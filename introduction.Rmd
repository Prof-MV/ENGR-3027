--- 
title: "ENGR-3027 Process Engineering"
author: "Martin Volkening"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [references.bib]
url: https://prof-mv.github.io/ENGR-3027/
cover-image: "images/Gemini_Generated_Image_dleggdleggdleggd.png"
description: |
  Lecture notes accompanying the course.
link-citations: yes
github-repo: Prof-MV/ENGR-3027
always_allow_html: true
---

```{r setup-index, include=FALSE}
source("R/helpers.R")
```

# Introduction {-}

Why are we studying this?

  *	Defining and identifying manufacturing processes is critical to understanding the role that automation plays and how to program an industrial process line.
  * What are some examples of a manufacturing process?
  *	What do we have or use that is manufactured?
  *	What is the biggest manufacturing change that you have experienced so far?

  *	Processes have changed throughout the centuries and have been driven by the four Industrial Revolutions.
  
  *	First Industrial Revolution – Coal in 1765
    * This transformed society from an agricultural base to an industrial base. Processes became mechanized and rather than hand made, products were manufactured. The discovery of coal and the development of the steam engine and metal forging transformed the way goods were created.
    
  * Second Industrial Revolution – Gas in 1870
    *The discovery of oil and electricity fueled the second industrial revolution. The discovery of oil lead to the invention of the combustion engine and new steel and chemical based products entered the manufacturing streams. Technological advances in communication were driven by the invention of the telegraph and later the telephone. Modes of transportation developed with the invention of the airplane and automobile. These discoveries helped to drive the advent of mass production which forever changed how items were produced.
    
  * Third Industrial Revolution – Electronics and Nuclear Energy in 1969
    *The third industrial revolution is dominated by the development of electronics and the beginning of the age of computers.
    *Technological developments were centered around four pillars of science: telecommunications, biotechnology, information technology and energy engineering.
    
  *	Fourth Industrial Revolution – Internet and AI
    * The fourth industrial revolution describes the current era of digitalization, automation, and advanced manufacturing technology. It's characterized by the convergence of emerging technologies, such as robotics, the Internet of Things (IoT), and 3D printing.
    
Check out these videos:

```{r video-industrial-rev-1, echo=FALSE, results='asis'}
embed_youtube("kpW9JcWxKq0", "The Four Industrial Revolutions")
```

and

```{r video-industrial-rev-2, echo=FALSE, results='asis'}
embed_youtube("okXk4Bnz2Lc", "Industry 4.0 Explained")
```

What is a Fifth Industrial Revolution going to look like?

```{r video-industrial-rev-5, echo=FALSE, results='asis'}
embed_youtube("sGI2FFm_8tw", "The Fifth Industrial Revolution")
```


Further Reading
[Whitepaper 'What is Manufacturing' by Intel](https://www.intel.com/content/www/us/en/newsroom/tech101/manufacturing-101-what-is-manufacturing.html#gs.hgplkf)

| Category                  | Grade Item                  | Type                  | Max. Points | Weight (%) |
|---------------------------|-----------------------------|-----------------------|-------------|------------|
| **Lab-Tutorial**          | **Lab-Tutorial**            | **Association**       | **48**      | **40**     |
| **Labs**                  | Lab-1                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-2                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-3                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-4                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-5                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-6                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-7                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-8                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-9                       | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-10                      | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-11                      | NumericSubmissions    | 48.33       | 8.33       |
|                           | Lab-12                      | NumericSubmissions    | 48.33       | 8.33       |
| **Assignments**           | **Assignments**             |                       | **12**      | **12**     |
|                           | Assignment-1                | NumericQuizzes        | 2           | 16.67      |
|                           | Assignment-2                | NumericQuizzes        | 2           | 16.67      |
|                           | Assignment-3                | NumericQuizzes        | 2           | 16.67      |
|                           | Assignment-4                | NumericQuizzes        | 2           | 16.67      |
|                           | Assignment-5                | NumericQuizzes        | 2           | 16.66      |
|                           | Assignment-6                | NumericQuizzes        | 2           | 16.66      |
| **Lab Pop-up Quizzes**    | **Lab Quizes**              |                       | **3**       | **3**      |
|                           | Lab Quiz-1                  | NumericQuizzes        | 0.5         | 16.66      |
|                           | Lab Quiz-2                  | NumericQuizzes        | 0.5         | 16.66      |
|                           | Lab Quiz-3                  | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lab Quiz-4                  | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lab Quiz-5                  | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lab Quiz-6                  | NumericQuizzes        | 0.5         | 16.67      |
| **Lecture Pop-up Quizzes**| **Lecture Quizes**          |                       | **3**       | **3 **     |
|                           | Lecture Quiz-1              | NumericQuizzes        | 0.5         | 16.66      |
|                           | Lecture Quiz-2              | NumericQuizzes        | 0.5         | 16.66      |
|                           | Lecture Quiz-3              | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lecture Quiz-4              | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lecture Quiz-5              | NumericQuizzes        | 0.5         | 16.67      |
|                           | Lecture Quiz-6              | NumericQuizzes        | 0.5         | 16.67      |
| **Midterm Test**          | **Mid Term Test**           | **NumericQuizzes**    | **40.5**    | **17**     |
| **Final Test**            | Final Test                  | NumericQuizzes        | 50          | 25         |
| **Calculated Grades**     | Midterm Grade               | Calculated            | —           | —          |
|                           | Final Calculated Grade      | —                     | 156.5       | 100        |

## Labs {-}
* Late penalty is 25% per lab session.
* Labs 1-5 must be completed before Week 7. 
* Bring your lab kit and PPE to every lab session.

## Assignments {-}
* 6 Assignments worth 2% each, for a total of 12%. 
* All are FOL quizzes, with at least one week open.

## Quizzes {-}
* 6 Lecture Quizzes and 6 Lab Quizzes.
* Quizzes are worth 0.5% each, for a total of 6%.
* Quizzes are given randomly throughout the term as a “pop quiz”.
* Quizzes are given at the start of the lab session (10 minute log in window) or at the end of the lecture.
* **You must be in attendance to write the quizzes.**

## Tests {-}
* During in-person lecture time (90 minutes). One midterm test worth 17%, one final test worth 25%.
* Both tests are cumulative and online, in-person.
* Closed-book with handwritten cheat sheet; details will be posted on FOL closer to the date.
* Kit calculators allowed.

## Other Grade Considerations {-}
In order to pass, two conditions must be met:
* Overall passing grade (50%).
* Attendance and submission of the mandatory labs (labs 1 though 10)

## How to succeed {-}
* Come to class and lab sessions Participate
* Complete examples given in class
* Do the homework and assigned reading 
* Attend office hours

## Cheating and Plagiarism {-}
Students must write their reports and assignments in their **own words**. Whenever students take an idea or a passage from another author, they must acknowledge their debt both by using quotation marks where appropriate and by proper referencing such as footnotes or citations. This includes non-published sources, such as work completed in previous years or a classmate’s work. 
**This includes the use of "AI" Technologies.**

## FOL {-}
* Lectures will be posted after class, as well as supplementary material.
* Assignments and lab manuals will be posted ahead of time. You will always have at least one week’s notice.
* All announcements will be made through the FOL course.

## Accessibility {-}
Please contact me if you require material in an alternate format or if any other arrangements can make this course more accessible to you.

Consider contacting Accessibility Services for specifics on accommodations that you may be eligible for.
  M-Fr 8:30-4:30
  F2010, 519-452-4282, accessibility@fanshawec.ca

## Fanshawe’s Recording Policy {-}
It is forbidden for students to record without written permission from the instructor (and) as an approved accommodation. Recording without permission or sharing a recording will result in disciplinary action.

If a class is being recorded with permission: it will be announced, and alternate means to participation will be made available to protect students’ privacy.



```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'dplyr', 'kableExtra', 'webshot2'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# Types of Manufacturing Processes

------------------------------------------------------------------------

```{r setup-ch1, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
source("R/helpers.R")
```

## Learning Objectives

By the end of this chapter, you will be able to:

1. Identify and classify the seven main types of manufacturing processes
2. Select appropriate manufacturing processes based on material, volume, and precision requirements
3. Compare cost, speed, and quality trade-offs between process types
4. Recognize manufacturing processes used in automotive, food, and defense industries
5. Apply process selection criteria to real-world manufacturing scenarios

------------------------------------------------------------------------

## Introduction to Manufacturing Processes

Manufacturing is defined as the conversion of raw materials into finished goods on a large scale using man and machine. **Manufacturing processes** are the specific methods used for this conversion. Based on product requirements, different types of manufacturing processes are selected to achieve the required output with optimal cost, quality, and efficiency.

```{r manufacturing-overview, echo=FALSE, fig.align="center", fig.cap="Overview of Manufacturing Process Categories", fig.width=10, fig.height=6}
# Create an overview visualization of manufacturing processes
process_categories <- data.frame(
  Category = c("Casting", "Molding", "Forming", "Machining", "Joining", "Coating", "Additive"),
  Primary_Material = c("Metals", "Plastics", "Metals", "All", "All", "All", "All"),
  Volume = c(4, 5, 4, 2, 3, 3, 1),
  Complexity = c(3, 4, 2, 5, 3, 2, 5),
  x_pos = c(1, 2, 3, 4, 5, 6, 7)
)

ggplot(process_categories, aes(x = x_pos, y = 1)) +
  geom_tile(aes(fill = Category), width = 0.9, height = 0.6, color = "white", size = 2) +
  geom_text(aes(label = Category), color = "white", fontface = "bold", size = 4) +
  scale_fill_manual(values = c("#E74C3C", "#3498DB", "#2ECC71", "#9B59B6", "#F39C12", "#1ABC9C", "#34495E")) +
  labs(title = "Seven Main Categories of Manufacturing Processes",
       subtitle = "Each category contains multiple specific processes for different applications") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 11),
    legend.position = "none"
  )
```

<details>
<summary>Why do we need different manufacturing processes?</summary>

Different products require different manufacturing approaches based on:

- **Material type**: Metals, plastics, ceramics, composites
- **Production volume**: One-off prototypes vs. millions of units
- **Geometric complexity**: Simple shapes vs. intricate details
- **Precision requirements**: Loose tolerances vs. micron-level accuracy
- **Cost constraints**: Budget limitations affect process selection
- **Lead time**: How quickly parts are needed

No single process is optimal for all situations!

</details>

A good video summarizing 6 of the 7 manufacturing processes is linked below (Coating/Plating is not covered):

```{r video-manufacturing-overview, echo=FALSE, results='asis'}
embed_youtube("Um_g8sQ_p3Y", "Manufacturing Processes Overview")
```

------------------------------------------------------------------------

## Process Selection Framework

Before examining each process type, it's important to understand how engineers select the right manufacturing process. The following visualization shows the key factors:

```{r process-selection-matrix, echo=FALSE, fig.align="center", fig.cap="Process Selection Based on Volume and Complexity", fig.width=10, fig.height=7}
# Create process selection visualization
selection_data <- data.frame(
  Process = c("Sand Casting", "Die Casting", "Investment Casting",
              "Injection Molding", "Blow Molding", "Thermoforming",
              "Forging", "Stamping", "Extrusion",
              "CNC Machining", "3D Printing", "Manual Assembly"),
  Volume = c(2, 5, 2, 5, 4, 3, 4, 5, 5, 2, 1, 2),
  Complexity = c(3, 3, 5, 4, 2, 2, 2, 2, 1, 5, 5, 3),
  Category = c("Casting", "Casting", "Casting",
               "Molding", "Molding", "Molding",
               "Forming", "Forming", "Forming",
               "Machining", "Additive", "Joining")
)

ggplot(selection_data, aes(x = Volume, y = Complexity, color = Category)) +
  geom_point(size = 6, alpha = 0.8) +
  geom_text(aes(label = Process), vjust = -1, size = 3, fontface = "bold") +
  scale_x_continuous(limits = c(0, 6), breaks = 1:5,
                     labels = c("Prototype\n(1-10)", "Low\n(10-1K)", "Medium\n(1K-10K)",
                               "High\n(10K-100K)", "Mass\n(100K+)")) +
  scale_y_continuous(limits = c(0, 6), breaks = 1:5,
                     labels = c("Simple", "Low", "Medium", "High", "Very High")) +
  scale_color_manual(values = c("Additive" = "#9B59B6", "Casting" = "#E74C3C", "Forming" = "#2ECC71",
                                "Joining" = "#1ABC9C", "Machining" = "#3498DB", "Molding" = "#F39C12")) +
  labs(x = "Production Volume", y = "Part Complexity",
       title = "Manufacturing Process Selection Guide",
       subtitle = "Choose processes based on volume requirements and part complexity") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 11),
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

```{r process-comparison-table, echo=FALSE}
comparison_data <- tibble(
  `Process Type` = c("Casting", "Molding", "Forming", "Machining", "Joining", "Coating", "Additive"),
  `Typical Materials` = c("Metals, alloys", "Plastics, rubber", "Metals, sheet", "All materials", "All materials", "All materials", "Plastics, metals, ceramics"),
  `Production Volume` = c("Low to High", "Medium to Very High", "Medium to Very High", "Low to Medium", "All volumes", "All volumes", "Prototype to Low"),
  `Typical Tolerance` = c("±0.5-2mm", "±0.1-0.5mm", "±0.1-1mm", "±0.01-0.1mm", "Varies", "N/A", "±0.1-0.3mm"),
  `Tooling Cost` = c("Medium-High", "High", "Medium-High", "Low", "Low", "Low", "None"),
  `Unit Cost at Volume` = c("Low", "Very Low", "Low", "High", "Medium", "Low", "High")
)

comparison_data %>%
  kable(format = "html", caption = "Manufacturing Process Comparison Summary") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered", "responsive"),
    full_width = TRUE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

------------------------------------------------------------------------

## 1. Casting Processes

**Casting** is a process of pouring liquid metal into a mold containing the hollow shape of the desired outcome. It uses sprue, gates, and runners to direct the molten metal flow.

```{r casting-comparison, echo=FALSE, fig.align="center", fig.cap="Comparison of Casting Processes", fig.width=10, fig.height=5}
casting_data <- data.frame(
  Process = c("Sand Casting", "Die Casting", "Investment Casting", "Permanent Mold", "Centrifugal", "Shell Molding"),
  Tooling_Cost = c(1, 5, 3, 4, 3, 2),
  Production_Rate = c(1, 5, 2, 3, 2, 3),
  Surface_Finish = c(1, 4, 5, 3, 3, 4),
  Complexity = c(3, 3, 5, 2, 1, 3)
)

casting_long <- casting_data %>%
  pivot_longer(cols = -Process, names_to = "Metric", values_to = "Score") %>%
  mutate(Metric = gsub("_", " ", Metric))

ggplot(casting_long, aes(x = Metric, y = Score, fill = Process)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "Med-Low", "Medium", "Med-High", "High")) +
  labs(title = "Casting Process Comparison",
       subtitle = "Comparing key characteristics across casting methods",
       x = "", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 15, hjust = 1),
    legend.position = "bottom"
  )
```

### Sand Casting

Sand casting is a metal casting process that uses sand as the mold material. This process has a low production rate as the sand mold must be destroyed to remove the part. However, it is economical for low-volume production.

**Process Steps:**

1. Create a pattern (usually wood or metal)
2. Pack sand around the pattern to form the mold
3. Remove the pattern, leaving a cavity
4. Pour molten metal into the cavity
5. Allow solidification
6. Break the sand mold to remove the casting

**Advantages:** Low tooling cost, can produce very large parts, suitable for all metals

**Disadvantages:** Poor surface finish, loose tolerances, slow cycle time

**Examples:** Engine blocks, machine tool bases, cylinder heads, pump housings, large gears

<details>
<summary>Discussion: Why is sand casting still widely used despite its limitations?</summary>

Sand casting remains popular because:

1. **Low startup cost** - A wood pattern costs hundreds vs. steel dies costing tens of thousands
2. **Flexibility** - Easy to modify patterns for design changes
3. **Size capability** - Can cast parts weighing several tons
4. **Material versatility** - Works with nearly any metal
5. **Short lead time** - Parts can be produced in days vs. weeks for die casting

For prototypes and low-volume production (< 500 parts), sand casting is often the most economical choice even with its lower quality.

</details>

### Die Casting

Die casting is used for producing metal parts where high precision is required. Molten metal is forced under high pressure into reusable metal dies, enabling high-volume production.

```{r video-die-casting, echo=FALSE, results='asis'}
embed_youtube("0oibUY8KUQM", "Die Casting Process")
```

**Process:**

1. Steel molds (dies) are machined to the part shape
2. Dies are mounted in a die casting machine
3. Molten metal is injected under high pressure (10-175 MPa)
4. Metal solidifies rapidly due to die cooling
5. Part is ejected and the cycle repeats

**Advantages:** Excellent dimensional accuracy, smooth surface finish, high production rates (up to 400 shots/hour)

**Disadvantages:** High die cost ($50,000-$500,000), limited to non-ferrous metals, porosity issues

**Examples:** Engine components, transmission housings, electronic enclosures, power tool housings

### Investment Casting (Lost-Wax)

Investment casting produces complex, precision parts by creating a wax pattern that is "invested" (surrounded) with ceramic slurry, then melted out to leave a mold cavity.

```{r video-investment-casting, echo=FALSE, results='asis'}
embed_youtube("QtxVdC7pBQM", "Investment Casting Process")
```

**Advantages:** Excellent surface finish, tight tolerances (±0.1%), complex geometries, any castable metal

**Disadvantages:** Expensive, slow cycle time, limited part size

**Examples:** Turbine blades, aerospace components, medical implants, jewelry, firearm components

<details>
<summary>Why do aerospace companies pay premium prices for investment casting?</summary>

Investment casting is essential for aerospace because:

1. **Complex internal passages** - Turbine blades have intricate cooling channels
2. **Superior metallurgy** - Controlled solidification produces better grain structure
3. **Near-net shape** - Minimizes machining of expensive superalloys
4. **Weight savings** - Can create hollow structures impossible with other methods
5. **Material options** - Works with titanium, Inconel, and other aerospace alloys

A single turbine blade might cost $1,000-$5,000, but there's no other process that can produce the required geometry and performance.

</details>

### Centrifugal Casting

Centrifugal casting spins molten metal in a rotating die, using centrifugal force to distribute the metal and float impurities to the inner surface.

**Applications:** Pipes, tubes, cylinder liners, bushings, rings

### Permanent Mold Casting

Uses reusable metal molds with gravity or low-pressure filling. Good for medium-volume production of aluminum and copper alloy parts.

**Applications:** Pistons, gear housings, wheels, pipe fittings

### Shell Molding

Uses resin-coated sand that forms a thin, strong shell around a heated pattern. Better dimensional accuracy than sand casting.

**Applications:** Gear housings, cylinder heads, connecting rods

------------------------------------------------------------------------

## 2. Molding Processes

**Molding** uses a rigid frame to shape hot liquid or ductile raw material. It is predominantly used for plastics and rubber products.

```{r molding-volume-chart, echo=FALSE, fig.align="center", fig.cap="Molding Process Selection by Production Volume", fig.width=9, fig.height=5}
molding_data <- data.frame(
  Process = c("Injection Molding", "Blow Molding", "Rotational Molding", "Thermoforming", "Extrusion"),
  Min_Volume = c(10000, 5000, 100, 500, 1000),
  Max_Volume = c(10000000, 1000000, 50000, 500000, 10000000),
  Typical = c(100000, 50000, 5000, 10000, 500000)
)

ggplot(molding_data, aes(x = reorder(Process, -Typical), y = Typical)) +
  geom_bar(stat = "identity", fill = "#3498DB", width = 0.6) +
  geom_errorbar(aes(ymin = Min_Volume, ymax = Max_Volume), width = 0.2, color = "#2C3E50") +
  scale_y_log10(labels = scales::comma) +
  labs(title = "Economical Production Volumes for Molding Processes",
       subtitle = "Error bars show typical volume range",
       x = "", y = "Annual Production Volume (log scale)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 20, hjust = 1)
  ) +
  coord_flip()
```

### Injection Molding

Injection molding is the most common process for manufacturing plastic parts. Plastic pellets are melted and injected under high pressure into a mold cavity.

```{r video-injection-molding, echo=FALSE, results='asis'}
embed_youtube("RMjtmsr3CqA", "Injection Molding Process")
```

**Process Cycle:**

1. **Clamping** - Mold halves are clamped together
2. **Injection** - Molten plastic is injected into the cavity
3. **Cooling** - Part solidifies in the mold
4. **Ejection** - Part is pushed out by ejector pins

**Cycle times:** 10-60 seconds typical, as fast as 2 seconds for small parts

**Examples:** Automotive dashboards, phone cases, medical devices, food containers, toys

```{r injection-molding-cost, echo=TRUE}
# Injection Molding Cost Analysis Example
# Comparing costs at different production volumes

mold_cost <- 50000  # Typical mold cost in dollars
material_cost_per_kg <- 2.50  # ABS plastic
part_weight_kg <- 0.1
cycle_time_sec <- 30
machine_rate_per_hour <- 75  # Machine + operator cost

# Calculate cost per part at different volumes
volumes <- c(1000, 10000, 50000, 100000, 500000)

cost_analysis <- data.frame(
  Volume = volumes,
  Mold_Per_Part = mold_cost / volumes,
  Material = part_weight_kg * material_cost_per_kg,
  Processing = (cycle_time_sec / 3600) * machine_rate_per_hour
)

cost_analysis$Total_Per_Part <- cost_analysis$Mold_Per_Part +
                                 cost_analysis$Material +
                                 cost_analysis$Processing

cat("Injection Molding Cost Breakdown:\n")
cat("================================\n")
for(i in 1:nrow(cost_analysis)) {
  cat(sprintf("At %s parts: $%.2f per part (Tooling: $%.2f, Material: $%.2f, Processing: $%.2f)\n",
              format(cost_analysis$Volume[i], big.mark=","),
              cost_analysis$Total_Per_Part[i],
              cost_analysis$Mold_Per_Part[i],
              cost_analysis$Material[i],
              cost_analysis$Processing[i]))
}
```

<details>
<summary>Discussion: When does injection molding become cost-effective vs. 3D printing?</summary>

**Break-even analysis:**

- 3D printing: ~$5-20 per part (no tooling, slow production)
- Injection molding: $50,000 tooling + $0.50-2 per part

**Break-even point:** Approximately 5,000-10,000 parts

**Rule of thumb:**
- < 500 parts: 3D printing or machining
- 500-5,000 parts: Consider soft tooling (aluminum molds)
- > 5,000 parts: Steel injection molds become economical

</details>

### Blow Molding

Blow molding creates hollow plastic parts by inflating a heated plastic tube (parison) inside a mold cavity.

**Types:**
- **Extrusion blow molding** - Parison extruded, then blown
- **Injection blow molding** - Preform injection molded, then blown
- **Stretch blow molding** - Preform stretched and blown (PET bottles)

**Examples:** Bottles, containers, fuel tanks, automotive ducts, toys

### Rotational Molding

Creates hollow parts by rotating a mold on two axes while heating, causing plastic powder to melt and coat the interior surface.

**Advantages:** Low tooling cost, no internal stresses, large hollow parts

**Examples:** Kayaks, playground equipment, tanks, coolers

### Thermoforming

Heats a plastic sheet until pliable, then forms it over a mold using vacuum, pressure, or mechanical force.

**Examples:** Packaging (blister packs), disposable cups, refrigerator liners

### Powder Metallurgy

Though involving metal, powder metallurgy uses molding principles. Metal powders are compacted in dies and sintered (heated below melting point) to fuse particles.

**Advantages:** Near-net shape, complex geometries, controlled porosity

**Examples:** Self-lubricating bearings, gears, filters, magnets

------------------------------------------------------------------------

## 3. Forming Processes

**Forming** uses mechanical forces (compression, tension, shear) to shape material without removing any material. This preserves material grain structure and can improve mechanical properties.

```{r forming-forces, echo=FALSE, fig.align="center", fig.cap="Types of Forming Forces", fig.width=9, fig.height=4}
# Visualization of forming force types
force_data <- data.frame(
  Type = c("Compression", "Tension", "Shear", "Bending"),
  Process = c("Forging, Rolling", "Drawing, Stretching", "Shearing, Blanking", "Brake Forming"),
  x = c(1, 2, 3, 4)
)

ggplot(force_data, aes(x = x, y = 1)) +
  geom_tile(aes(fill = Type), width = 0.8, height = 0.5, color = "black") +
  geom_text(aes(label = Type), y = 1.1, fontface = "bold", size = 4) +
  geom_text(aes(label = Process), y = 0.9, size = 3, color = "gray30") +
  scale_fill_manual(values = c("#E74C3C", "#F39C12", "#3498DB", "#2ECC71")) +
  labs(title = "Forming Process Classification by Primary Force Type") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "none"
  )
```

### Forging

Forging uses compressive forces from hammers or presses to shape heated metal. Forged parts have superior strength due to aligned grain structure.

```{r video-forging, echo=FALSE, results='asis'}
embed_youtube("o4vQJnPwgiA", "Forging Process")
```

**Types of Forging:**
- **Open-die forging** - Simple shapes, large parts
- **Closed-die (impression) forging** - Complex shapes, high volume
- **Cold forging** - Room temperature, excellent finish
- **Hot forging** - Heated material, easier deformation

**Examples:** Crankshafts, connecting rods, gears, aircraft structural components, hand tools

<details>
<summary>Why are aircraft landing gear forgings so expensive?</summary>

Aircraft landing gear forgings can cost $100,000+ because:

1. **Material** - High-strength steel or titanium alloys
2. **Size** - Large parts require massive presses (50,000+ tons)
3. **Certification** - Extensive testing and documentation
4. **Grain flow** - Must be optimized for fatigue resistance
5. **NDT requirements** - 100% ultrasonic and magnetic particle inspection
6. **Low volume** - Only a few hundred per aircraft type per year

The forged grain structure provides 20-40% better fatigue life than equivalent castings or machined parts.

</details>

### Stamping

Stamping uses dies and presses to form, cut, or shape sheet metal. Modern stamping lines can produce 1,000+ parts per hour.

**Operations include:**
- **Blanking** - Cutting flat shapes from sheet
- **Piercing** - Punching holes
- **Drawing** - Forming cup shapes
- **Bending** - Creating angles
- **Coining** - Fine detail forming

**Examples:** Automotive body panels, appliance housings, electronic enclosures

### Bending

Bending uses press brakes to create angular shapes in sheet metal.

**Key formula:**
$$\text{Bend Allowance} = \frac{\pi \times A \times (R + K \times T)}{180}$$

Where: A = bend angle, R = inside radius, T = material thickness, K = K-factor (typically 0.3-0.5)

### Shearing

Shearing cuts sheet metal without chip formation using opposed cutting edges.

**Types:** Blanking, piercing, trimming, notching, slitting

### Rolling

Reduces material thickness by passing through rotating rolls. Used for sheet, plate, and structural shapes.

### Extrusion (Metal)

Forces material through a die to create constant cross-section profiles.

**Examples:** Aluminum window frames, heat sinks, structural shapes

------------------------------------------------------------------------

## 4. Machining Processes

**Machining** removes material using cutting tools to achieve precise dimensions and surface finishes. It is the most versatile manufacturing process but typically has higher per-part costs.

```{r machining-comparison, echo=FALSE, fig.align="center", fig.cap="Machining Process Capabilities", fig.width=10, fig.height=5}
machining_data <- data.frame(
  Process = c("Turning", "Milling", "Drilling", "Grinding", "EDM", "Laser Cutting"),
  Tolerance_um = c(25, 25, 50, 2, 5, 100),
  Surface_Ra = c(1.6, 1.6, 3.2, 0.2, 0.8, 3.2),
  Material_Removal = c(5, 4, 3, 1, 1, 2)  # Relative rate
)

machining_long <- machining_data %>%
  mutate(
    `Tolerance (μm)` = Tolerance_um,
    `Surface Finish (Ra μm)` = Surface_Ra
  ) %>%
  select(Process, `Tolerance (μm)`, `Surface Finish (Ra μm)`) %>%
  pivot_longer(cols = -Process, names_to = "Metric", values_to = "Value")

ggplot(machining_long, aes(x = Process, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("#3498DB", "#E74C3C")) +
  facet_wrap(~Metric, scales = "free_y") +
  labs(title = "Machining Process Precision Comparison",
       subtitle = "Lower values indicate better precision",
       x = "", y = "Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )
```

### Turning

Rotates the workpiece while a cutting tool moves to create cylindrical shapes.

**Performed on lathes or turning centers**

**Operations:** Facing, turning, boring, threading, grooving, parting

### Milling

Rotates a cutting tool while moving the workpiece to remove material. The most versatile machining process.

**Types:**
- **Peripheral milling** - Cutter axis parallel to surface
- **Face milling** - Cutter axis perpendicular to surface
- **End milling** - Creates slots, pockets, contours

### Drilling

Creates cylindrical holes using rotating drill bits.

**Related operations:** Reaming (sizing), boring (enlarging), tapping (threading)

### Grinding

Uses abrasive wheels for precision finishing. Achieves the finest tolerances and surface finishes.

**Types:** Surface grinding, cylindrical grinding, centerless grinding

### Electrical Discharge Machining (EDM)

Uses electrical sparks to erode conductive materials. Essential for hardened materials and complex geometries.

**Applications:** Injection mold cavities, dies, aerospace components

<details>
<summary>When should you use EDM instead of conventional machining?</summary>

**Choose EDM when:**

1. **Hardened materials** - Can machine 60+ HRC steels that would destroy cutting tools
2. **Complex internal features** - Wire EDM cuts intricate shapes
3. **Tight corners** - Can achieve sharp internal corners impossible with rotary tools
4. **Fragile parts** - No cutting forces (non-contact process)
5. **Thin walls** - No deflection from tool pressure

**Limitations:**
- Slow material removal (grams/hour vs. kg/hour for milling)
- Only works on conductive materials
- Recast layer may need removal
- Higher cost per part

</details>

------------------------------------------------------------------------

## 5. Joining Processes

**Joining** combines two or more components into a single assembly. Methods range from permanent (welding) to removable (fasteners).

```{r joining-comparison, echo=FALSE}
joining_data <- tibble(
  Process = c("Arc Welding", "Resistance Welding", "Laser Welding", "Brazing", "Soldering", "Adhesive Bonding", "Mechanical Fastening"),
  `Joint Strength` = c("Excellent", "Excellent", "Excellent", "Good", "Fair", "Good", "Excellent"),
  `Dissimilar Metals` = c("Limited", "Limited", "Limited", "Yes", "Yes", "Yes", "Yes"),
  `Automation` = c("Medium", "High", "High", "Medium", "High", "High", "High"),
  `Typical Applications` = c("Structural steel, pressure vessels", "Auto body panels, wire mesh", "Electronics, medical devices", "Carbide tooling, HVAC", "Electronics, plumbing", "Composites, glass, plastics", "All industries")
)

joining_data %>%
  kable(format = "html", caption = "Joining Process Comparison") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered"),
    full_width = TRUE
  ) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

### Welding

Melts and fuses base materials together, often with added filler metal.

**Common Types:**
- **MIG (GMAW)** - Gas Metal Arc Welding - fast, easy automation
- **TIG (GTAW)** - Gas Tungsten Arc Welding - precise, clean welds
- **Stick (SMAW)** - Shielded Metal Arc Welding - versatile, field use
- **Resistance** - Uses electrical resistance heating
- **Laser/Electron Beam** - High precision, deep penetration

### Brazing and Soldering

Joins metals using a filler metal with a lower melting point than the base materials. The base materials do not melt.

- **Brazing** - Filler melts above 450°C (840°F)
- **Soldering** - Filler melts below 450°C

### Adhesive Bonding

Uses chemical adhesives to join materials. Essential for composites, glass, and dissimilar materials.

**Advantages:** Distributes stress, joins dissimilar materials, seals against fluids

**Disadvantages:** Surface preparation critical, limited temperature resistance, aging concerns

### Mechanical Fastening

Uses bolts, screws, rivets, or clips. Allows disassembly for maintenance.

------------------------------------------------------------------------

## 6. Surface Treatment and Coating

**Coating and surface treatment** processes protect parts from corrosion, wear, or environmental damage, and can improve appearance or electrical properties.

```{r coating-processes, echo=FALSE}
coating_data <- tibble(
  Process = c("Electroplating", "Anodizing", "Powder Coating", "Painting", "Hot Dip Galvanizing", "PVD/CVD", "Thermal Spray"),
  `Typical Thickness` = c("1-50 μm", "5-100 μm", "50-150 μm", "25-75 μm", "45-85 μm", "1-10 μm", "100-500 μm"),
  `Base Material` = c("Conductive metals", "Aluminum", "Any metal", "Any", "Steel", "Any", "Any"),
  `Primary Benefit` = c("Corrosion, appearance", "Corrosion, hardness", "Corrosion, appearance", "Appearance", "Corrosion", "Wear, hardness", "Wear, thermal barrier"),
  Industry = c("Automotive, electronics", "Aerospace, construction", "Appliances, furniture", "All", "Construction, automotive", "Tooling, aerospace", "Aerospace, energy")
)

coating_data %>%
  kable(format = "html", caption = "Surface Treatment and Coating Processes") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered"),
    full_width = TRUE
  ) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

### Electroplating

Deposits metal coating using electrical current. Common coatings include chrome, nickel, zinc, gold, and silver.

### Anodizing

Electrochemically grows an oxide layer on aluminum. Provides corrosion resistance and can be dyed various colors.

### Powder Coating

Applies dry powder electrostatically, then cures with heat. Produces thick, durable, attractive finishes.

### Galvanizing

Coats steel with zinc for corrosion protection. Hot-dip galvanizing provides excellent outdoor durability.

------------------------------------------------------------------------

## 7. Additive Manufacturing (3D Printing)

**Additive manufacturing** builds parts layer-by-layer from digital models. It's the opposite of machining (subtractive manufacturing).

```{r am-processes, echo=FALSE, fig.align="center", fig.cap="Additive Manufacturing Process Comparison", fig.width=10, fig.height=6}
am_data <- data.frame(
  Process = c("FDM", "SLA", "SLS", "DMLS/SLM", "Binder Jetting", "PolyJet"),
  Material = c("Thermoplastics", "Photopolymers", "Nylon, Polymers", "Metals", "Metals, Sand", "Photopolymers"),
  Accuracy = c(2, 5, 3, 4, 3, 5),
  Speed = c(3, 2, 3, 1, 4, 2),
  Cost = c(5, 3, 2, 1, 3, 2),
  Strength = c(3, 2, 4, 5, 4, 2)
)

am_long <- am_data %>%
  select(-Material) %>%
  pivot_longer(cols = -Process, names_to = "Metric", values_to = "Score")

ggplot(am_long, aes(x = Metric, y = Score, fill = Process)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(breaks = 1:5, labels = c("Poor", "Fair", "Good", "Very Good", "Excellent")) +
  labs(title = "Additive Manufacturing Process Comparison",
       subtitle = "Comparing key characteristics across 3D printing technologies",
       x = "", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```

```{r video-3d-printing, echo=FALSE, results='asis'}
  embed_youtube("Vx0Z6LplaMU", "How 3D Printing Works")
```


### FDM (Fused Deposition Modeling)

Extrudes thermoplastic filament through a heated nozzle. Most common desktop 3D printing technology.

**Materials:** PLA, ABS, PETG, Nylon, TPU

### SLA (Stereolithography)

Uses UV laser to cure liquid photopolymer resin. Excellent surface finish and detail.

### SLS (Selective Laser Sintering)

Fuses powder material with a laser. Produces strong functional parts without support structures.

### Metal 3D Printing (DMLS/SLM)

Fuses metal powder with high-power lasers. Used for aerospace, medical, and tooling applications.

<details>
<summary>When does metal 3D printing make sense vs. traditional manufacturing?</summary>

**Metal 3D printing is advantageous when:**

1. **Complex internal features** - Conformal cooling channels in molds
2. **Topology optimization** - Organic shapes that minimize weight
3. **Consolidation** - Combining multiple parts into one
4. **Low volume** - Too few parts to justify tooling
5. **Custom/one-off** - Medical implants, prototypes

**Traditional manufacturing is better when:**
- High volumes (> 100-1000 parts depending on complexity)
- Simple geometries
- Large parts (3D print beds are limited)
- Maximum strength required (forging still superior)

**Cost comparison:**
- Simple bracket: $5 machined vs. $50+ 3D printed
- Complex aerospace part: $10,000 machined vs. $3,000 3D printed

</details>

------------------------------------------------------------------------

## Industry Applications

```{r industry-table, echo=FALSE}
industry_examples <- tibble(
  `Process` = c("Die Casting", "Injection Molding", "Forging", "Stamping", "Machining", "Welding", "Powder Coating", "3D Printing"),
  `Automotive` = c("Engine blocks, transmission cases", "Dashboard, interior trim, connectors", "Crankshafts, connecting rods, gears", "Body panels, structural components", "Engine components, precision parts", "Body structure, exhaust systems", "Wheels, chassis components", "Prototypes, custom fixtures"),
  `Food Industry` = c("Equipment housings", "Packaging, containers, caps", "Mixer blades, pump impellers", "Cans, trays, lids", "Valves, fittings", "Tanks, piping, conveyors", "Equipment frames", "Custom tooling, fixtures"),
  `Defense/Aerospace` = c("Aircraft structural components", "Connectors, housings, switches", "Landing gear, turbine disks", "Aircraft skins, missile bodies", "Precision weapons components", "Aircraft structures, armor", "Military vehicles, equipment", "Turbine blades, brackets, tooling")
)

industry_examples %>%
  kable(format = "html", caption = "Manufacturing Process Applications by Industry") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered"),
    full_width = TRUE
  ) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D4E6F1") %>%
  column_spec(2, background = "#FCF3CF") %>%
  column_spec(3, background = "#D5F5E3") %>%
  column_spec(4, background = "#FADBD8")
```

------------------------------------------------------------------------

## Sustainability in Manufacturing

Modern manufacturing must consider environmental impact. Here's how different processes compare:

```{r sustainability, echo=FALSE, fig.align="center", fig.cap="Environmental Considerations by Process Type", fig.width=10, fig.height=5}
sustainability_data <- data.frame(
  Process = c("Casting", "Molding", "Forming", "Machining", "Joining", "Additive"),
  Material_Waste = c(2, 1, 1, 4, 1, 2),
  Energy_Use = c(5, 3, 4, 2, 4, 3),
  Recyclability = c(5, 3, 5, 5, 4, 2)
)

sustainability_long <- sustainability_data %>%
  pivot_longer(cols = -Process, names_to = "Factor", values_to = "Score") %>%
  mutate(Factor = gsub("_", " ", Factor))

ggplot(sustainability_long, aes(x = Process, y = Score, fill = Factor)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("#27AE60", "#E74C3C", "#3498DB")) +
  scale_y_continuous(breaks = 1:5, labels = c("Very Low", "Low", "Medium", "High", "Very High")) +
  labs(title = "Sustainability Comparison of Manufacturing Processes",
       subtitle = "Lower Material Waste & Energy Use is better; Higher Recyclability is better",
       x = "", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```

<details>
<summary>Discussion: How can manufacturers reduce environmental impact?</summary>

**Strategies for sustainable manufacturing:**

1. **Near-net-shape processes** - Casting, forging, and molding reduce machining waste
2. **Closed-loop recycling** - Reprocess scrap material on-site
3. **Energy-efficient equipment** - Modern machines use 30-50% less energy
4. **Additive manufacturing** - Only uses material where needed
5. **Water-based coatings** - Replace solvent-based paints
6. **Lean manufacturing** - Reduces overproduction and waste
7. **Life cycle assessment** - Consider total environmental impact

**Example:** Aluminum die casting recycles 95%+ of sprues and runners, while machining from billet may waste 80% of material.

</details>

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: Process Identification</summary>

**A company needs to produce 50,000 aluminum housings per year. Each housing is a complex shape with internal fins for heat dissipation. The surface must be smooth and dimensions must be within ±0.3mm. Which process would you recommend?**

**Answer:** **Die Casting** is the best choice because:
- High volume (50,000/year) justifies tooling cost
- Aluminum is ideal for die casting
- Complex internal features are possible
- ±0.3mm tolerance is achievable
- Good surface finish without secondary operations

Alternative: If volumes were lower (< 5,000), investment casting might be considered.

</details>

<details>
<summary>Question 2: Cost Comparison</summary>

**Calculate the break-even point between 3D printing and injection molding for a small plastic part:**
- 3D printing: $8 per part (no tooling)
- Injection molding: $25,000 mold + $0.50 per part

**Answer:**
Let n = number of parts

Break-even: $8n = $25,000 + $0.50n

$7.50n = $25,000

n = 3,333 parts

**Below 3,333 parts:** 3D printing is cheaper
**Above 3,333 parts:** Injection molding is cheaper

At 10,000 parts:
- 3D printing: $80,000
- Injection molding: $30,000

</details>

<details>
<summary>Question 3: Material Selection</summary>

**Match each material/product to the most appropriate manufacturing process:**

a) Stainless steel surgical instrument
b) Large plastic kayak
c) Titanium jet engine bracket
d) Aluminum beverage can

**Answers:**

a) **Investment casting** or **machining** - Complex shapes, high precision, excellent surface finish
b) **Rotational molding** - Large hollow plastic part, low tooling cost
c) **Additive manufacturing (DMLS)** or **forging** - Complex geometry, lightweight, strength critical
d) **Deep drawing (stamping)** - Very high volume, thin-wall cylinder

</details>

<details>
<summary>Question 4: Process Selection Scenario</summary>

**You need to manufacture a new product with these requirements:**
- Quantity: 200 units for initial market test
- Material: ABS plastic
- Size: 150mm × 100mm × 50mm
- Tolerance: ±0.5mm
- Surface: Smooth, will be painted

**What process would you recommend and why?**

**Answer:** **3D Printing (FDM or SLA)** would be most appropriate because:

1. **Low quantity (200)** - Injection molding tooling ($30,000+) not justified
2. **Market test phase** - Design may change based on feedback
3. **Quick turnaround** - Parts in days vs. weeks for tooling
4. **Tolerances achievable** - ±0.5mm is within FDM capabilities
5. **Post-processing acceptable** - Parts will be painted anyway

**Cost comparison:**
- FDM: 200 × $15 = $3,000
- Injection molding: $30,000 + (200 × $1) = $30,200

If the product succeeds and volume increases to 10,000+, transition to injection molding.

</details>

<details>
<summary>Question 5: Hybrid Manufacturing</summary>

**What is hybrid manufacturing and when is it used?**

**Answer:** **Hybrid manufacturing** combines additive and subtractive processes in a single machine or workflow.

**Common combinations:**
- 3D print near-net shape → CNC machine critical surfaces
- Cast blank → Machine precision features
- Forge rough shape → Machine final dimensions

**Benefits:**
- Reduced material waste vs. pure machining
- Better precision than pure additive
- Faster than pure machining for complex parts

**Example:** Aerospace companies 3D print titanium brackets, then machine mounting surfaces to achieve tight tolerances. This can reduce material waste by 90% compared to machining from billet.

</details>

------------------------------------------------------------------------

## Summary

```{r summary-table-mfg, echo=FALSE}
summary_data <- tibble(
  `Process Category` = c("Casting", "Molding", "Forming", "Machining", "Joining", "Coating", "Additive"),
  `Key Principle` = c("Pour liquid into mold", "Shape heated/softened material", "Deform solid with force", "Remove material with tools", "Combine multiple parts", "Apply protective layer", "Build layer by layer"),
  `Best For` = c("Complex metal shapes, medium-high volume", "Plastic parts, very high volume", "Strong metal parts, high volume", "Precision parts, any material", "Assembly of components", "Corrosion/wear protection", "Prototypes, complex geometry"),
  `Typical Industries` = c("Automotive, aerospace", "Consumer products, packaging", "Automotive, construction", "All industries", "All industries", "All industries", "Aerospace, medical, prototyping")
)

summary_data %>%
  kable(format = "html", caption = "Manufacturing Processes Summary") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered"),
    full_width = TRUE
  ) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE)
```

### Key Takeaways

1. **No single process is best for everything** - Selection depends on material, volume, complexity, and cost constraints
2. **Volume drives economics** - High tooling costs require high volumes to amortize
3. **Consider the complete supply chain** - Secondary operations, assembly, and finishing affect total cost
4. **Sustainability matters** - Modern manufacturing must minimize waste and energy use
5. **Hybrid approaches are growing** - Combining processes optimizes cost and performance

------------------------------------------------------------------------

## References

1. Groover, M.P. (2020). *Fundamentals of Modern Manufacturing* (7th ed.). Wiley.
2. Kalpakjian, S., & Schmid, S.R. (2020). *Manufacturing Engineering and Technology* (8th ed.). Pearson.
3. DeGarmo, E.P., Black, J.T., & Kohser, R.A. (2019). *DeGarmo's Materials and Processes in Manufacturing* (13th ed.). Wiley.
4. Afzal, M. "Types of Manufacturing Processes." *Engineering Articles*.

<!--chapter:end:01-Types-of-Manufacturing.Rmd-->

# Process and Design

------------------------------------------------------------------------

```{r setup-ch2, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

1. Describe the stages of process plant project development from concept to operation
2. Differentiate between fixed, programmable, and flexible automation systems
3. Interpret Process Flow Diagrams (PFDs) and Piping & Instrumentation Diagrams (P&IDs)
4. Explain the purpose and content of Front-End Engineering Design (FEED)
5. Apply Design for Manufacturing (DFM) and Design for Assembly (DFA) principles
6. Understand the role of HAZOP studies in process safety
7. Identify key engineering deliverables for each project phase

------------------------------------------------------------------------

## Introduction to Process Engineering

**Process engineering** is a specialized branch of engineering that focuses on the design, optimization, and implementation of manufacturing processes and production systems. Process engineers work at the intersection of design and production, ensuring that products can be manufactured efficiently, safely, and economically.

<details>
<summary>What is the role of a process engineer?</summary>

Process engineers are responsible for:

- **Designing production processes** - Selecting equipment, defining sequences, optimizing flow
- **Improving existing processes** - Reducing waste, increasing throughput, improving quality
- **Scaling up from lab to production** - Taking R&D concepts to full-scale manufacturing
- **Ensuring safety and compliance** - Meeting regulatory and environmental requirements
- **Supporting production** - Troubleshooting issues, training operators
- **Cost optimization** - Reducing manufacturing costs while maintaining quality

</details>

------------------------------------------------------------------------

## Types of Manufacturing Automation

Automation is essential for achieving high productivity, consistent quality, and competitive manufacturing costs. There are three fundamental types of automation, each suited to different production scenarios.

```{r automation-comparison, echo=FALSE, fig.align="center", fig.cap="Comparison of Automation Types", fig.width=10, fig.height=6}
# Create automation comparison visualization
automation_data <- data.frame(
  Type = c("Fixed", "Programmable", "Flexible"),
  Initial_Cost = c(5, 3, 4),
  Flexibility = c(1, 3, 5),
  Volume_Capability = c(5, 3, 3),
  Changeover_Time = c(1, 2, 5),  # 5 = fast changeover
  Unit_Cost = c(5, 3, 3)  # 5 = lowest unit cost
)

automation_long <- automation_data %>%
  pivot_longer(cols = -Type, names_to = "Metric", values_to = "Score") %>%
  mutate(
    Metric = gsub("_", " ", Metric),
    Type = factor(Type, levels = c("Fixed", "Programmable", "Flexible"))
  )

ggplot(automation_long, aes(x = Metric, y = Score, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("#E74C3C", "#F39C12", "#27AE60")) +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "Med-Low", "Medium", "Med-High", "High")) +
  labs(title = "Automation Type Comparison",
       subtitle = "Each type optimizes for different production requirements",
       x = "", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 20, hjust = 1),
    legend.position = "bottom"
  )
```

### Fixed Automation

**Fixed automation** (also called "hard automation") uses specialized equipment designed for a specific product. The sequence of operations is determined by the equipment configuration and cannot be easily changed.

**Characteristics:**
- Very high production rates (thousands per hour)
- Low per-unit cost at high volumes
- High initial capital investment
- Inflexible - dedicated to one product

**Examples:**
- Automotive transfer lines for engine blocks
- Beverage bottling lines
- Chemical processing plants
- Paper manufacturing

```{r fixed-automation-economics, echo=TRUE}
# Fixed Automation Economic Analysis
# When does fixed automation make sense?

# Example: Automotive transfer line for cylinder heads
fixed_automation_cost <- 5000000  # Initial equipment cost
annual_production <- 500000       # Parts per year
fixed_cost_per_part <- 2.50       # Operating cost per part
equipment_life_years <- 10

# Calculate total cost per part including amortization
annual_equipment_cost <- fixed_automation_cost / equipment_life_years
total_annual_cost <- annual_equipment_cost + (fixed_cost_per_part * annual_production)
cost_per_part <- total_annual_cost / annual_production

cat("Fixed Automation Analysis:\n")
cat("==========================\n")
cat(sprintf("Equipment cost: $%s\n", format(fixed_automation_cost, big.mark=",")))
cat(sprintf("Annual production: %s parts\n", format(annual_production, big.mark=",")))
cat(sprintf("Operating cost per part: $%.2f\n", fixed_cost_per_part))
cat(sprintf("Amortized equipment cost per part: $%.2f\n", annual_equipment_cost/annual_production))
cat(sprintf("Total cost per part: $%.2f\n", cost_per_part))
```

### Programmable Automation

**Programmable automation** allows the production equipment to be reprogrammed for different products. It's suited for batch production where products change periodically.

**Characteristics:**
- Medium production rates
- Significant changeover time between products
- Lower initial cost than fixed automation
- Suitable for batch sizes of 100-10,000

**Examples:**
- CNC machining centers
- Industrial robots
- PLC-controlled assembly machines
- Batch chemical reactors

<details>
<summary>Discussion: When should you choose programmable over fixed automation?</summary>

**Choose programmable automation when:**

1. **Product variety** - You make multiple products on the same equipment
2. **Volume uncertainty** - Demand may shift between products
3. **Product evolution** - Frequent design changes expected
4. **Lower volumes** - Not enough volume to justify dedicated equipment
5. **Capital constraints** - Can't afford multiple dedicated lines

**Example scenario:**
A machine shop that makes 20 different part numbers for aerospace customers would use CNC machines (programmable) rather than dedicated transfer lines (fixed) because:
- Volumes per part number are low (100-1,000/year)
- New part designs are introduced regularly
- Flexibility to respond to customer changes is critical

</details>

### Flexible Automation

**Flexible automation** can produce a variety of parts with minimal changeover time. It combines the flexibility of programmable automation with the productivity approaching fixed automation.

**Characteristics:**
- Medium-high production rates
- Very fast changeover (minutes, not hours)
- High initial investment
- Suitable for medium variety, medium volume

**Examples:**
- Flexible Manufacturing Systems (FMS)
- Robotic assembly cells
- Automated guided vehicle (AGV) systems
- Modern automotive final assembly lines

```{r automation-selection, echo=FALSE}
automation_guide <- tibble(
  `Production Characteristic` = c("Annual Volume", "Product Variety", "Changeover Frequency",
                                  "Initial Investment", "Operating Cost", "Best Industries"),
  `Fixed Automation` = c("> 1,000,000 units", "Single product", "Rarely (years)",
                        "Very High ($5M+)", "Lowest per unit", "Automotive, Beverage, Chemical"),
  `Programmable Automation` = c("1,000 - 100,000 units", "Several products in batches", "Weekly to monthly",
                                "Medium ($500K-$2M)", "Medium per unit", "Job shops, Aerospace, Medical"),
  `Flexible Automation` = c("10,000 - 500,000 units", "Many products, mixed", "Hours to minutes",
                           "High ($2M-$10M)", "Low-medium per unit", "Electronics, Automotive suppliers")
)

automation_guide %>%
  kable(format = "html", caption = "Automation Type Selection Guide") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "bordered"),
    full_width = TRUE
  ) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1") %>%
  column_spec(2, background = "#FADBD8") %>%
  column_spec(3, background = "#FCF3CF") %>%
  column_spec(4, background = "#D5F5E3")
```

<details>
<summary>List industries where you can find various automated process systems</summary>

**By automation type:**

**Fixed Automation:**
- Oil refineries
- Chemical plants
- Food processing (high-volume)
- Beverage bottling
- Automotive powertrain
- Steel mills
- Paper/pulp mills

**Programmable Automation:**
- Aerospace manufacturing
- Medical device production
- Pharmaceutical (batch)
- Job shops
- Tool & die making
- Defense contractors

**Flexible Automation:**
- Electronics assembly
- Automotive final assembly
- Warehouse/distribution
- Semiconductor fabrication
- Consumer appliances
- Furniture manufacturing

</details>

### Automation Advantages and Disadvantages

```{r automation-pros-cons, echo=FALSE}
pros_cons <- tibble(
  Category = c(rep("Advantages", 7), rep("Disadvantages", 5)),
  Point = c(
    "Lowered Operating Costs - Reduced labor per unit",
    "Improved Worker Safety - Removes humans from hazardous operations",
    "Reduced Factory Lead Times - Faster, more predictable production",
    "Increased Production Output - 24/7 operation possible",
    "Smaller Environmental Footprint - Optimized resource usage",
    "Increased Productivity and Efficiency - Consistent cycle times",
    "Increased System Versatility - Modern systems adapt to changes",
    "Higher Start-up Cost - Significant capital investment required",
    "Higher Cost of Maintenance - Specialized technicians needed",
    "Obsolescence/Depreciation - Technology changes rapidly",
    "Workforce Displacement - Fewer direct labor jobs",
    "Not Economical for Small Scale - Minimum volumes required"
  )
)

pros_cons %>%
  kable(format = "html", caption = "Advantages and Disadvantages of Manufacturing Automation") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  row_spec(1:7, background = "#D5F5E3") %>%
  row_spec(8:12, background = "#FADBD8")
```

------------------------------------------------------------------------

## Project Development Phases

Manufacturing projects follow a structured development process from initial concept to full operation. Understanding these phases is essential for process engineers.

```{r project-phases, echo=FALSE, fig.align="center", fig.cap="Project Development Phases and Gate Reviews", fig.width=12, fig.height=6}
# Create project phase visualization
phases <- data.frame(
  Phase = c("Concept", "FEED", "Detailed\nDesign", "Procurement\n& Fabrication",
            "Construction", "Commissioning", "Start-up", "Operation"),
  x = 1:8,
  Duration = c(1, 2, 3, 4, 5, 2, 1, 10),
  Cost_Percent = c(1, 3, 10, 40, 30, 8, 5, 3),
  color = c("#3498DB", "#9B59B6", "#E74C3C", "#F39C12", "#1ABC9C", "#34495E", "#27AE60", "#2C3E50")
)

gates <- data.frame(
  Gate = c("G1", "G2", "G3", "G4", "G5"),
  x = c(1.5, 2.5, 4.5, 6.5, 7.5),
  label = c("Concept\nApproval", "FEED\nApproval", "Construction\nApproval",
            "Ready for\nCommissioning", "Ready for\nOperation")
)

ggplot() +
  # Phase bars
  geom_tile(data = phases, aes(x = x, y = 1, fill = color),
            width = 0.9, height = 0.5, color = "white", size = 1) +
  geom_text(data = phases, aes(x = x, y = 1, label = Phase),
            color = "white", fontface = "bold", size = 3) +
  # Gate markers
  geom_point(data = gates, aes(x = x, y = 1), shape = 18, size = 6, color = "#C0392B") +
  geom_text(data = gates, aes(x = x, y = 0.6, label = Gate),
            fontface = "bold", size = 4, color = "#C0392B") +
  geom_text(data = gates, aes(x = x, y = 0.3, label = label),
            size = 2.5, color = "#7F8C8D") +
  # Cost accumulation curve concept
  annotate("text", x = 4.5, y = 1.6,
           label = "Stage-Gate Process: Each gate requires approval before proceeding",
           fontface = "italic", size = 4) +
  scale_fill_identity() +
  labs(title = "Project Development Phases with Stage-Gate Reviews") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14)
  ) +
  ylim(-0.1, 2)
```

### Phase 1: Concept Development

The initial phase defines the project scope, evaluates feasibility, and develops preliminary cost estimates.

**Key Deliverables:**
- Project charter and business case
- Preliminary process flow diagrams
- Order-of-magnitude cost estimate (±30-50%)
- Initial schedule
- Risk assessment

### Phase 2: Front-End Engineering Design (FEED)

FEED (also called FEL - Front-End Loading) develops the project definition to a level sufficient for final investment decision.

```{r feed-process, echo=FALSE, results='asis'}
  embed_youtube("gSkoGFLDxF0", "FEED Process Overview")
```

**FEED Deliverables include:**

- Project organization chart
- Defined project scope
- Process Flow Diagrams (PFDs)
- Piping & Instrumentation Diagrams (P&IDs)
- Equipment datasheets and specifications
- Major equipment list
- 2D and 3D preliminary models
- Equipment layout and installation plan
- HAZOP and safety studies
- Automation strategy
- Budget estimate (±10-15%)
- Project timeline
- Fixed-bid quote capability

<details>
<summary>What are the steps of Process System Design and Engineering?</summary>

1. **Process Development**
   - Develop PFDs & P&IDs
   - Process simulation
   - Heat and mass balance

2. **Equipment Engineering**
   - 2D & 3D models
   - Equipment layout and installation plan
   - Skid design
   - Mechanical & structural design

3. **Systems Engineering**
   - Piping design
   - Electrical design
   - Instrumentation design
   - Control system architecture

4. **Installation Planning**
   - Lifts & installation planning
   - Construction sequencing
   - Tie-in planning

</details>

### Phase 3: Detailed Engineering

Detailed engineering produces all documents needed for procurement and construction.

```{r engineering-disciplines, echo=FALSE}
disciplines <- tibble(
  Discipline = c("Process", "Mechanical", "Piping", "Electrical", "I&C", "Civil/Structural"),
  `Key Deliverables` = c(
    "P&IDs, datasheets, process packages, operating procedures",
    "Vessel drawings, heat exchanger specs, rotating equipment specs",
    "Isometrics, pipe specs, stress analysis, 3D models",
    "Single-line diagrams, load lists, cable schedules, lighting",
    "Logic diagrams, instrument index, control narratives, HMI specs",
    "Foundation drawings, structural steel, buildings, roads"
  ),
  `Systems Provided` = c(
    "Process units, utility systems",
    "Pressure vessels, tanks, exchangers, pumps",
    "Process piping, utility piping",
    "Power distribution, motor control, lighting",
    "DCS/PLC, safety systems, instruments",
    "Foundations, structures, buildings"
  )
)

disciplines %>%
  kable(format = "html", caption = "Engineering Disciplines and Deliverables") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D4E6F1", width = "10em")
```

<details>
<summary>Automation and Controls Engineering needs to include which tasks?</summary>

**Control System Design:**
- Automation architecture design
- Control panel fabrication drawings
- PLC/DCS programming
- HMI/SCADA design
- Safety system design (SIS)

**Documentation:**
- Control narratives
- Logic diagrams (cause & effect)
- Instrument datasheets
- Loop diagrams
- Cable schedules

**Integration:**
- Controls integration services
- Network architecture
- Cybersecurity
- Historian configuration
- MES integration

</details>

### Phase 4-7: Construction, Commissioning, and Start-up

```{r project-activities, echo=FALSE}
activities <- tibble(
  Phase = c("Procurement & Fabrication", "Construction", "Commissioning", "Start-up"),
  `Key Activities` = c(
    "Purchase equipment, fabricate skids, manufacture custom items",
    "Civil work, install equipment, piping, electrical, instrumentation",
    "System checkout, loop testing, safety system validation",
    "Initial operation, performance testing, operator training"
  ),
  `Process Engineer Role` = c(
    "Review vendor documents, approve equipment",
    "Supervise installation, resolve field issues",
    "Verify system operation, support testing",
    "Optimize process, troubleshoot issues, train operators"
  ),
  `Typical Duration` = c("3-12 months", "6-24 months", "1-3 months", "1-3 months")
)

activities %>%
  kable(format = "html", caption = "Later Project Phases") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

<details>
<summary>What needs to be planned for Testing & Commissioning?</summary>

**Pre-Commissioning:**
- Mechanical completion checks
- Piping pressure tests
- Electrical continuity tests
- Instrument calibration

**Commissioning:**
- Loop checking
- Control system function tests
- Safety system (SIS) validation
- Utility systems start-up
- Dry run testing

**Performance Testing:**
- Factory Acceptance Tests (FAT)
- Site Acceptance Tests (SAT)
- Performance guarantee tests
- Reliability testing

</details>

------------------------------------------------------------------------

## Process Documentation

### Process Flow Diagrams (PFDs)

PFDs show the overall process flow, major equipment, and key operating conditions. They are the "big picture" view of the process.

```{r pfd-elements, echo=FALSE}
pfd_elements <- tibble(
  `Element` = c("Major Equipment", "Process Streams", "Operating Conditions",
                "Control Loops", "Utility Streams", "Stream Data"),
  `What's Shown` = c(
    "Reactors, vessels, heat exchangers, pumps, compressors",
    "Main process flow lines with arrows",
    "Temperature, pressure, flow rates at key points",
    "Major control loops only",
    "Steam, cooling water, nitrogen (simplified)",
    "Stream numbers with heat/mass balance table"
  ),
  `What's NOT Shown` = c(
    "Pipe sizes, valve types, instrument details",
    "Minor bypasses, drain lines, vent lines",
    "All intermediate conditions",
    "Local instruments, minor controls",
    "Detailed utility connections",
    "All intermediate streams"
  )
)

pfd_elements %>%
  kable(format = "html", caption = "Process Flow Diagram (PFD) Content") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D5F5E3")
```

### Piping & Instrumentation Diagrams (P&IDs)

P&IDs are the detailed "roadmap" of the process, showing all equipment, piping, valves, and instrumentation.

```{r read-pandid, echo=FALSE, results='asis'}
  embed_youtube("j4EOTerfyTY", "How to Read P&IDs")
```


```{r pid-symbols, echo=FALSE, fig.align="center", fig.cap="Common P&ID Symbols (Simplified)", fig.width=12, fig.height=8}
# Create a simplified P&ID symbol reference
symbols <- data.frame(
  Category = c(rep("Valves", 4), rep("Instruments", 4), rep("Equipment", 4)),
  Name = c("Gate Valve", "Globe Valve", "Ball Valve", "Check Valve",
           "Flow Transmitter", "Pressure Indicator", "Level Controller", "Temperature Element",
           "Pump", "Heat Exchanger", "Vessel/Tank", "Compressor"),
  Symbol_Code = c("--|X|--", "--|>|--", "--|(O)|--", "--|>--",
                  "FT", "PI", "LC", "TE",
                  "P-101", "E-101", "V-101", "C-101"),
  x = rep(c(1, 2, 3, 4), 3),
  y = c(rep(3, 4), rep(2, 4), rep(1, 4))
)

ggplot(symbols, aes(x = x, y = y)) +
  geom_tile(aes(fill = Category), width = 0.9, height = 0.6, color = "black", alpha = 0.3) +
  geom_text(aes(label = Name), y = symbols$y + 0.15, fontface = "bold", size = 3) +
  geom_text(aes(label = Symbol_Code), y = symbols$y - 0.1, size = 3.5,
            family = "mono", color = "#2C3E50") +
  scale_fill_manual(values = c("#3498DB", "#E74C3C", "#27AE60")) +
  labs(title = "Common P&ID Symbol Categories",
       subtitle = "Standard symbols per ISA-5.1") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```

```{r instrument-tags, echo=FALSE}
instrument_tags <- tibble(
  `First Letter` = c("F", "L", "P", "T", "A", "S"),
  `Measured Variable` = c("Flow", "Level", "Pressure", "Temperature", "Analysis", "Speed"),
  `Modifier Letters` = c("T = Transmitter", "C = Controller", "I = Indicator",
                        "E = Element/Sensor", "V = Valve", "A = Alarm"),
  `Example Tag` = c("FT-101 (Flow Transmitter)", "LC-201 (Level Controller)",
                   "PI-301 (Pressure Indicator)", "TE-401 (Temperature Element)",
                   "AT-501 (Analyzer Transmitter)", "SI-601 (Speed Indicator)")
)

instrument_tags %>%
  kable(format = "html", caption = "ISA Instrument Tag Structure") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#E8DAEF", width = "8em")
```

<details>
<summary>Quick Quiz: Decode these instrument tags</summary>

**Decode the following P&ID tags:**

1. **FIC-101** = ?
2. **TT-205** = ?
3. **PSV-301** = ?
4. **LCV-402** = ?

**Answers:**

1. **FIC-101** = Flow Indicating Controller (loop 101)
2. **TT-205** = Temperature Transmitter (loop 205)
3. **PSV-301** = Pressure Safety Valve (loop 301)
4. **LCV-402** = Level Control Valve (loop 402)

</details>

------------------------------------------------------------------------

## Design for Manufacturing (DFM) and Assembly (DFA)

**DFM** and **DFA** are methodologies that consider manufacturing and assembly constraints during product design, reducing cost and improving quality.

### DFM Principles

```{r dfm-principles, echo=FALSE, fig.align="center", fig.cap="DFM Guidelines", fig.width=10, fig.height=6}
dfm_data <- data.frame(
  Principle = c("Minimize Parts", "Use Standard Parts", "Design for Ease of Fabrication",
                "Mistake-Proof Design", "Minimize Assembly Directions",
                "Maximize Compliance", "Minimize Handling"),
  Impact = c(5, 4, 4, 5, 3, 3, 4),
  Cost_Reduction = c(5, 4, 3, 4, 3, 2, 3)
)

dfm_long <- dfm_data %>%
  pivot_longer(cols = c(Impact, Cost_Reduction), names_to = "Metric", values_to = "Score") %>%
  mutate(Metric = gsub("_", " ", Metric))

ggplot(dfm_long, aes(x = reorder(Principle, Score), y = Score, fill = Metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("#3498DB", "#27AE60")) +
  scale_y_continuous(breaks = 1:5) +
  labs(title = "DFM Principles: Impact and Cost Reduction Potential",
       x = "", y = "Rating (1-5)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 30, hjust = 1),
    legend.position = "bottom"
  ) +
  coord_flip()
```

```{r dfm-guidelines, echo=FALSE}
dfm_guide <- tibble(
  `DFM Guideline` = c(
    "Minimize total number of parts",
    "Use standard components",
    "Design for ease of fabrication",
    "Design for ease of assembly",
    "Minimize assembly directions",
    "Maximize compliance in assembly",
    "Design for ease of service"
  ),
  `Why It Matters` = c(
    "Fewer parts = fewer chances for failure, less inventory, lower cost",
    "Standard parts are cheaper, faster to procure, easier to replace",
    "Complex features increase manufacturing cost and defect rates",
    "Reduces assembly time and errors",
    "Multiple directions require repositioning, increasing time",
    "Tight tolerances increase cost; allow self-alignment where possible",
    "Products will need maintenance; design for technician access"
  ),
  `Example` = c(
    "Combine bracket and housing into single molded part",
    "Use M6 bolts instead of custom fasteners",
    "Avoid undercuts, deep pockets, thin walls",
    "Use snap-fits instead of screws where appropriate",
    "All parts insert from top-down in assembly",
    "Use tapered holes for self-centering pins",
    "Locate service points on accessible panels"
  )
)

dfm_guide %>%
  kable(format = "html", caption = "Design for Manufacturing Guidelines") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D4E6F1", width = "15em")
```

### DFA Analysis

DFA systematically evaluates assembly operations to identify improvement opportunities.

```{r dfa-example, echo=TRUE}
# DFA Analysis Example: Simple Assembly
# Calculate assembly efficiency using Boothroyd-Dewhurst method

# Assembly data (simplified)
parts <- data.frame(
  Part = c("Base", "PCB", "Cover", "Screw 1", "Screw 2", "Screw 3", "Screw 4", "Label"),
  Handling_Time = c(2.5, 3.0, 2.5, 3.5, 3.5, 3.5, 3.5, 4.0),  # seconds
  Insertion_Time = c(3.0, 4.0, 3.5, 6.0, 6.0, 6.0, 6.0, 2.0),  # seconds
  Theoretically_Necessary = c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
)

# Calculations
total_parts <- nrow(parts)
total_time <- sum(parts$Handling_Time + parts$Insertion_Time)
min_parts <- sum(parts$Theoretically_Necessary)
ideal_time <- min_parts * 3  # 3 seconds is theoretical minimum per part

efficiency <- (ideal_time / total_time) * 100

cat("DFA Analysis Results:\n")
cat("=====================\n")
cat(sprintf("Total parts: %d\n", total_parts))
cat(sprintf("Theoretically minimum parts: %d\n", min_parts))
cat(sprintf("Total assembly time: %.1f seconds\n", total_time))
cat(sprintf("Ideal assembly time: %.1f seconds\n", ideal_time))
cat(sprintf("Design Efficiency: %.1f%%\n", efficiency))
cat("\nOpportunity: Combine 4 screws into snap-fit design\n")
```

<details>
<summary>Case Study: Redesigning for DFM/DFA</summary>

**Original Design:**
- 15 parts
- 4 different screw types
- Assembly time: 180 seconds
- Multiple assembly directions
- Special tools required

**Redesigned using DFM/DFA:**
- 8 parts (47% reduction)
- 1 standard screw type
- Assembly time: 75 seconds (58% reduction)
- Single assembly direction (top-down)
- No special tools

**Cost Impact:**
- Part cost reduced 35%
- Assembly labor reduced 58%
- Quality defects reduced 60%
- Total product cost reduced 40%

</details>

------------------------------------------------------------------------

## HAZOP Studies

**HAZOP** (Hazard and Operability Study) is a systematic method to identify hazards and operability problems in process plants.

```{r hazop-study, echo=FALSE, results='asis'}
  embed_youtube("6AqtX8oCpKI&t", "HAZOP Study Overview")
```


```{r hazop-study-overview, echo=FALSE, results='asis'}
  embed_youtube("ukn0RRt0ReA&list=PLeTiXOrLeXhI5IZKv3GeOUMOYpz5mG36S", "HAZOP Study Overview")
```

### HAZOP Methodology

```{r hazop-keywords, echo=FALSE}
hazop_keywords <- tibble(
  `Guide Word` = c("NO/NOT", "MORE", "LESS", "AS WELL AS", "PART OF", "REVERSE", "OTHER THAN"),
  `Meaning` = c(
    "Complete negation of design intent",
    "Quantitative increase",
    "Quantitative decrease",
    "Qualitative modification/addition",
    "Qualitative decrease",
    "Logical opposite of intent",
    "Complete substitution"
  ),
  `Example with FLOW` = c(
    "No flow - pump failure, blocked line",
    "More flow - control valve fails open",
    "Less flow - partial blockage, pump wear",
    "Flow + contamination - upstream leak",
    "Only part of intended flow path active",
    "Reverse flow - check valve failure",
    "Wrong material flowing"
  )
)

hazop_keywords %>%
  kable(format = "html", caption = "HAZOP Guide Words and Examples") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#C0392B", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#FADBD8", width = "10em")
```

### HAZOP Example

```{r hazop-example, echo=FALSE}
hazop_example <- tibble(
  `Node` = rep("Feed Pump P-101 to Reactor R-101", 4),
  `Parameter` = c("Flow", "Flow", "Pressure", "Temperature"),
  `Guide Word` = c("No", "More", "More", "Less"),
  `Deviation` = c("No Flow", "More Flow", "High Pressure", "Low Temperature"),
  `Cause` = c(
    "Pump failure, blocked suction",
    "Control valve fails open",
    "Downstream blockage",
    "Cooling water leak into feed"
  ),
  `Consequence` = c(
    "Reactor starved, runaway possible",
    "Reactor overflow, environmental release",
    "Pipe rupture, personnel injury",
    "Reaction incomplete, off-spec product"
  ),
  `Safeguard` = c(
    "Low flow alarm, interlock",
    "High level alarm, overflow protection",
    "Relief valve, high pressure trip",
    "Low temp alarm, feed analysis"
  ),
  `Action` = c(
    "Verify interlock function",
    "Add independent high-high level trip",
    "Verify relief valve sizing",
    "Add temperature interlock"
  )
)

hazop_example %>%
  kable(format = "html", caption = "HAZOP Worksheet Example") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#C0392B", color = "white") %>%
  column_spec(1, width = "10em")
```

<details>
<summary>Discussion: Why is HAZOP done during FEED, not later?</summary>

HAZOP should be completed during FEED because:

1. **Cost of changes** - Changes during FEED cost 1x; during detailed design cost 10x; during construction cost 100x
2. **Design influence** - P&IDs are still being developed and can be modified
3. **Equipment selection** - Safety requirements may affect equipment sizing
4. **Budget accuracy** - Safety systems must be included in project budget
5. **Regulatory approval** - Many jurisdictions require HAZOP before construction permits

**Best practice:** Conduct preliminary HAZOP early in FEED, then detailed HAZOP when P&IDs are 60-80% complete.

</details>

------------------------------------------------------------------------

## Cost Estimation

Accurate cost estimation is critical for project approval and budget management.

```{r cost-estimate-classes, echo=FALSE}
cost_classes <- tibble(
  `AACE Class` = c("Class 5", "Class 4", "Class 3", "Class 2", "Class 1"),
  `Project Phase` = c("Concept Screening", "Concept Study", "FEED/Budget",
                     "Detailed Design", "Construction"),
  `Engineering Complete` = c("0-2%", "1-15%", "10-40%", "30-75%", "65-100%"),
  `Accuracy Range` = c("-50% to +100%", "-30% to +50%", "-20% to +30%",
                      "-15% to +20%", "-10% to +15%"),
  `Purpose` = c("Screening alternatives", "Feasibility", "Authorization",
               "Control", "Bid/Tender")
)

cost_classes %>%
  kable(format = "html", caption = "Cost Estimate Classification (AACE International)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

```{r cost-breakdown, echo=FALSE, fig.align="center", fig.cap="Typical Process Plant Cost Breakdown", fig.width=9, fig.height=6}
cost_data <- data.frame(
  Category = c("Equipment", "Piping", "Electrical", "Instrumentation",
               "Civil/Structural", "Buildings", "Engineering", "Construction Mgmt",
               "Contingency"),
  Percentage = c(25, 15, 10, 12, 8, 5, 10, 8, 7)
)

ggplot(cost_data, aes(x = reorder(Category, Percentage), y = Percentage, fill = Category)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = paste0(Percentage, "%")), hjust = -0.2, fontface = "bold") +
  scale_fill_brewer(palette = "Set3") +
  labs(title = "Typical Process Plant Cost Distribution",
       x = "", y = "Percentage of Total Installed Cost") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "none"
  ) +
  coord_flip() +
  ylim(0, 30)
```

------------------------------------------------------------------------

## Case Study: Automotive Paint Line Project

```{r case-study-timeline, echo=FALSE, fig.align="center", fig.cap="Automotive Paint Line Project Timeline", fig.width=12, fig.height=5}
# Simplified project timeline
timeline <- data.frame(
  Phase = c("Concept", "FEED", "Detailed Design", "Procurement",
            "Construction", "Commissioning", "Start-up"),
  Start = c(0, 2, 6, 10, 14, 26, 28),
  Duration = c(2, 4, 4, 12, 12, 2, 2),
  y = 1:7
)

ggplot(timeline) +
  geom_segment(aes(x = Start, xend = Start + Duration, y = y, yend = y),
               size = 10, color = "#3498DB", lineend = "round") +
  geom_text(aes(x = Start + Duration/2, y = y, label = Phase),
            color = "white", fontface = "bold", size = 3) +
  geom_text(aes(x = Start + Duration/2, y = y - 0.4,
                label = paste0("M", Start, "-M", Start + Duration)),
            size = 2.5, color = "#7F8C8D") +
  scale_x_continuous(breaks = seq(0, 30, 6), labels = paste0("Month ", seq(0, 30, 6))) +
  labs(title = "Automotive Paint Line Project: 30-Month Timeline",
       x = "", y = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank()
  )
```

<details>
<summary>Case Study Details: Paint Line Engineering Challenges</summary>

**Project Overview:**
- New automotive paint line for SUV body shop
- Capacity: 60 jobs per hour (JPH)
- Process: E-coat, primer, basecoat, clearcoat

**Key Engineering Challenges:**

**1. Environmental Control**
- Temperature: ±1°C throughout paint booth
- Humidity: 65% ±5% RH
- Air cleanliness: Class 10,000

**2. Automation Requirements**
- 48 paint robots (8 per zone)
- Conveyor system with 2m pitch
- Zone tracking and recipe management

**3. Safety Systems**
- Explosion-proof electrical classification
- Fire suppression throughout
- VOC monitoring and control

**4. Quality Systems**
- Inline thickness measurement
- Automated visual inspection
- Recipe management and traceability

**Project Outcome:**
- On-time completion
- Under budget by 3%
- Quality metrics exceeded targets
- 99.2% first-pass yield achieved

</details>

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: Automation Selection</summary>

**A medical device company needs to produce 5,000 units per year of a surgical instrument. The design is mature and not expected to change. Volumes could grow to 50,000 units if successful. Which automation type should they initially choose?**

**Answer:** **Programmable automation** (CNC machining, robotic cells)

**Reasoning:**
- Current volume (5,000/year) doesn't justify fixed automation
- Flexibility allows for minor design refinements
- Can scale up by adding shifts or machines
- Lower initial investment preserves capital
- If volume grows to 50,000, can justify dedicated equipment later

</details>

<details>
<summary>Question 2: P&ID Interpretation</summary>

**Decode the following instrument tags and explain their function:**

a) FIC-201
b) PSV-305
c) TT-401
d) LCV-150

**Answers:**

a) **FIC-201** - Flow Indicating Controller (loop 201)
   - Measures flow, displays value, and controls a valve

b) **PSV-305** - Pressure Safety Valve (loop 305)
   - Relieves pressure if it exceeds setpoint (safety device)

c) **TT-401** - Temperature Transmitter (loop 401)
   - Converts temperature measurement to 4-20mA signal

d) **LCV-150** - Level Control Valve (loop 150)
   - Valve that is manipulated by a level controller

</details>

<details>
<summary>Question 3: Project Phases</summary>

**Why is FEED often considered the most critical project phase?**

**Answer:** FEED is critical because:

1. **Defines scope** - All subsequent work based on FEED deliverables
2. **Locks in 80% of cost** - Design decisions determine equipment and construction costs
3. **Lowest cost to change** - Changes cost 10-100x more in later phases
4. **Authorization basis** - Management approves project based on FEED estimate
5. **Risk identification** - HAZOP and risk studies identify safety requirements
6. **Contractor selection** - FEED package used for competitive bidding

**Poor FEED = project overruns, scope changes, and budget problems.**

</details>

<details>
<summary>Question 4: DFM Application</summary>

**A product currently uses 12 screws of 3 different sizes for assembly. Apply DFM principles to improve this design.**

**Answer:** Apply these DFM principles:

1. **Minimize parts**: Can some screws be eliminated by using integral snap-fits?

2. **Standardize**: Use one screw size instead of three
   - Reduces inventory complexity
   - Single tool for assembly
   - Lower procurement cost

3. **Design for ease**: Consider alternatives:
   - Snap-fit connections (no tools)
   - Twist-lock features
   - Press-fit pins

**Possible redesign:**
- Reduce from 12 screws to 4 screws (for serviceability)
- All same size (M3 × 8)
- Add 4 snap-fits for initial positioning
- Result: 67% fewer fasteners, single tool, faster assembly

</details>

<details>
<summary>Question 5: HAZOP Analysis</summary>

**For a reactor feed pump, apply the HAZOP guide word "REVERSE" to the parameter "FLOW". What could cause this? What are the consequences? What safeguards would you recommend?**

**Answer:**

**Deviation:** Reverse flow through feed pump

**Causes:**
- Pump stops while discharge valve open
- Check valve fails (stuck open or missing)
- Parallel pump creates backflow
- Reactor pressure exceeds pump shutoff head

**Consequences:**
- Reactor contents backflow into feed tank
- Contamination of feed material
- Possible chemical reaction in feed system
- Pump damage (running backward)

**Safeguards:**
- Check valve on pump discharge
- Automatic pump discharge block valve (closes on pump stop)
- Low flow alarm and trip
- Reactor pressure monitoring
- Backflow-preventing orifice

</details>

------------------------------------------------------------------------

## Summary

```{r summary-ch2, echo=FALSE}
summary_ch2 <- tibble(
  Topic = c("Automation Types", "Project Phases", "PFDs vs P&IDs", "DFM/DFA", "HAZOP", "Cost Estimation"),
  `Key Takeaway` = c(
    "Fixed for high volume single product; Programmable for batch; Flexible for variety with quick changeover",
    "Concept → FEED → Detailed Design → Construction → Commissioning → Start-up",
    "PFD = big picture (equipment, flows); P&ID = detailed (all instruments, valves, piping)",
    "Design for easy manufacturing and assembly reduces cost 20-40%",
    "Systematic hazard identification using guide words; do it during FEED",
    "Estimate accuracy improves with engineering completion; AACE Class 1-5"
  )
)

summary_ch2 %>%
  kable(format = "html", caption = "Chapter 2 Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Key Takeaways

1. **Automation selection** depends on production volume, variety, and changeover requirements
2. **FEED phase** defines 80% of project cost with only 10-15% of engineering effort
3. **P&IDs** are the critical document connecting design to construction
4. **DFM/DFA** should be applied early in design to maximize impact
5. **HAZOP** identifies hazards systematically and must be done before construction
6. **Cost estimates** improve in accuracy as engineering progresses

------------------------------------------------------------------------

## References

1. Towler, G., & Sinnott, R. (2021). *Chemical Engineering Design* (7th ed.). Elsevier.
2. AACE International. (2020). *Cost Estimate Classification System*.
3. ISA-5.1. (2022). *Instrumentation Symbols and Identification*.
4. Boothroyd, G., Dewhurst, P., & Knight, W.A. (2011). *Product Design for Manufacture and Assembly* (3rd ed.). CRC Press.
5. CCPS. (2008). *Guidelines for Hazard Evaluation Procedures* (3rd ed.). Wiley.

<!--chapter:end:02-Process-and-Design.Rmd-->

# Integrated Manufacturing Systems

------------------------------------------------------------------------

```{r setup-ch3, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

1. Compare different types of production facility layouts and material handling methods
2. Calculate Manufacturing Cycle Time (MCT) and Manufacturing Cycle Efficiency (MCE)
3. Analyze production line performance including the impact of station failures
4. Apply line balancing techniques to optimize workstation assignments
5. Explain the concepts of takt time, cycle time, and their relationship
6. Describe Flexible Manufacturing Systems (FMS) and their applications
7. Understand modern concepts including digital twins and Industry 4.0

------------------------------------------------------------------------

## Material Handling Methods & Systems

There are four common types of production facility layouts, each with distinct features and material handling requirements:

```{r layout-comparison-table, echo=FALSE}
layout_data <- tibble(
  `Layout Type` = c("Fixed-Position", "Process (Job Shop)", "Cellular", "Product (Flow Line)"),
  `Product Characteristics` = c(
    "Large, heavy, or immobile products",
    "High variety, low volume, custom work",
    "Part families, medium variety/volume",
    "Standardized products, high volume"
  ),
  `Material Handling` = c(
    "Cranes, hoists, fork lifts bring materials to product",
    "Fork lifts, AGVs, carts move WIP between departments",
    "Conveyors within cells, carts between cells",
    "Conveyors, automated transfer systems"
  ),
  `Examples` = c(
    "Ships, aircraft, buildings, large machinery",
    "Machine shops, hospitals, universities",
    "Electronics assembly, engine components",
    "Automotive assembly, bottling, food processing"
  )
)

layout_data %>%
  kable(format = "html", caption = "Material Handling Methods by Plant Layout") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = TRUE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE, width = "10em", background = "#D4E6F1") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white")
```

<details>
<summary>Discussion: How do you choose between layout types?</summary>

**Selection criteria:**

| Factor | Favors Process Layout | Favors Product Layout |
|--------|----------------------|----------------------|
| Volume | Low (< 1,000/year) | High (> 10,000/year) |
| Variety | High (many products) | Low (1-2 products) |
| Routing | Variable by product | Fixed, same for all |
| Equipment | General-purpose | Specialized |
| Worker skills | High, varied | Specific, repetitive |
| WIP inventory | High | Low |
| Lead time | Long | Short |

**When in doubt:** If volume and variety are moderate, consider cellular manufacturing as a compromise.

</details>

------------------------------------------------------------------------

## Fundamentals of Production Lines

A **production line** consists of workstations arranged so that the product moves from one station to the next, with a portion of the total work performed at each location.

```{r production-line-viz, echo=FALSE, fig.align="center", fig.cap="Production Line Concept", fig.width=11, fig.height=4}
# Create production line visualization
stations <- data.frame(
  name = c("Station 1", "Station 2", "Station 3", "Station 4", "Station 5"),
  x = 1:5,
  y = 1,
  time = c(45, 52, 48, 55, 50)
)

ggplot(stations, aes(x = x, y = y)) +
  geom_tile(fill = "#3498DB", width = 0.8, height = 0.5, color = "white", size = 2) +
  geom_text(aes(label = name), color = "white", fontface = "bold", size = 4, y = 1.05) +
  geom_text(aes(label = paste0(time, " sec")), color = "white", size = 3.5, y = 0.95) +
  geom_segment(data = stations[1:4,], aes(x = x + 0.45, xend = x + 0.55, y = y, yend = y),
               arrow = arrow(length = unit(0.3, "cm")), color = "#2C3E50", size = 1.5) +
  annotate("text", x = 0.3, y = 1, label = "Input", fontface = "italic") +
  annotate("text", x = 5.7, y = 1, label = "Output", fontface = "italic") +
  annotate("segment", x = 0.5, xend = 0.55, y = 1, yend = 1,
           arrow = arrow(length = unit(0.2, "cm")), color = "#27AE60") +
  annotate("segment", x = 5.45, xend = 5.5, y = 1, yend = 1,
           arrow = arrow(length = unit(0.2, "cm")), color = "#27AE60") +
  labs(title = "5-Station Production Line",
       subtitle = "Cycle time determined by slowest station (bottleneck): 55 seconds") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 11)
  ) +
  xlim(-0.2, 6.2)
```

### Methods of Work Transport

```{r transport-methods, echo=FALSE}
transport_data <- tibble(
  Method = c("Manual", "Continuous", "Synchronous (Intermittent)", "Asynchronous"),
  `Description` = c(
    "Workers pass parts by hand or using simple carts",
    "Conveyor moves at constant speed; work done while moving",
    "All units move simultaneously in discrete steps",
    "Units move independently when released by worker"
  ),
  `Advantages` = c(
    "Low cost, flexible, easy to implement",
    "Smooth flow, no transfer time between stations",
    "Fixed cycle time, easy to control",
    "Absorbs variation, no blocking/starving"
  ),
  `Disadvantages` = c(
    "Variable pace, potential blocking/starving",
    "Work must be done on moving product",
    "Rigid timing, all stations must finish together",
    "Requires buffers, more complex control"
  ),
  `Applications` = c(
    "Low-volume assembly, repair shops",
    "Beverage bottling, canning lines",
    "Automotive body welding, transfer lines",
    "Electronics assembly, flexible lines"
  )
)

transport_data %>%
  kable(format = "html", caption = "Work Transport Methods in Production Lines") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1", width = "10em")
```

```{r transport-diagrams, echo=FALSE, fig.align="center", fig.cap="Work Transport System Types", fig.width=12, fig.height=6}
# Create three panels showing different transport types
par(mfrow = c(1, 3))

# Data for visualization
transport_viz <- data.frame(
  Type = rep(c("Continuous", "Synchronous", "Asynchronous"), each = 5),
  Station = rep(1:5, 3),
  x = rep(1:5, 3),
  y = c(rep(3, 5), rep(2, 5), rep(1, 5))
)

ggplot(transport_viz, aes(x = x, y = y)) +
  # Continuous
  annotate("rect", xmin = 0.5, xmax = 5.5, ymin = 2.7, ymax = 3.3, fill = "#3498DB", alpha = 0.2) +
  annotate("text", x = 0.3, y = 3, label = "Continuous", angle = 90, fontface = "bold") +
  geom_segment(aes(x = 0.5, xend = 5.5, y = 3, yend = 3), color = "#3498DB", size = 2) +
  annotate("text", x = 3, y = 3.2, label = "v = constant", fontface = "italic", size = 3) +
  # Synchronous
  annotate("rect", xmin = 0.5, xmax = 5.5, ymin = 1.7, ymax = 2.3, fill = "#E74C3C", alpha = 0.2) +
  annotate("text", x = 0.3, y = 2, label = "Synchronous", angle = 90, fontface = "bold") +
  geom_segment(aes(x = 0.7, xend = 1.3, y = 2, yend = 2), color = "#E74C3C", size = 2) +
  geom_segment(aes(x = 1.7, xend = 2.3, y = 2, yend = 2), color = "#E74C3C", size = 2) +
  geom_segment(aes(x = 2.7, xend = 3.3, y = 2, yend = 2), color = "#E74C3C", size = 2) +
  geom_segment(aes(x = 3.7, xend = 4.3, y = 2, yend = 2), color = "#E74C3C", size = 2) +
  geom_segment(aes(x = 4.7, xend = 5.3, y = 2, yend = 2), color = "#E74C3C", size = 2) +
  annotate("text", x = 3, y = 2.2, label = "All move together", fontface = "italic", size = 3) +
  # Asynchronous
  annotate("rect", xmin = 0.5, xmax = 5.5, ymin = 0.7, ymax = 1.3, fill = "#27AE60", alpha = 0.2) +
  annotate("text", x = 0.3, y = 1, label = "Asynchronous", angle = 90, fontface = "bold") +
  geom_segment(aes(x = 0.7, xend = 1.1, y = 1, yend = 1), color = "#27AE60", size = 2) +
  geom_segment(aes(x = 1.9, xend = 2.5, y = 1, yend = 1), color = "#27AE60", size = 2) +
  geom_segment(aes(x = 2.7, xend = 3.1, y = 1, yend = 1), color = "#27AE60", size = 2) +
  geom_segment(aes(x = 4.0, xend = 4.4, y = 1, yend = 1), color = "#27AE60", size = 2) +
  geom_segment(aes(x = 4.8, xend = 5.3, y = 1, yend = 1), color = "#27AE60", size = 2) +
  annotate("text", x = 3, y = 1.2, label = "Independent movement + buffers", fontface = "italic", size = 3) +
  # Station markers
  geom_point(data = data.frame(x = rep(1:5, 3), y = rep(c(3, 2, 1), each = 5)),
             aes(x = x, y = y), shape = 21, fill = "white", size = 4, stroke = 1.5) +
  labs(title = "Comparison of Work Transport Systems") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(-0.3, 6)
```

<details>
<summary>What causes blocking and starving in production lines?</summary>

**Starving:** A station is ready to work but has no parts to process.
- **Causes:** Upstream station is slower, upstream breakdown, material shortage

**Blocking:** A station finishes but cannot release the part.
- **Causes:** Downstream station still working, downstream breakdown, no buffer space

**Solutions:**
1. **Buffers** - Storage between stations absorbs variation
2. **Line balancing** - Equalize work content across stations
3. **Parallel stations** - Add capacity at bottlenecks
4. **Preventive maintenance** - Reduce breakdowns

</details>

### Work Cycle Types

```{r work-cycle-viz, echo=FALSE, fig.align="center", fig.cap="Manual, Semi-Automated, and Fully Automated Machine Cycles", fig.width=12, fig.height=5}
# Create work cycle comparison
cycle_data <- data.frame(
  Type = c("Manual", "Semi-Auto", "Fully Auto"),
  Machine_Time = c(0, 60, 85),
  Operator_Time = c(100, 40, 5),
  y = c(3, 2, 1)
)

cycle_long <- cycle_data %>%
  pivot_longer(cols = c(Machine_Time, Operator_Time), names_to = "Activity", values_to = "Percent")

ggplot(cycle_data) +
  # Manual
  geom_tile(aes(x = 50, y = 3), width = 100, height = 0.5, fill = "#F39C12") +
  annotate("text", x = 50, y = 3, label = "100% Operator Control", color = "white", fontface = "bold") +
  annotate("text", x = -10, y = 3, label = "Manual", fontface = "bold", hjust = 1) +
  # Semi-automated
  geom_tile(aes(x = 20, y = 2), width = 40, height = 0.5, fill = "#F39C12") +
  geom_tile(aes(x = 70, y = 2), width = 60, height = 0.5, fill = "#3498DB") +
  annotate("text", x = 20, y = 2, label = "Load/Unload", color = "white", size = 3) +
  annotate("text", x = 70, y = 2, label = "Auto Cycle", color = "white", size = 3) +
  annotate("text", x = -10, y = 2, label = "Semi-Auto", fontface = "bold", hjust = 1) +
  # Fully automated
  geom_tile(aes(x = 2.5, y = 1), width = 5, height = 0.5, fill = "#F39C12") +
  geom_tile(aes(x = 52.5, y = 1), width = 95, height = 0.5, fill = "#3498DB") +
  annotate("text", x = 52.5, y = 1, label = "Automated Operation (Unattended)", color = "white", size = 3) +
  annotate("text", x = -10, y = 1, label = "Fully Auto", fontface = "bold", hjust = 1) +
  # Legend
  annotate("rect", xmin = 70, xmax = 75, ymin = 3.7, ymax = 3.9, fill = "#F39C12") +
  annotate("text", x = 77, y = 3.8, label = "Operator", hjust = 0, size = 3) +
  annotate("rect", xmin = 90, xmax = 95, ymin = 3.7, ymax = 3.9, fill = "#3498DB") +
  annotate("text", x = 97, y = 3.8, label = "Machine", hjust = 0, size = 3) +
  labs(title = "Work Cycle Distribution by Automation Level",
       x = "Percentage of Cycle Time", y = "") +
  scale_x_continuous(limits = c(-20, 110), breaks = seq(0, 100, 25)) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.y = element_blank(),
    panel.grid.major.y = element_blank()
  )
```

------------------------------------------------------------------------

## Key Time Metrics

Understanding time metrics is essential for analyzing and improving production systems.

```{r time-metrics-table, echo=FALSE}
time_metrics <- tibble(
  `Metric` = c("Takt Time", "Cycle Time", "Lead Time", "Throughput Time"),
  `Definition` = c(
    "Available production time ÷ Customer demand",
    "Time between units coming off the line",
    "Total time from order to delivery",
    "Time from raw material to finished goods"
  ),
  `Formula` = c(
    "$T_{takt} = \\frac{\\text{Available Time}}{\\text{Demand}}$",
    "$T_c = \\frac{60}{R_p}$ (min, if Rp in units/hr)",
    "Order processing + Manufacturing + Delivery",
    "Processing + Waiting + Moving + Inspection"
  ),
  `Purpose` = c(
    "Sets the pace of production to match demand",
    "Actual pace of the production line",
    "Customer's wait time",
    "Internal manufacturing efficiency"
  )
)

time_metrics %>%
  kable(format = "html", escape = FALSE, caption = "Key Manufacturing Time Metrics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D5F5E3", width = "10em")
```

### Takt Time vs. Cycle Time

```{r takt-vs-cycle, echo=TRUE}
# Takt Time Calculation Example
# Automotive assembly plant

# Given data
shift_length_min <- 480      # 8 hours = 480 minutes
breaks_min <- 30             # Two 15-minute breaks
planned_downtime_min <- 20   # Changeover, meetings
customer_demand <- 60        # Cars per shift

# Calculate available time
available_time <- shift_length_min - breaks_min - planned_downtime_min
cat("Available Production Time:", available_time, "minutes per shift\n")

# Calculate Takt Time
takt_time <- available_time / customer_demand
cat("Takt Time:", round(takt_time, 2), "minutes per car\n")
cat("         =", round(takt_time * 60, 1), "seconds per car\n\n")

# Compare to actual cycle time
actual_cycle_time <- 7.5  # minutes (current performance)
cat("Actual Cycle Time:", actual_cycle_time, "minutes per car\n")

if (actual_cycle_time <= takt_time) {
  cat("Status: MEETING DEMAND - Cycle time is within takt time\n")
  cat("Capacity margin:", round((1 - actual_cycle_time/takt_time) * 100, 1), "%\n")
} else {
  cat("Status: CANNOT MEET DEMAND - Cycle time exceeds takt time\n")
  cat("Shortfall:", round((actual_cycle_time/takt_time - 1) * 100, 1), "% over capacity\n")
}
```

<details>
<summary>Discussion: What happens when cycle time exceeds takt time?</summary>

**When Cycle Time > Takt Time, you cannot meet customer demand.**

**Options to fix this:**

1. **Reduce cycle time:**
   - Kaizen improvements at bottleneck
   - Better tools/fixtures
   - Automation of slow tasks

2. **Increase available time:**
   - Add overtime
   - Add shifts
   - Reduce breaks (carefully!)

3. **Add capacity:**
   - Parallel stations at bottleneck
   - Additional production lines
   - Outsourcing

4. **Manage demand:**
   - Negotiate delivery schedules
   - Build inventory in advance
   - Redirect to other facilities

**Key insight:** Takt time is the "heartbeat" of lean manufacturing - everything should be synchronized to it.

</details>

### Manufacturing Cycle Time and Efficiency

```{r mct-mce, echo=TRUE}
# Manufacturing Cycle Time (MCT) and Efficiency (MCE) Example

# Given production data
production_time_min <- 480   # Total time equipment ran
units_produced <- 60         # Good units produced

# MCT Calculation
MCT <- production_time_min / units_produced
cat("Manufacturing Cycle Time (MCT):", MCT, "minutes per unit\n\n")

# MCE Calculation requires understanding of value-added time
# Typical breakdown of production time:
value_added_time <- 3.5      # Actual processing time (minutes)
inspection_time <- 0.5       # Quality checks
wait_time <- 2.5             # Queuing between operations
move_time <- 1.5             # Transport between stations

total_time_per_unit <- value_added_time + inspection_time + wait_time + move_time
cat("Time breakdown per unit:\n")
cat("  Value-added (processing):", value_added_time, "min\n")
cat("  Inspection:", inspection_time, "min\n")
cat("  Waiting:", wait_time, "min\n")
cat("  Moving:", move_time, "min\n")
cat("  Total:", total_time_per_unit, "min\n\n")

# MCE Calculation
MCE <- (value_added_time / total_time_per_unit) * 100
cat("Manufacturing Cycle Efficiency (MCE):", round(MCE, 1), "%\n")
cat("\nInterpretation: Only", round(MCE, 1), "% of time adds value.\n")
cat("Opportunity:", round(100 - MCE, 1), "% of time is waste that could be reduced.\n")
```

```{r mce-visual, echo=FALSE, fig.align="center", fig.cap="Manufacturing Cycle Efficiency - Where Does Time Go?", fig.width=9, fig.height=5}
time_breakdown <- data.frame(
  Activity = c("Value-Added\n(Processing)", "Inspection", "Waiting", "Moving"),
  Time = c(3.5, 0.5, 2.5, 1.5),
  Category = c("Value-Added", "Necessary", "Waste", "Waste")
)

ggplot(time_breakdown, aes(x = reorder(Activity, -Time), y = Time, fill = Category)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = paste0(Time, " min")), vjust = -0.5, fontface = "bold") +
  scale_fill_manual(values = c("Value-Added" = "#27AE60", "Necessary" = "#F39C12", "Waste" = "#E74C3C")) +
  labs(title = "Time Breakdown per Unit - Identifying Improvement Opportunities",
       subtitle = "MCE = Value-Added Time / Total Time = 43.75%",
       x = "", y = "Time (minutes)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```

------------------------------------------------------------------------

## Manual Assembly Lines

Manual assembly lines use human workers at each station. The efficiency depends on how well work is balanced across stations.

### Line Balancing

**Line balancing** assigns tasks to workstations to minimize idle time while meeting production rate requirements.

**Key formulas:**

$$T_c = \frac{\text{Available Time}}{\text{Required Output}} = \frac{60}{R_p}$$

$$TM = \frac{\sum t_i}{T_c} = \frac{T_{wc}}{T_c}$$

$$E_b = \frac{T_{wc}}{n \times T_c} \times 100\%$$

Where:
- $T_c$ = Cycle time (time available per unit)
- $R_p$ = Production rate (units per hour)
- $TM$ = Theoretical minimum stations
- $T_{wc}$ = Total work content (sum of all task times)
- $n$ = Actual number of stations
- $E_b$ = Line efficiency (balance efficiency)

### Line Balancing Example: Electronics Assembly

```{r line-balance-example, echo=TRUE}
# Line Balancing Example: Tablet Computer Assembly

# Task data
tasks <- data.frame(
  Task = c("A", "B", "C", "D", "E", "F", "G", "H"),
  Description = c("Install battery", "Mount display", "Connect cables",
                  "Install motherboard", "Add memory", "Install camera",
                  "Attach case back", "Final test"),
  Time_sec = c(30, 45, 20, 55, 15, 25, 35, 40),
  Predecessors = c("-", "A", "A", "B,C", "D", "D", "E,F", "G")
)

# Display task data
cat("Assembly Tasks:\n")
print(tasks[, c("Task", "Description", "Time_sec", "Predecessors")])

# Calculate metrics
total_work_content <- sum(tasks$Time_sec)
cat("\nTotal Work Content:", total_work_content, "seconds\n")

# Production requirements
desired_output <- 45  # units per hour
available_time <- 3600  # seconds per hour

# Step 1: Calculate cycle time
cycle_time <- available_time / desired_output
cat("\nStep 1 - Cycle Time:")
cat("\n  Required output:", desired_output, "units/hour")
cat("\n  Cycle time = 3600 /", desired_output, "=", cycle_time, "seconds\n")

# Step 2: Calculate theoretical minimum stations
TM <- total_work_content / cycle_time
cat("\nStep 2 - Theoretical Minimum Stations:")
cat("\n  TM =", total_work_content, "/", cycle_time, "=", round(TM, 2))
cat("\n  Minimum stations required:", ceiling(TM), "\n")

# Step 3: Assign tasks to stations (using largest task time rule)
cat("\nStep 3 - Station Assignments (respecting precedence):\n")
cat("  Station 1: A (30s) + C (20s) + B (45s) = 95s > 80s... EXCEEDS\n")
cat("  Let's try: A (30s) + C (20s) = 50s [30s idle]\n")
cat("  Station 2: B (45s) + E (15s) = 60s... wait, E needs D\n")
cat("  Station 2: B (45s) + D (55s) = 100s > 80s... EXCEEDS\n")
cat("  Station 2: B (45s) = 45s [35s idle]\n")
cat("  Station 3: D (55s) = 55s [25s idle]\n")
cat("  Station 4: E (15s) + F (25s) + G (35s) = 75s [5s idle]\n")
cat("  Station 5: H (40s) = 40s [40s idle]\n")

n_stations <- 5
efficiency <- (total_work_content / (n_stations * cycle_time)) * 100
balance_delay <- 100 - efficiency

cat("\nStep 4 - Results:")
cat("\n  Number of stations:", n_stations)
cat("\n  Line efficiency:", round(efficiency, 1), "%")
cat("\n  Balance delay (idle time):", round(balance_delay, 1), "%")
cat("\n\n  This is poor balance - consider redesigning tasks or adding parallel stations.")
```

```{r precedence-diagram, echo=FALSE, fig.align="center", fig.cap="Precedence Diagram for Tablet Assembly", fig.width=10, fig.height=5}
# Create precedence diagram
nodes <- data.frame(
  task = c("A", "B", "C", "D", "E", "F", "G", "H"),
  x = c(1, 2, 2, 3, 4, 4, 5, 6),
  y = c(2, 2.5, 1.5, 2, 2.5, 1.5, 2, 2),
  time = c(30, 45, 20, 55, 15, 25, 35, 40)
)

edges <- data.frame(
  x = c(1, 1, 2, 2, 3, 3, 4, 4, 5),
  y = c(2, 2, 2.5, 1.5, 2, 2, 2.5, 1.5, 2),
  xend = c(2, 2, 3, 3, 4, 4, 5, 5, 6),
  yend = c(2.5, 1.5, 2, 2, 2.5, 1.5, 2, 2, 2)
)

ggplot() +
  geom_segment(data = edges, aes(x = x + 0.15, y = y, xend = xend - 0.15, yend = yend),
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  geom_point(data = nodes, aes(x = x, y = y), size = 16, color = "#3498DB") +
  geom_text(data = nodes, aes(x = x, y = y + 0.08, label = task),
            color = "white", fontface = "bold", size = 5) +
  geom_text(data = nodes, aes(x = x, y = y - 0.12, label = paste0(time, "s")),
            color = "white", size = 3.5) +
  labs(title = "Precedence Diagram: Tablet Assembly",
       subtitle = "Arrows indicate task sequence requirements") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 11)
  ) +
  xlim(0.5, 6.5) + ylim(1, 3)
```

<details>
<summary>Try It: Can you find a better balance?</summary>

**Challenge:** Reassign tasks to improve efficiency above 80%.

**Hints:**
- Can task A be split into two smaller tasks?
- Could parallel workstations handle the bottleneck task D?
- What if we allow 85 seconds per station (slower line, fewer stations)?

**One solution with parallel stations:**
- Station 1: A + C = 50s
- Station 2a: B = 45s (parallel)
- Station 2b: B = 45s (parallel)
- Station 3: D = 55s
- Station 4: E + F = 40s
- Station 5: G + H = 75s

With parallelism at Station 2, effective cycle time stays at 55s (Station 3 bottleneck), but we can now achieve higher throughput.

</details>

------------------------------------------------------------------------

## Automated Production Lines

Automated lines reduce human intervention using mechanized transfer systems and automated workstations. They're used for high-volume production with well-defined work content.

### Impact of Station Failures

The performance of automated lines is degraded by station failures. Even small failure probabilities can significantly reduce output.

**Actual Cycle Time:**
$$T_p = T_c + pT$$

**Actual Production Rate:**
$$R_p = \frac{60}{T_p} = \frac{60}{T_c + pT}$$

Where:
- $T_c$ = Ideal cycle time (minutes)
- $p$ = Probability of station failure per cycle
- $T$ = Average downtime per failure (minutes)

```{r downtime-analysis, echo=TRUE}
# Automated Line Performance Analysis

# Line parameters
ideal_cycle_time <- 1.0    # minutes per part (ideal)
n_stations <- 10           # Number of stations

# Scenario comparison
scenarios <- data.frame(
  Scenario = c("World Class", "Good", "Average", "Poor"),
  Failure_Prob = c(0.005, 0.02, 0.05, 0.10),  # Per station per cycle
  Repair_Time = c(2, 5, 10, 15)  # Minutes average
)

# Calculate line performance for each scenario
cat("Automated Line Performance Analysis\n")
cat("===================================\n")
cat("Ideal cycle time:", ideal_cycle_time, "min/part\n")
cat("Number of stations:", n_stations, "\n")
cat("Ideal production rate:", 60/ideal_cycle_time, "parts/hour\n\n")

for(i in 1:nrow(scenarios)) {
  p <- scenarios$Failure_Prob[i]
  T <- scenarios$Repair_Time[i]

  # Line failure probability (any station)
  p_line <- 1 - (1 - p)^n_stations

  # Actual cycle time
  Tp <- ideal_cycle_time + p_line * T

  # Actual production rate
  Rp <- 60 / Tp

  # Efficiency
  efficiency <- (ideal_cycle_time / Tp) * 100

  cat(sprintf("%s Performance:\n", scenarios$Scenario[i]))
  cat(sprintf("  Station failure prob: %.1f%%\n", p * 100))
  cat(sprintf("  Line failure prob: %.1f%%\n", p_line * 100))
  cat(sprintf("  Average repair time: %d min\n", T))
  cat(sprintf("  Actual cycle time: %.2f min\n", Tp))
  cat(sprintf("  Actual production: %.1f parts/hour\n", Rp))
  cat(sprintf("  Line efficiency: %.1f%%\n\n", efficiency))
}
```

```{r downtime-visual, echo=FALSE, fig.align="center", fig.cap="Impact of Station Failures on Production Rate", fig.width=10, fig.height=6}
# Create visualization of failure impact
p_range <- seq(0, 0.10, 0.005)
repair_times <- c(5, 10, 20)

sim_data <- expand.grid(p = p_range, T = repair_times) %>%
  mutate(
    p_line = 1 - (1 - p)^10,
    Tp = 1.0 + p_line * T,
    Rp = 60 / Tp,
    Repair_Scenario = paste0("Repair Time = ", T, " min")
  )

ggplot(sim_data, aes(x = p * 100, y = Rp, color = Repair_Scenario)) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = 60, linetype = "dashed", color = "gray50") +
  annotate("text", x = 1, y = 62, label = "Ideal Rate (60 parts/hr)", size = 3.5) +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Production Rate vs. Station Failure Probability",
       subtitle = "10-station line, 1-minute ideal cycle time",
       x = "Station Failure Probability (%)",
       y = "Actual Production Rate (parts/hour)",
       color = "Downtime Scenario") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```

<details>
<summary>Discussion: Why is preventive maintenance critical for automated lines?</summary>

**The math shows why:**
- At 5% failure probability with 10-minute repairs, you lose 25% of capacity
- This costs more than the maintenance to prevent it

**Cost comparison (example):**
- Lost production: 15 parts/hour × $50/part × 8 hours = $6,000/day
- Preventive maintenance: $500/day
- **ROI of PM: 12:1**

**Best practices:**
1. Track failure data by station
2. Prioritize PM on high-failure stations
3. Stock critical spare parts
4. Train operators on quick changeover/repair
5. Consider redundant stations for bottlenecks

</details>

### Buffer Sizing

Buffers between stations decouple operations and improve overall line availability.

```{r buffer-analysis, echo=FALSE, fig.align="center", fig.cap="Effect of Buffers on Line Availability", fig.width=9, fig.height=5}
# Simplified buffer effectiveness model
buffer_sizes <- 0:10
station_availability <- 0.95  # 95% availability per station

# Without buffers, line availability = A^n
no_buffer <- station_availability^5  # 5 stations

# With buffers, availability improves (simplified model)
buffer_effect <- data.frame(
  Buffer_Size = buffer_sizes,
  Line_Availability = no_buffer + (1 - no_buffer) * (1 - exp(-buffer_sizes/3))
)

ggplot(buffer_effect, aes(x = Buffer_Size, y = Line_Availability * 100)) +
  geom_line(color = "#3498DB", size = 1.5) +
  geom_point(color = "#3498DB", size = 3) +
  geom_hline(yintercept = no_buffer * 100, linetype = "dashed", color = "#E74C3C") +
  annotate("text", x = 8, y = no_buffer * 100 + 1,
           label = "No buffers (77.4%)", color = "#E74C3C") +
  geom_hline(yintercept = 95, linetype = "dashed", color = "#27AE60") +
  annotate("text", x = 8, y = 96, label = "Target (95%)", color = "#27AE60") +
  labs(title = "Line Availability vs. Buffer Size",
       subtitle = "5-station line, 95% station availability each",
       x = "Buffer Size (units between stations)",
       y = "Line Availability (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  ylim(75, 100)
```

------------------------------------------------------------------------

## Cellular Manufacturing

**Cellular manufacturing** applies Group Technology to organize production into cells that specialize in "families" of similar parts.

### Part Families and Machine Cells

```{r cellular-concept, echo=FALSE, fig.align="center", fig.cap="Cellular Manufacturing: From Process Layout to Cells", fig.width=12, fig.height=6}
# Show transformation from process to cellular layout

# Process layout (before)
process_machines <- data.frame(
  Machine = c("L1", "L2", "L3", "M1", "M2", "M3", "D1", "D2", "G1", "G2"),
  Type = c(rep("Lathe", 3), rep("Mill", 3), rep("Drill", 2), rep("Grinder", 2)),
  x = c(1, 1.5, 2, 3, 3.5, 4, 5, 5.5, 6, 6.5),
  y_before = c(3, 2.5, 3.5, 3, 2.5, 3.5, 3, 2.5, 3, 2.5)
)

# Cellular layout (after)
cellular_machines <- data.frame(
  Machine = c("L1", "M1", "D1", "G1", "L2", "M2", "D2", "G2"),
  Cell = c(rep("Cell A: Shaft Family", 4), rep("Cell B: Housing Family", 4)),
  x = c(1, 2, 3, 4, 1, 2, 3, 4),
  y = c(2, 2, 2, 2, 1, 1, 1, 1),
  color = c(rep("#E74C3C", 4), rep("#3498DB", 4))
)

p_cellular <- ggplot(cellular_machines, aes(x = x, y = y)) +
  # Cell backgrounds
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 1.7, ymax = 2.3,
           fill = "#E74C3C", alpha = 0.15) +
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 0.7, ymax = 1.3,
           fill = "#3498DB", alpha = 0.15) +
  geom_tile(aes(fill = color), width = 0.5, height = 0.3, color = "black") +
  geom_text(aes(label = Machine), size = 3, fontface = "bold") +
  geom_segment(data = cellular_machines[c(1:3, 5:7),],
               aes(x = x + 0.3, xend = x + 0.7, y = y, yend = y),
               arrow = arrow(length = unit(0.15, "cm")), color = "black") +
  annotate("text", x = 0.3, y = 2, label = "Cell A:\nShafts", hjust = 1, fontface = "bold", color = "#E74C3C") +
  annotate("text", x = 0.3, y = 1, label = "Cell B:\nHousings", hjust = 1, fontface = "bold", color = "#3498DB") +
  scale_fill_identity() +
  labs(title = "Cellular Layout",
       subtitle = "Parts grouped into families, each in dedicated cell") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  xlim(-0.3, 5)

p_cellular
```

```{r cellular-benefits, echo=FALSE}
cellular_comparison <- tibble(
  Metric = c("Setup time", "Work-in-process", "Lead time", "Quality defects",
             "Material handling", "Floor space", "Worker skills"),
  `Traditional (Process)` = c("High - frequent changeovers", "High - batches waiting",
                              "Long - complex routing", "Higher - multiple handoffs",
                              "High - long distances", "More - large aisles",
                              "Specialized by machine"),
  `Cellular` = c("Low - dedicated to family", "Low - continuous flow",
                "Short - U-cell flow", "Lower - cell ownership",
                "Low - within cell", "Less - compact cells",
                "Cross-trained on cell"),
  `Typical Improvement` = c("50-90% reduction", "50-90% reduction",
                           "50-80% reduction", "30-50% reduction",
                           "40-70% reduction", "20-50% reduction",
                           "Increased flexibility")
)

cellular_comparison %>%
  kable(format = "html", caption = "Cellular Manufacturing Benefits vs. Traditional Process Layout") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D5F5E3") %>%
  column_spec(4, background = "#FCF3CF")
```

------------------------------------------------------------------------

## Flexible Manufacturing Systems (FMS)

An **FMS** is a highly automated cell consisting of CNC machines interconnected by automated material handling, all controlled by a central computer.

### FMS Components

```{r fms-components, echo=FALSE, fig.align="center", fig.cap="Flexible Manufacturing System Components", fig.width=11, fig.height=6}
# FMS schematic
fms_data <- data.frame(
  Component = c("CNC\nMachine 1", "CNC\nMachine 2", "CNC\nMachine 3",
                "CNC\nMachine 4", "Load/Unload\nStation", "Central\nComputer"),
  x = c(2, 4, 6, 4, 1, 4),
  y = c(2, 3, 2, 1, 2, 2),
  type = c(rep("Machine", 4), "Station", "Computer"),
  color = c(rep("#3498DB", 4), "#F39C12", "#9B59B6")
)

ggplot(fms_data, aes(x = x, y = y)) +
  # AGV track
  annotate("path",
           x = c(1.5, 2, 4, 6, 6, 4, 2, 1.5, 1.5),
           y = c(2, 2.8, 3.5, 2.8, 1.2, 0.5, 1.2, 2, 2),
           color = "#95A5A6", size = 3, linetype = "dashed") +
  annotate("text", x = 3, y = 0.3, label = "AGV Track", color = "#95A5A6", fontface = "italic") +
  # Components
  geom_tile(aes(fill = color), width = 1.2, height = 0.8, color = "black") +
  geom_text(aes(label = Component), size = 3, fontface = "bold") +
  # Connections to central computer
  geom_segment(aes(x = 4, xend = 2.5, y = 2.4, yend = 2.3), linetype = "dotted") +
  geom_segment(aes(x = 4, xend = 4, y = 2.4, yend = 2.6), linetype = "dotted") +
  geom_segment(aes(x = 4, xend = 5.5, y = 2.4, yend = 2.3), linetype = "dotted") +
  geom_segment(aes(x = 4, xend = 4, y = 1.6, yend = 1.4), linetype = "dotted") +
  annotate("text", x = 5, y = 2.5, label = "Network\nConnections", size = 2.5, fontface = "italic") +
  scale_fill_identity() +
  labs(title = "Flexible Manufacturing System (FMS) Layout",
       subtitle = "CNC machines connected by AGV with central computer control") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 11)
  ) +
  xlim(0, 7) + ylim(0, 4)
```

```{r fms-applications, echo=FALSE}
fms_apps <- tibble(
  `Characteristic` = c("Production Volume", "Part Variety", "Batch Size", "Setup Time",
                       "Typical Parts", "Investment", "Best Suited For"),
  `FMS Capability` = c(
    "Medium (2,000 - 100,000/year per part type)",
    "Medium (4-100 different part types)",
    "Small to medium (1-500 per batch)",
    "Minimal (automatic pallet/fixture changes)",
    "Prismatic parts (housings, brackets, covers)",
    "$5M - $50M+ depending on size",
    "Aerospace, automotive components, job shops with repeat parts"
  )
)

fms_apps %>%
  kable(format = "html", caption = "FMS Characteristics and Applications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#E8DAEF", width = "12em")
```

------------------------------------------------------------------------

## Modern Manufacturing Concepts

### SMED (Single-Minute Exchange of Die)

**SMED** is a lean manufacturing technique to reduce changeover time to under 10 minutes ("single digit minutes").

```{r smed-process, echo=FALSE}
smed_steps <- tibble(
  Step = c("1. Separate", "2. Convert", "3. Streamline"),
  Description = c(
    "Distinguish internal setup (machine stopped) from external setup (machine running)",
    "Convert as much internal setup to external setup as possible",
    "Reduce time for remaining internal and external activities"
  ),
  Examples = c(
    "Pre-stage tools while machine runs; Pre-heat molds; Prepare fixtures",
    "Use quick-release clamps instead of bolts; Standardize tool heights",
    "Eliminate adjustments; Use one-turn fasteners; Parallel operations with 2 people"
  ),
  `Typical Improvement` = c("30-50% reduction", "Additional 20-30%", "Additional 10-20%")
)

smed_steps %>%
  kable(format = "html", caption = "SMED Methodology for Setup Reduction") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#FADBD8", width = "8em")
```

<details>
<summary>Case Study: Injection Molding Changeover</summary>

**Before SMED:**
- Changeover time: 90 minutes
- Machine stopped for entire process
- One operator working alone

**After SMED analysis:**

| Activity | Before | Type | After | Change |
|----------|--------|------|-------|--------|
| Find tools | 10 min | Internal | 0 | External - tools pre-staged |
| Remove old mold | 15 min | Internal | 5 min | Quick-release clamps |
| Get new mold | 10 min | Internal | 0 | External - mold pre-staged at machine |
| Install new mold | 20 min | Internal | 8 min | Standardized mold heights |
| Connect utilities | 10 min | Internal | 4 min | Quick-connect fittings |
| Adjust settings | 15 min | Internal | 3 min | Pre-programmed recipes |
| First article | 10 min | Internal | 5 min | Improved documentation |

**Results:**
- Total changeover: 25 minutes (72% reduction)
- Additional capacity: +15 changeovers/week possible
- Smaller batch sizes now economical

</details>

### AGV and AMR Systems

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/7Pq-S557XQU"
    title="AGV vs AMR Comparison"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

```{r agv-amr-comparison, echo=FALSE}
agv_amr <- tibble(
  Feature = c("Navigation", "Flexibility", "Infrastructure", "Cost",
              "Path Changes", "Obstacle Handling", "Best Application"),
  `AGV (Automated Guided Vehicle)` = c(
    "Fixed path (wires, magnets, tape)",
    "Low - follows predetermined routes",
    "Requires installation (floor modifications)",
    "Lower vehicle cost, higher infrastructure",
    "Requires physical modification",
    "Stops and waits",
    "High-volume, repetitive routes"
  ),
  `AMR (Autonomous Mobile Robot)` = c(
    "Dynamic (SLAM, vision, sensors)",
    "High - calculates optimal routes",
    "Minimal (maps environment)",
    "Higher vehicle cost, lower infrastructure",
    "Software update only",
    "Navigates around obstacles",
    "Variable routes, dynamic environments"
  )
)

agv_amr %>%
  kable(format = "html", caption = "AGV vs. AMR Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1")
```

### Digital Twin

A **digital twin** is a virtual representation of a physical manufacturing system that is updated in real-time with sensor data.

```{r digital-twin-viz, echo=FALSE, fig.align="center", fig.cap="Digital Twin Concept", fig.width=10, fig.height=5}
# Digital twin conceptual diagram
dt_data <- data.frame(
  Component = c("Physical\nSystem", "Sensors &\nIoT", "Digital\nTwin", "Analytics &\nAI", "Visualization"),
  x = 1:5,
  y = 1
)

ggplot(dt_data, aes(x = x, y = y)) +
  geom_tile(fill = c("#3498DB", "#27AE60", "#9B59B6", "#E74C3C", "#F39C12"),
            width = 0.8, height = 0.5, color = "white", size = 2) +
  geom_text(aes(label = Component), color = "white", fontface = "bold", size = 3.5) +
  geom_segment(data = dt_data[1:4,], aes(x = x + 0.45, xend = x + 0.55, y = y, yend = y),
               arrow = arrow(length = unit(0.25, "cm")), color = "#2C3E50", size = 1.2) +
  # Feedback loop
  annotate("curve", x = 5, xend = 1, y = 0.65, yend = 0.65,
           curvature = -0.3, arrow = arrow(length = unit(0.2, "cm")),
           color = "#7F8C8D", linetype = "dashed") +
  annotate("text", x = 3, y = 0.4, label = "Feedback for optimization",
           color = "#7F8C8D", fontface = "italic") +
  labs(title = "Digital Twin Data Flow",
       subtitle = "Real-time connection between physical and virtual systems") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  ylim(0.2, 1.5)
```

**Digital Twin Applications:**
- Predictive maintenance (predict failures before they occur)
- Process optimization (simulate changes before implementation)
- Training (virtual commissioning and operator training)
- Quality prediction (correlate parameters with outcomes)

------------------------------------------------------------------------

## Industry Applications

```{r industry-applications-ch3, echo=FALSE}
industry_apps <- tibble(
  `System Type` = c("Transfer Line", "Manual Assembly", "FMS", "Cellular", "AGV/AMR"),
  `Automotive` = c(
    "Engine block machining, cylinder head lines",
    "Final vehicle assembly, interior trim",
    "Transmission components, brake parts",
    "Subassemblies, wiring harnesses",
    "Body shop material delivery, parts sequencing"
  ),
  `Food Processing` = c(
    "Beverage bottling, canning lines",
    "Packaging, quality inspection",
    "Multi-product bakery equipment",
    "Specialty product lines",
    "Ingredient delivery, packaging transport"
  ),
  `Aerospace/Defense` = c(
    "High-volume fastener production",
    "Aircraft final assembly, inspection",
    "Structural component machining",
    "Avionics assembly, repair cells",
    "Large assembly transport, tool delivery"
  )
)

industry_apps %>%
  kable(format = "html", caption = "Manufacturing System Applications by Industry") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D4E6F1") %>%
  column_spec(2, background = "#FCF3CF") %>%
  column_spec(3, background = "#D5F5E3") %>%
  column_spec(4, background = "#FADBD8")
```

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: Takt Time Calculation</summary>

**A plant operates 8-hour shifts with 30 minutes of breaks. Daily demand is 400 units. Calculate the takt time.**

**Solution:**

Available time = 8 hours × 60 min - 30 min = 450 minutes

Takt time = 450 min / 400 units = **1.125 minutes per unit** = 67.5 seconds

If actual cycle time is 60 seconds, the plant has (67.5 - 60)/67.5 = **11% capacity margin**.

</details>

<details>
<summary>Question 2: Line Efficiency</summary>

**A 6-station assembly line has a cycle time of 2 minutes. The task times at each station are: 1.8, 1.9, 2.0, 1.7, 1.6, and 1.5 minutes. Calculate the line efficiency.**

**Solution:**

Total work content = 1.8 + 1.9 + 2.0 + 1.7 + 1.6 + 1.5 = 10.5 minutes

Line efficiency = (10.5) / (6 × 2.0) × 100% = 10.5/12 × 100% = **87.5%**

Balance delay (idle time) = 100% - 87.5% = **12.5%**

</details>

<details>
<summary>Question 3: Downtime Impact</summary>

**An automated line has 8 stations, each with 3% failure probability per cycle and 8-minute average repair time. The ideal cycle time is 0.5 minutes. What is the actual production rate?**

**Solution:**

Line failure probability = 1 - (1 - 0.03)^8 = 1 - 0.97^8 = 1 - 0.784 = **21.6%**

Actual cycle time = 0.5 + (0.216 × 8) = 0.5 + 1.73 = **2.23 minutes**

Actual production rate = 60 / 2.23 = **26.9 parts/hour**

(vs. ideal of 120 parts/hour - only 22% of ideal capacity!)

This shows why reliability is critical in automated systems.

</details>

<details>
<summary>Question 4: FMS Selection</summary>

**A company makes 15 different part numbers with annual volumes of 500-5,000 each. Parts are machined from aluminum and require milling, drilling, and tapping. Which system is most appropriate: dedicated transfer line, FMS, or CNC job shop?**

**Answer:** **FMS is most appropriate** because:

- **Volume range (500-5,000)** is ideal for FMS
- **Part variety (15 types)** requires flexibility
- **Similar operations** (milling, drilling, tapping) can share equipment
- **Material (aluminum)** machines well on CNC

Transfer line would require too much volume per part. Job shop would have high setup times and low efficiency for these volumes.

</details>

<details>
<summary>Question 5: SMED Application</summary>

**A stamping press has a 45-minute die change. Internal activities are 35 minutes, external are 10 minutes but currently done with machine stopped. How much can SMED reduce this?**

**Answer:**

**Step 1 - Separate:** Do the 10 minutes of external work while press runs.
- New changeover: 35 minutes (30% reduction)

**Step 2 - Convert:** Analyze the 35 minutes:
- If 15 minutes can be converted to external (pre-staging, etc.): New changeover = 20 minutes

**Step 3 - Streamline:** Quick-release clamps, standardization might save another 5 minutes.
- Final changeover: **15 minutes (67% reduction)**

This enables smaller batch sizes and more frequent changeovers.

</details>

------------------------------------------------------------------------

## Summary

```{r summary-ch3, echo=FALSE}
summary_ch3 <- tibble(
  Topic = c("Production Lines", "Time Metrics", "Line Balancing", "Automated Lines",
            "Cellular Manufacturing", "FMS", "Modern Concepts"),
  `Key Points` = c(
    "Manual, continuous, synchronous, or asynchronous transfer; each has trade-offs",
    "Takt time = demand pace; Cycle time = actual pace; MCE measures value-added %",
    "Assign tasks to minimize idle time; Efficiency = work content / (stations × cycle time)",
    "Reliability is critical; Small failure probabilities cause large capacity losses",
    "Group Technology groups part families; Reduces setup, WIP, lead time 50-90%",
    "Automated cells for medium variety/volume; Computer-controlled flexibility",
    "SMED for quick changeover; AGV/AMR for material handling; Digital twins for optimization"
  )
)

summary_ch3 %>%
  kable(format = "html", caption = "Chapter 3 Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"), full_width = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#1A5276", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Key Takeaways

1. **Match system to product** - Volume and variety determine optimal manufacturing system
2. **Takt time sets the pace** - Everything should be designed to meet customer demand rate
3. **Balance matters** - Unbalanced lines waste capacity through idle time
4. **Reliability is critical** - Small failures compound to large losses in automated systems
5. **Flexibility has value** - FMS and cellular systems enable quick response to change
6. **Technology evolves** - Digital twins and AMRs are transforming manufacturing

------------------------------------------------------------------------

## References

1. Groover, M.P. (2020). *Automation, Production Systems, and Computer-Integrated Manufacturing* (5th ed.). Pearson.
2. Liker, J.K. (2004). *The Toyota Way*. McGraw-Hill.
3. Shingo, S. (1985). *A Revolution in Manufacturing: The SMED System*. Productivity Press.
4. Black, J.T. (1991). *The Design of the Factory with a Future*. McGraw-Hill.

<!--chapter:end:03-Integrated-Manufacturing-Systems.Rmd-->

# Plant Layout and Facility Design

------------------------------------------------------------------------

```{r setup-ch4, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Identify and describe the four basic types of facility layouts
- Compare the advantages and disadvantages of each layout type
- Apply the steps involved in designing a process layout
- Calculate cycle time, theoretical minimum stations, and line efficiency for product layouts
- Understand the principles of warehouse and office layout design

<details>
<summary>Why is Plant Layout Important?</summary>

Plant layout directly impacts:

- **Productivity:** Efficient layouts minimize wasted movement and time
- **Cost:** Poor layouts increase material handling costs by 20-50%
- **Safety:** Well-designed layouts reduce accidents and injuries
- **Flexibility:** The right layout allows adaptation to changing demands
- **Employee Morale:** Good layouts improve working conditions

</details>

------------------------------------------------------------------------

## Types of Facility Layouts

There are **four basic layout types**, each suited to different production requirements:

```{r layout-types-table, echo=FALSE}
layout_data <- tibble(
  `Layout Type` = c("Process Layout", "Product Layout", "Hybrid/Cellular Layout", "Fixed-Position Layout"),
  `Also Known As` = c("Functional Layout, Job Shop", "Flow Line, Assembly Line", "Group Technology, Cell Layout", "Project Layout"),
  `Best For` = c("High variety, low volume", "Low variety, high volume", "Medium variety, medium volume", "Very large or immobile products"),
  `Example Industries` = c("Hospitals, Machine Shops, Universities", "Automotive Assembly, Food Processing", "Electronics Manufacturing, Furniture", "Shipbuilding, Aircraft, Construction")
)

layout_data %>%
  kable(format = "html", caption = "Overview of Facility Layout Types") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = TRUE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE, width = "12em") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

### Visualizing the Layout Spectrum

```{r layout-spectrum, echo=FALSE, fig.align="center", fig.cap="Product Variety vs. Production Volume for Different Layouts", fig.width=8, fig.height=5}
# Create a visualization of layout types based on variety and volume
layout_viz <- data.frame(
  Layout = c("Fixed-Position", "Process", "Cellular", "Product"),
  Volume = c(1, 2, 3, 4),
  Variety = c(4, 3.5, 2.5, 1),
  Size = c(15, 20, 20, 25)
)

ggplot(layout_viz, aes(x = Volume, y = Variety, label = Layout)) +
  geom_point(aes(size = Size, color = Layout), alpha = 0.7) +
  geom_text(vjust = -1.5, fontface = "bold", size = 4) +
  scale_x_continuous(limits = c(0, 5), breaks = 1:4,
                     labels = c("Very Low", "Low", "Medium", "High")) +
  scale_y_continuous(limits = c(0, 5), breaks = 1:4,
                     labels = c("Standardized", "Low", "Medium", "High")) +
  scale_size_continuous(range = c(10, 25), guide = "none") +
  scale_color_manual(values = c("#E74C3C", "#3498DB", "#2ECC71", "#9B59B6"), guide = "none") +
  labs(x = "Production Volume", y = "Product Variety",
       title = "Facility Layout Selection Guide") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  ) +
  annotate("segment", x = 0.5, xend = 4.5, y = 0.5, yend = 4.5,
           arrow = arrow(length = unit(0.3, "cm")), color = "gray50", linetype = "dashed")
```

------------------------------------------------------------------------

## Process Layout (Functional Layout)

In a **process layout**, similar resources (machines, equipment, workers with similar skills) are grouped together. Work flows between departments based on the specific requirements of each job.

```{r process-layout-diagram, echo=FALSE, fig.align="center", fig.cap="Example Process Layout - Machine Shop", fig.width=9, fig.height=6}
# Create a simple process layout visualization
library(ggplot2)

departments <- data.frame(
  name = c("Receiving", "Lathes", "Milling", "Drilling", "Grinding", "Assembly", "Painting", "Shipping"),
  x = c(1, 2, 4, 2, 4, 3, 5, 6),
  y = c(3, 4, 4, 2, 2, 3, 3, 3),
  color = c("#95A5A6", "#3498DB", "#3498DB", "#3498DB", "#3498DB", "#2ECC71", "#9B59B6", "#95A5A6")
)

# Flow paths for different products
flow_A <- data.frame(
  x = c(1, 2, 4, 4, 3, 5, 6),
  y = c(3, 4, 4, 2, 3, 3, 3),
  product = "Product A"
)

flow_B <- data.frame(
  x = c(1, 2, 2, 4, 3, 6),
  y = c(3, 4, 2, 2, 3, 3),
  product = "Product B"
)

ggplot() +
  # Department boxes
  geom_tile(data = departments, aes(x = x, y = y, fill = color),
            width = 0.8, height = 0.6, alpha = 0.8, color = "black") +
  geom_text(data = departments, aes(x = x, y = y, label = name),
            fontface = "bold", size = 3.5) +
  # Flow paths
  geom_path(data = flow_A, aes(x = x, y = y + 0.05),
            color = "#E74C3C", size = 1.2, arrow = arrow(length = unit(0.2, "cm")),
            linetype = "solid") +
  geom_path(data = flow_B, aes(x = x, y = y - 0.05),
            color = "#F39C12", size = 1.2, arrow = arrow(length = unit(0.2, "cm")),
            linetype = "dashed") +
  scale_fill_identity() +
  labs(title = "Process Layout: Machine Shop Example",
       subtitle = "Different products follow different paths through the facility") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  annotate("text", x = 6.5, y = 4, label = "Product A", color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 6.5, y = 3.7, label = "Product B", color = "#F39C12", fontface = "bold") +
  coord_fixed(ratio = 1)
```

### Characteristics of Process Layouts

```{r process-characteristics, echo=FALSE}
process_chars <- tibble(
  Characteristic = c("Equipment", "Labor", "Flexibility", "Processing Speed",
                     "Material Handling", "Scheduling", "Space Requirements"),
  Description = c("General-purpose machines", "Skilled workers required",
                  "High - can handle variety", "Slower due to varied routing",
                  "Higher costs (complex paths)", "Complex - different routes",
                  "Higher - WIP inventory storage")
)

process_chars %>%
  kable(format = "html", caption = "Process Layout Characteristics") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE, width = "10em", background = "#EBF5FB")
```

<details>
<summary>Discussion Question: Can you identify a process layout in your daily life?</summary>

**Think about:**
- A hospital emergency room (patients routed based on their needs)
- A university campus (students move between buildings for different classes)
- A grocery store (customers choose their own path)
- A machine shop (parts routed based on required operations)

**What makes these process layouts?** Similar functions are grouped together, and "products" (patients, students, customers) follow different paths based on their individual needs.

</details>

### Real-World Examples

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/DrO5sS51Yk8&t"
    title="Process Layout Example"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## Product Layout (Assembly Line)

In a **product layout**, equipment and workstations are arranged in a line according to the sequence of operations needed to produce the product. Every unit follows the same path.

```{r product-layout-diagram, echo=FALSE, fig.align="center", fig.cap="Product Layout - Assembly Line", fig.width=10, fig.height=4}
stations <- data.frame(
  name = c("Station 1\nFrame", "Station 2\nEngine", "Station 3\nBody",
           "Station 4\nInterior", "Station 5\nWheels", "Station 6\nQuality"),
  x = c(1, 2, 3, 4, 5, 6),
  y = rep(1, 6)
)

ggplot(stations, aes(x = x, y = y)) +
  geom_tile(fill = "#3498DB", width = 0.7, height = 0.5, color = "black") +
  geom_text(aes(label = name), color = "white", fontface = "bold", size = 3) +
  geom_segment(aes(x = x + 0.4, xend = x + 0.6, y = y, yend = y),
               data = stations[1:5,],
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1.5) +
  labs(title = "Product Layout: Automotive Assembly Line",
       subtitle = "All products follow the same sequential path") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(0.3, 6.7)
```

### Characteristics of Product Layouts

```{r product-characteristics, echo=FALSE}
product_chars <- tibble(
  Advantage = c("High production rate", "Low unit cost", "Low material handling",
                "Simple scheduling", "Less WIP inventory"),
  Disadvantage = c("High initial investment", "Low flexibility", "Line stops affect all",
                   "Monotonous work", "Requires balanced workloads")
)

product_chars %>%
  kable(format = "html", caption = "Product Layout: Advantages vs. Disadvantages") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "center") %>%
  column_spec(1, background = "#D5F5E3", width = "15em") %>%
  column_spec(2, background = "#FADBD8", width = "15em") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

<details>
<summary>Quick Quiz: Product Layout</summary>

**Question:** A car wash where vehicles move through a series of cleaning stations is an example of which layout type?

**Answer:** Product Layout - all cars follow the same path through the same sequence of operations.

</details>

------------------------------------------------------------------------

## Hybrid Layout (Cellular Manufacturing)

**Hybrid layouts** combine the flexibility of process layouts with the efficiency of product layouts. The most common type is the **cellular layout** using Group Technology.

### Group Technology Concept

Group Technology (GT) identifies parts with similar characteristics and groups them into **part families**. Machines are then arranged into **cells** to process these families.

```{r cellular-layout, echo=FALSE, fig.align="center", fig.cap="Cellular Layout with Manufacturing Cells", fig.width=10, fig.height=6}
# Create cells visualization
cell_data <- data.frame(
  cell = c(rep("Cell A\nShaft Family", 4), rep("Cell B\nGear Family", 4), rep("Cell C\nHousing Family", 4)),
  machine = c("Lathe", "Mill", "Drill", "Grind",
              "Mill", "Drill", "Gear Cut", "Inspect",
              "Mill", "Drill", "Bore", "Inspect"),
  x = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4),
  y = c(3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1),
  cell_color = c(rep("#E74C3C", 4), rep("#3498DB", 4), rep("#2ECC71", 4))
)

ggplot(cell_data, aes(x = x, y = y)) +
  # Cell backgrounds
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 2.6, ymax = 3.4,
           fill = "#E74C3C", alpha = 0.2) +
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 1.6, ymax = 2.4,
           fill = "#3498DB", alpha = 0.2) +
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 0.6, ymax = 1.4,
           fill = "#2ECC71", alpha = 0.2) +
  # Machines
  geom_tile(aes(fill = cell_color), width = 0.6, height = 0.4, color = "black") +
  geom_text(aes(label = machine), size = 3, fontface = "bold") +
  # Flow arrows within cells
  geom_segment(data = cell_data[c(1:3, 5:7, 9:11),],
               aes(x = x + 0.35, xend = x + 0.65, y = y, yend = y),
               arrow = arrow(length = unit(0.15, "cm")), color = "black") +
  # Cell labels
  annotate("text", x = 0, y = 3, label = "Cell A\nShafts", hjust = 1, fontface = "bold", color = "#E74C3C") +
  annotate("text", x = 0, y = 2, label = "Cell B\nGears", hjust = 1, fontface = "bold", color = "#3498DB") +
  annotate("text", x = 0, y = 1, label = "Cell C\nHousings", hjust = 1, fontface = "bold", color = "#2ECC71") +
  scale_fill_identity() +
  labs(title = "Cellular Layout: Group Technology",
       subtitle = "Parts grouped into families, each processed in dedicated cells") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-0.5, 5)
```

<details>
<summary>Discussion Question: Benefits of Cellular Manufacturing</summary>

**What are the main benefits of cellular manufacturing over traditional process layouts?**

1. **Reduced material handling** - Parts stay within the cell
2. **Shorter lead times** - No waiting between departments
3. **Less WIP inventory** - Smaller batches, faster flow
4. **Improved quality** - Workers responsible for complete part
5. **Team accountability** - Cell teams own their output

</details>

------------------------------------------------------------------------

## Fixed-Position Layout

In a **fixed-position layout**, the product remains stationary while workers, equipment, and materials are brought to it. This is used when the product is too large or heavy to move.

### Examples of Fixed-Position Layouts

- **Shipbuilding** - Ships built in dry docks
- **Aircraft manufacturing** - Large aircraft assembled in hangars
- **Construction** - Buildings, bridges, dams
- **Surgery** - Patient remains stationary

<details>
<summary>Challenge Question: Managing a Fixed-Position Layout</summary>

**What are the unique challenges of managing a fixed-position layout?**

Think about:
- Scheduling deliveries of materials and equipment
- Coordinating multiple contractors/teams
- Limited space around the product
- Weather and environmental factors (outdoor projects)
- Ensuring safety with many workers in one area

</details>

------------------------------------------------------------------------

## Designing Process Layouts

Designing an effective process layout involves **three main steps**:

### Step 1: Gather Information

You need to determine:
- **Space requirements** for each department
- **Available space** in the facility
- **Closeness relationships** between departments

#### From-To Matrix (Load Matrix)

A From-To matrix shows the number of trips or loads between departments:

```{r from-to-matrix, echo=FALSE}
# Create a From-To matrix example
from_to <- matrix(c(
  "-", 100, 50, 0, 0,
  0, "-", 200, 50, 0,
  0, 0, "-", 100, 60,
  0, 0, 0, "-", 150,
  0, 0, 0, 0, "-"
), nrow = 5, byrow = TRUE)

colnames(from_to) <- c("Receiving", "Machining", "Assembly", "Painting", "Shipping")
rownames(from_to) <- c("Receiving", "Machining", "Assembly", "Painting", "Shipping")

from_to %>%
  kable(format = "html", caption = "From-To Matrix: Loads per Day Between Departments") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D6EAF8")
```

### Step 2: Develop Block Plans

Use the **Load-Distance Model** to evaluate layout alternatives:

$$\text{Total Cost} = \sum_{i=1}^{n} \sum_{j=1}^{n} L_{ij} \times D_{ij} \times C$$

Where:
- $L_{ij}$ = Number of loads between departments $i$ and $j$
- $D_{ij}$ = Distance between departments $i$ and $j$
- $C$ = Cost per unit distance

### Interactive Example: Comparing Two Layouts

```{r layout-comparison, echo=FALSE, fig.align="center", fig.width=10, fig.height=5, fig.cap="Comparing Two Process Layout Alternatives"}
# Layout A
layout_A <- data.frame(
  dept = c("Receiving", "Machining", "Assembly", "Painting", "Shipping"),
  x = c(1, 2, 3, 4, 5),
  y = rep(1, 5)
)

# Layout B (different arrangement)
layout_B <- data.frame(
  dept = c("Receiving", "Machining", "Assembly", "Painting", "Shipping"),
  x = c(1, 2, 2, 3, 3),
  y = c(1.5, 2, 1, 2, 1)
)

p1 <- ggplot(layout_A, aes(x = x, y = y)) +
  geom_tile(fill = "#3498DB", width = 0.8, height = 0.4, color = "black") +
  geom_text(aes(label = dept), color = "white", size = 3, fontface = "bold") +
  labs(title = "Layout A: Linear") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  xlim(0.5, 5.5) + ylim(0.5, 1.5)

p2 <- ggplot(layout_B, aes(x = x, y = y)) +
  geom_tile(fill = "#E74C3C", width = 0.8, height = 0.4, color = "black") +
  geom_text(aes(label = dept), color = "white", size = 3, fontface = "bold") +
  labs(title = "Layout B: Compact") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  xlim(0.5, 3.5) + ylim(0.5, 2.5)

gridExtra::grid.arrange(p1, p2, ncol = 2)
```

```{r load-distance-calc, echo=TRUE}
# Calculate Load-Distance scores for both layouts
# From-To data: Receiving->Machining=100, Machining->Assembly=200,
#               Assembly->Painting=100, Painting->Shipping=150

# Layout A distances (linear): all adjacent = 1 unit
layout_A_score <- 100*1 + 200*1 + 100*1 + 150*1
cat("Layout A Total Load-Distance:", layout_A_score, "\n")

# Layout B distances (compact): most departments closer together
# Receiving to Machining = 1.12 (diagonal)
# Machining to Assembly = 1
# Assembly to Painting = 1.12 (diagonal)
# Painting to Shipping = 1
layout_B_score <- 100*1.12 + 200*1 + 100*1.12 + 150*1
cat("Layout B Total Load-Distance:", round(layout_B_score, 1), "\n")

cat("\nLayout A is better by:", round(layout_B_score - layout_A_score, 1), "units")
```

<details>
<summary>Why does the linear layout win in this case?</summary>

In this example, the linear layout (A) wins because the process flow is essentially sequential (Receiving → Machining → Assembly → Painting → Shipping).

When flow is **sequential**, a **product layout** (linear arrangement) is more efficient. Process layouts are better when there's **varied routing** between departments.

</details>

### Step 3: Develop Detailed Layout

Once the block plan is selected:
- Determine exact sizes and shapes of departments
- Plan aisle locations and widths
- Consider utilities, safety exits, and accessibility
- Use CAD software or 3D modeling for visualization

------------------------------------------------------------------------

## Designing Product Layouts (Line Balancing)

The key challenge in product layout design is **line balancing** - assigning tasks to workstations to minimize idle time while meeting production requirements.

### Line Balancing Steps

1. **Identify tasks and precedence relationships**
2. **Calculate required cycle time**
3. **Calculate theoretical minimum number of stations**
4. **Assign tasks to stations**
5. **Calculate efficiency**

### Key Formulas

**Cycle Time:**
$$C = \frac{\text{Available Production Time}}{\text{Desired Output}}$$

**Theoretical Minimum Stations:**
$$TM = \frac{\sum t_i}{C}$$

**Line Efficiency:**
$$\text{Efficiency} = \frac{\sum t_i}{n \times C} \times 100\%$$

Where:
- $C$ = Cycle time
- $\sum t_i$ = Total task time
- $n$ = Number of workstations

### Interactive Example: Pizza Assembly Line

```{r pizza-example, echo=FALSE, message=FALSE, warning=FALSE}
# Pizza assembly tasks
pizza_tasks <- tibble(
  Task = c("A", "B", "C", "D", "E", "F"),
  Description = c("Roll dough", "Spread sauce", "Add cheese", "Add toppings", "Season", "Box pizza"),
  `Time (sec)` = c(40, 25, 20, 35, 15, 30),
  Predecessors = c("-", "A", "B", "B", "C, D", "E")
)

pizza_tasks %>%
  kable(format = "html", caption = "Pizza Assembly Tasks") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#FEF9E7", width = "5em")
```

```{r pizza-precedence, echo=FALSE, fig.align="center", fig.cap="Precedence Diagram for Pizza Assembly", fig.width=9, fig.height=4}
# Create precedence diagram
nodes <- data.frame(
  task = c("A", "B", "C", "D", "E", "F"),
  x = c(1, 2, 3, 3, 4, 5),
  y = c(1.5, 1.5, 2, 1, 1.5, 1.5),
  time = c(40, 25, 20, 35, 15, 30)
)

edges <- data.frame(
  x = c(1, 2, 2, 3, 3, 4),
  y = c(1.5, 1.5, 1.5, 2, 1, 1.5),
  xend = c(2, 3, 3, 4, 4, 5),
  yend = c(1.5, 2, 1, 1.5, 1.5, 1.5)
)

ggplot() +
  geom_segment(data = edges, aes(x = x + 0.15, y = y, xend = xend - 0.15, yend = yend),
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  geom_point(data = nodes, aes(x = x, y = y), size = 18, color = "#3498DB") +
  geom_text(data = nodes, aes(x = x, y = y, label = paste0(task, "\n", time, "s")),
            color = "white", fontface = "bold", size = 3.5) +
  theme_void() +
  labs(title = "Precedence Diagram: Pizza Assembly",
       subtitle = "Arrows show required sequence of operations") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(0.5, 5.5) + ylim(0.5, 2.5)
```

### Line Balancing Calculation

```{r line-balance-calc, echo=TRUE}
# Given data
total_task_time <- 40 + 25 + 20 + 35 + 15 + 30  # seconds
desired_output <- 60  # pizzas per hour
available_time <- 3600  # seconds per hour

# Step 1: Calculate Cycle Time
cycle_time <- available_time / desired_output
cat("Cycle Time:", cycle_time, "seconds per pizza\n")

# Step 2: Calculate Theoretical Minimum Stations
TM <- total_task_time / cycle_time
cat("Theoretical Minimum Stations:", TM, "=", ceiling(TM), "stations\n")

# Step 3: Assign tasks to stations (one possible solution)
cat("\n--- Workstation Assignments ---\n")
cat("Station 1: A (40s) + B (25s) = 65s > 60s ... EXCEEDS!\n")
cat("Let's try again:\n")
cat("Station 1: A (40s) = 40s [Idle: 20s]\n")
cat("Station 2: B (25s) + D (35s) = 60s [Idle: 0s]\n")
cat("Station 3: C (20s) + E (15s) + F (30s) = 65s > 60s... EXCEEDS!\n")
cat("Revised:\n")
cat("Station 3: C (20s) + E (15s) = 35s [Idle: 25s]\n")
cat("Station 4: F (30s) = 30s [Idle: 30s]\n")

# With 4 stations
n_stations <- 4
efficiency <- (total_task_time / (n_stations * cycle_time)) * 100
cat("\n--- Results ---\n")
cat("Number of Stations:", n_stations, "\n")
cat("Line Efficiency:", round(efficiency, 1), "%\n")
cat("Balance Delay (Idle Time):", round(100 - efficiency, 1), "%\n")
```

<details>
<summary>Try It Yourself: Can you find a better balance?</summary>

**Challenge:** Can you assign tasks to only 3 stations while respecting the precedence constraints?

**Hint:** Consider these assignments:
- Station 1: A (40s) + ?
- Station 2: B (25s) + ? + ?
- Station 3: ? + ?

Remember: Total time per station cannot exceed 60 seconds!

**Solution:** It's actually possible with careful planning:
- Station 1: A (40s) = 40s
- Station 2: B (25s) + C (20s) + E (15s) = 60s (but E needs C AND D complete!)

So 3 stations is NOT feasible due to precedence constraints. The minimum is 4 stations for this problem.

</details>

------------------------------------------------------------------------

## Warehouse Layout Design

Warehouse layouts are a special case of process layouts focused on **minimizing material handling**.

### Key Principles

1. **Place high-volume items near the dock**
2. **Group items that are often picked together**
3. **Use ABC analysis** for storage assignment:
   - **A items** (20% of SKUs, 80% of picks): Prime locations
   - **B items** (30% of SKUs, 15% of picks): Secondary locations
   - **C items** (50% of SKUs, 5% of picks): Remote locations

```{r warehouse-viz, echo=FALSE, fig.align="center", fig.cap="Warehouse Layout: ABC Storage Strategy", fig.width=9, fig.height=5}
warehouse <- data.frame(
  zone = c(rep("A Items", 4), rep("B Items", 6), rep("C Items", 10)),
  x = c(1:4, 1:6, 1:10),
  y = c(rep(1, 4), rep(2, 6), rep(3, 10)),
  fill = c(rep("#E74C3C", 4), rep("#F39C12", 6), rep("#3498DB", 10))
)

ggplot(warehouse, aes(x = x, y = y)) +
  geom_tile(aes(fill = fill), width = 0.9, height = 0.8, color = "black") +
  scale_fill_identity() +
  annotate("rect", xmin = 0, xmax = 11, ymin = -0.2, ymax = 0.3, fill = "#95A5A6") +
  annotate("text", x = 5.5, y = 0.05, label = "SHIPPING/RECEIVING DOCK", fontface = "bold") +
  annotate("text", x = 2.5, y = 1, label = "A Items\n(Fast Moving)", color = "white", fontface = "bold") +
  annotate("text", x = 3.5, y = 2, label = "B Items (Medium)", color = "white", fontface = "bold") +
  annotate("text", x = 5.5, y = 3, label = "C Items (Slow Moving)", color = "white", fontface = "bold") +
  labs(title = "Warehouse Layout: ABC Storage Strategy",
       subtitle = "High-frequency items placed closest to the dock") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  coord_fixed(ratio = 0.8)
```

------------------------------------------------------------------------

## Office Layout Design

Office layouts balance **communication needs** with **privacy requirements**.

### Two Main Approaches

```{r office-comparison, echo=FALSE}
office_types <- tibble(
  Aspect = c("Space", "Walls", "Flexibility", "Communication", "Privacy", "Cost"),
  `Open Plan` = c("Shared workspaces", "Partitions/dividers", "High - easy to reconfigure",
                  "Excellent", "Low", "Lower"),
  `Traditional/Closed` = c("Private offices", "Permanent walls", "Low - expensive to change",
                           "Limited", "High", "Higher")
)

office_types %>%
  kable(format = "html", caption = "Office Layout Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#D6EAF8")
```

### Office Ergonomics Checklist

<details>
<summary>Click to expand: Office Ergonomics Best Practices</summary>

**Posture:**
- Support the small of the back
- Keep shoulders relaxed
- Maintain neutral wrist position
- Feet flat on floor or footrest

**Lighting:**
- Position monitor to reduce glare
- Adjust brightness for screen vs. paper work
- Use task lighting when needed

**Workstation:**
- Monitor at arm's length
- Top of screen at or below eye level
- Keyboard and mouse at elbow height

**Work Habits:**
- Take breaks every 30-60 minutes
- Vary tasks to prevent repetitive strain
- Use keyboard shortcuts to reduce mouse use

</details>

### The Future of Office Design

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/0X_tKMhxNXA"
    title="Office of Today, Workplace of Tomorrow"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## Summary: Choosing the Right Layout

```{r decision-flowchart, echo=FALSE, fig.align="center", fig.cap="Layout Selection Decision Guide", fig.width=10, fig.height=6}
# Simple decision tree visualization
decisions <- data.frame(
  label = c("Start:\nWhat are you\nproducing?",
            "Can the\nproduct move?",
            "FIXED-POSITION\nLAYOUT",
            "High variety\nor high volume?",
            "PROCESS\nLAYOUT",
            "PRODUCT\nLAYOUT",
            "Consider\nHYBRID/CELLULAR"),
  x = c(1, 2.5, 2.5, 4, 4, 5.5, 4),
  y = c(2, 2, 0.8, 2, 0.8, 2, 3.2),
  fill = c("#95A5A6", "#F39C12", "#E74C3C", "#F39C12", "#3498DB", "#2ECC71", "#9B59B6")
)

ggplot(decisions, aes(x = x, y = y)) +
  geom_tile(aes(fill = fill), width = 1.3, height = 0.7, color = "black") +
  geom_text(aes(label = label), size = 2.8, fontface = "bold") +
  # Arrows
  annotate("segment", x = 1.65, xend = 1.85, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 2.5, y = 1.65, yend = 1.15,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = 2.7, y = 1.4, label = "No", size = 3) +
  annotate("segment", x = 3.15, xend = 3.35, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = 3.25, y = 2.15, label = "Yes", size = 3) +
  annotate("segment", x = 4, xend = 4, y = 1.65, yend = 1.15,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = 4.2, y = 1.4, label = "Variety", size = 3) +
  annotate("segment", x = 4.65, xend = 4.85, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = 4.75, y = 2.15, label = "Volume", size = 3) +
  annotate("segment", x = 4, xend = 4, y = 2.35, yend = 2.85,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = 4.2, y = 2.6, label = "Medium", size = 3) +
  scale_fill_identity() +
  theme_void() +
  labs(title = "Layout Selection Decision Guide") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
```

### Key Takeaways

1. **Process layouts** offer flexibility for varied products but have higher material handling costs
2. **Product layouts** are efficient for high-volume, standardized products
3. **Cellular layouts** provide a middle ground with benefits of both
4. **Fixed-position layouts** are necessary when products cannot be moved
5. **Line balancing** is critical for efficient product layouts
6. **Warehouse layouts** should minimize travel distance for high-frequency items

------------------------------------------------------------------------

## Industry Case Studies

### Case Study 1: Food Processing Plant Layout

Food processing facilities have unique layout requirements due to food safety, hygiene, and regulatory compliance.

```{r food-processing-layout, echo=FALSE, fig.align="center", fig.cap="Food Processing Plant Layout Example", fig.width=10, fig.height=6}
# Create a food processing plant layout
food_zones <- data.frame(
  zone = c("Receiving\n(Raw Materials)", "Cold Storage", "Preparation",
           "Processing\n(Cooking)", "Packaging", "Finished Goods\nStorage", "Shipping"),
  x = c(1, 1, 2, 3, 4, 5, 5),
  y = c(2.5, 1.5, 2, 2, 2, 2.5, 1.5),
  fill = c("#95A5A6", "#3498DB", "#F39C12", "#E74C3C", "#9B59B6", "#2ECC71", "#95A5A6"),
  width = c(1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2),
  height = c(0.6, 0.6, 0.8, 0.8, 0.8, 0.6, 0.6)
)

# Flow arrows
flow_data <- data.frame(
  x = c(1, 1, 2, 3, 4, 5),
  y = c(2.5, 1.5, 2, 2, 2, 2.5),
  xend = c(2, 2, 3, 4, 5, 5),
  yend = c(2, 2, 2, 2, 2.5, 1.5)
)

ggplot() +
  # Zone backgrounds - clean and dirty separation
  annotate("rect", xmin = 0.3, xmax = 2.7, ymin = 1, ymax = 3,
           fill = "#FADBD8", alpha = 0.3) +
  annotate("rect", xmin = 2.7, xmax = 5.7, ymin = 1, ymax = 3,
           fill = "#D5F5E3", alpha = 0.3) +
  annotate("text", x = 1.5, y = 3.2, label = "Raw Material Zone", fontface = "bold", color = "#E74C3C") +
  annotate("text", x = 4.2, y = 3.2, label = "Clean Processing Zone", fontface = "bold", color = "#2ECC71") +
  # Zones
  geom_tile(data = food_zones, aes(x = x, y = y, fill = fill, width = width, height = height),
            color = "black") +
  geom_text(data = food_zones, aes(x = x, y = y, label = zone), size = 3, fontface = "bold") +
  # Flow
  geom_curve(data = flow_data, aes(x = x + 0.6, y = y, xend = xend - 0.6, yend = yend),
             arrow = arrow(length = unit(0.15, "cm")), curvature = 0.1, color = "#2C3E50") +
  scale_fill_identity() +
  labs(title = "Food Processing Plant Layout",
       subtitle = "One-way flow from raw materials to finished goods prevents cross-contamination") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

**Key Design Principles for Food Processing:**

```{r food-design-principles, echo=FALSE}
food_principles <- tibble(
  Principle = c("Linear Flow", "Zone Separation", "Cleanability", "Temperature Control",
                "Sanitary Design", "Allergen Control"),
  Description = c(
    "Raw materials → Processing → Packaging (no backtracking)",
    "Physical barriers between raw and ready-to-eat areas",
    "Smooth, non-porous surfaces; rounded corners; proper drainage",
    "Maintain cold chain; separate refrigerated zones",
    "Handwashing stations, foot baths, air curtains at zone transitions",
    "Dedicated lines or thorough cleaning between allergen products"
  ),
  `Regulatory Reference` = c("FSMA", "HACCP", "3-A Standards", "FDA 21 CFR 110", "USDA FSIS", "FALCPA")
)

food_principles %>%
  kable(format = "html", caption = "Food Processing Layout Design Principles") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "10em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

<details>
<summary>Discussion Question: Cross-Contamination Prevention</summary>

**Question:** A food processing plant produces both peanut butter products and tree nut-free products. What layout considerations are essential?

**Key Considerations:**

1. **Physical Separation:** Completely separate production lines with physical barriers (walls, not just distance)
2. **Air Handling:** Separate HVAC systems to prevent airborne allergen transfer
3. **Personnel Flow:** Dedicated workers for each line, or strict gowning/cleaning procedures when crossing zones
4. **Scheduling:** If shared equipment is unavoidable, schedule allergen products last before deep cleaning
5. **Traffic Patterns:** Forklift and cart paths should not cross between allergen zones
6. **Verification:** Air sampling and surface swabs to verify effectiveness

</details>

### Case Study 2: Aerospace Manufacturing Facility

Aerospace facilities often use **fixed-position layouts** combined with **process layouts** for component fabrication.

```{r aerospace-layout, echo=FALSE, fig.align="center", fig.cap="Aerospace Assembly Facility Layout", fig.width=10, fig.height=6}
# Aerospace facility layout
aero_areas <- data.frame(
  area = c("Component\nFabrication", "Subassembly", "Wing\nAssembly", "Fuselage\nAssembly",
           "Final\nAssembly", "Systems\nIntegration", "Testing", "Paint &\nFinishing"),
  x = c(1, 2, 3.5, 3.5, 5, 6, 7, 8),
  y = c(2, 2, 2.7, 1.3, 2, 2, 2, 2),
  fill = c("#3498DB", "#9B59B6", "#F39C12", "#F39C12", "#E74C3C", "#2ECC71", "#1ABC9C", "#95A5A6")
)

ggplot(aero_areas, aes(x = x, y = y)) +
  geom_tile(aes(fill = fill), width = 0.9, height = 0.7, color = "black") +
  geom_text(aes(label = area), size = 3, fontface = "bold") +
  # Main flow arrows
  annotate("segment", x = 1.5, xend = 1.6, y = 2, yend = 2,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 2.5, xend = 3, y = 2.2, yend = 2.7,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 2.5, xend = 3, y = 1.8, yend = 1.3,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 4, xend = 4.5, y = 2.7, yend = 2.2,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 4, xend = 4.5, y = 1.3, yend = 1.8,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 5.5, xend = 5.6, y = 2, yend = 2,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 6.5, xend = 6.6, y = 2, yend = 2,
           arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("segment", x = 7.5, xend = 7.6, y = 2, yend = 2,
           arrow = arrow(length = unit(0.15, "cm"))) +
  # Aircraft silhouette at final assembly
  annotate("point", x = 5, y = 2, size = 3, shape = 17, color = "#2C3E50") +
  scale_fill_identity() +
  labs(title = "Aerospace Manufacturing Facility Layout",
       subtitle = "Hybrid layout: Process (fabrication) → Fixed-Position (final assembly)") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(0.3, 8.7) + ylim(0.5, 3.5)
```

**Aerospace Layout Characteristics:**

- **Clean rooms** for precision components (hydraulics, avionics)
- **High-bay areas** for large assembly operations
- **Overhead cranes** for moving heavy components
- **Flow-line final assembly** (aircraft moves through stations) for high-volume commercial aircraft
- **Fixed-position** for military aircraft or low-volume production
- **Strict FOD (Foreign Object Debris)** control throughout

<details>
<summary>Video: Boeing 737 Assembly</summary>

Watch how Boeing uses a moving assembly line for high-volume aircraft production:

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/u7nFmYLdgJI"
    title="Boeing 737 Assembly"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

</details>

### Case Study 3: Automotive Supplier - Hybrid Cell Layout

```{r auto-supplier-layout, echo=FALSE, fig.align="center", fig.cap="Automotive Supplier Facility with Cellular Layout", fig.width=10, fig.height=6}
# Automotive supplier with cells
cells <- data.frame(
  cell = c(rep("Machining Cell 1\n(Brackets)", 3),
           rep("Machining Cell 2\n(Housings)", 3),
           rep("Assembly Cell", 4),
           "Shipping"),
  machine = c("CNC Lathe", "CNC Mill", "Deburr",
              "VMC", "HMC", "CMM",
              "Press Fit", "Weld", "Test", "Pack",
              "Dock"),
  x = c(1, 2, 3, 1, 2, 3, 5, 6, 7, 8, 9),
  y = c(3, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2),
  fill = c(rep("#E74C3C", 3), rep("#3498DB", 3), rep("#2ECC71", 4), "#95A5A6")
)

ggplot(cells, aes(x = x, y = y)) +
  # Cell backgrounds
  annotate("rect", xmin = 0.4, xmax = 3.6, ymin = 2.5, ymax = 3.5,
           fill = "#E74C3C", alpha = 0.2) +
  annotate("rect", xmin = 0.4, xmax = 3.6, ymin = 0.5, ymax = 1.5,
           fill = "#3498DB", alpha = 0.2) +
  annotate("rect", xmin = 4.4, xmax = 8.6, ymin = 1.5, ymax = 2.5,
           fill = "#2ECC71", alpha = 0.2) +
  # Machines
  geom_tile(aes(fill = fill), width = 0.7, height = 0.6, color = "black") +
  geom_text(aes(label = machine), size = 2.5, fontface = "bold") +
  # Flow arrows
  geom_segment(data = data.frame(x = c(1.4, 2.4), y = c(3, 3), xend = c(1.6, 2.6), yend = c(3, 3)),
               aes(x = x, y = y, xend = xend, yend = yend),
               arrow = arrow(length = unit(0.1, "cm"))) +
  geom_segment(data = data.frame(x = c(1.4, 2.4), y = c(1, 1), xend = c(1.6, 2.6), yend = c(1, 1)),
               aes(x = x, y = y, xend = xend, yend = yend),
               arrow = arrow(length = unit(0.1, "cm"))) +
  annotate("curve", x = 3, y = 2.6, xend = 4.6, yend = 2.2,
           arrow = arrow(length = unit(0.15, "cm")), curvature = -0.2) +
  annotate("curve", x = 3, y = 1.4, xend = 4.6, yend = 1.8,
           arrow = arrow(length = unit(0.15, "cm")), curvature = 0.2) +
  geom_segment(data = data.frame(x = c(5.4, 6.4, 7.4, 8.4), y = rep(2, 4),
                                  xend = c(5.6, 6.6, 7.6, 8.6), yend = rep(2, 4)),
               aes(x = x, y = y, xend = xend, yend = yend),
               arrow = arrow(length = unit(0.1, "cm"))) +
  # Labels
  annotate("text", x = 2, y = 3.7, label = "Machining Cell 1: Brackets", fontface = "bold", color = "#E74C3C") +
  annotate("text", x = 2, y = 0.3, label = "Machining Cell 2: Housings", fontface = "bold", color = "#3498DB") +
  annotate("text", x = 6.5, y = 2.7, label = "Assembly Cell", fontface = "bold", color = "#2ECC71") +
  scale_fill_identity() +
  labs(title = "Automotive Supplier Facility Layout",
       subtitle = "Cellular manufacturing feeding a common assembly line") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

**JIT Delivery Requirements:**

Automotive suppliers must often deliver directly to the assembly line in **sequence** (JIS - Just-In-Sequence):

```{r jit-table, echo=FALSE}
jit_reqs <- tibble(
  Requirement = c("Delivery Window", "Sequence Accuracy", "Quality Level", "Packaging", "Traceability"),
  `Typical Standard` = c("±30 minutes of scheduled time", "100% (0 sequence errors)",
                         "0 PPM target (Six Sigma)", "Returnable containers to line side",
                         "Full lot/serial traceability required"),
  `Layout Impact` = c("Dedicated shipping lane, staging area near dock",
                      "Pick-to-light systems, visual management",
                      "Inline inspection, mistake-proofing (poka-yoke)",
                      "Container cleaning/storage area needed",
                      "Barcode/RFID scanning stations throughout")
)

jit_reqs %>%
  kable(format = "html", caption = "JIT/JIS Requirements and Layout Implications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "10em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

------------------------------------------------------------------------

## Ergonomics in Manufacturing

Ergonomics (human factors engineering) is critical for plant layout design to ensure worker safety, reduce injuries, and improve productivity.

### The NIOSH Lifting Equation

The National Institute for Occupational Safety and Health (NIOSH) developed an equation to evaluate manual lifting tasks:

$$RWL = LC \times HM \times VM \times DM \times AM \times FM \times CM$$

Where **RWL** = Recommended Weight Limit (in pounds or kg)

```{r niosh-factors-plant, echo=FALSE}
niosh_factors <- tibble(
  Factor = c("LC", "HM", "VM", "DM", "AM", "FM", "CM"),
  Name = c("Load Constant", "Horizontal Multiplier", "Vertical Multiplier",
           "Distance Multiplier", "Asymmetric Multiplier", "Frequency Multiplier", "Coupling Multiplier"),
  Formula = c("51 lb (23 kg)", "10/H", "1 - 0.0075|V - 30|", "0.82 + 1.8/D",
              "1 - 0.0032A", "Table lookup", "Table lookup"),
  Description = c("Maximum weight under ideal conditions",
                  "H = horizontal distance from spine to load (inches)",
                  "V = vertical height of hands at start (inches)",
                  "D = vertical travel distance (inches)",
                  "A = angle of asymmetry (degrees)",
                  "Based on lift frequency and duration",
                  "Based on grip quality (good/fair/poor)")
)

niosh_factors %>%
  kable(format = "html", caption = "NIOSH Lifting Equation Factors") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "5em", background = "#FEF9E7") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

### Lifting Index Calculation

$$LI = \frac{\text{Actual Weight}}{\text{RWL}}$$

```{r li-interpretation-plant, echo=FALSE}
li_table <- tibble(
  `Lifting Index` = c("LI ≤ 1.0", "1.0 < LI ≤ 3.0", "LI > 3.0"),
  `Risk Level` = c("Low", "Moderate", "High"),
  `Action Required` = c("Task is acceptable for most workers",
                        "Task poses risk; engineering controls recommended",
                        "Task is unacceptable; immediate redesign required"),
  Color = c("#2ECC71", "#F39C12", "#E74C3C")
)

li_table %>%
  select(-Color) %>%
  kable(format = "html", caption = "Lifting Index Interpretation") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "center") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#FCF3CF") %>%
  row_spec(3, background = "#FADBD8") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

### NIOSH Lifting Example

```{r niosh-example-plant, echo=TRUE}
# Example: Worker lifts 35 lb boxes from pallet to conveyor
# Conditions:
# - Horizontal distance (H) = 15 inches
# - Vertical height at start (V) = 10 inches
# - Vertical travel distance (D) = 20 inches
# - Asymmetry angle (A) = 30 degrees
# - Frequency = 4 lifts per minute, 2 hours
# - Coupling = Fair (handles present)

LC <- 51  # Load constant (lb)

# Calculate multipliers
HM <- 10 / 15  # Horizontal multiplier
VM <- 1 - 0.0075 * abs(10 - 30)  # Vertical multiplier
DM <- 0.82 + (1.8 / 20)  # Distance multiplier
AM <- 1 - 0.0032 * 30  # Asymmetric multiplier
FM <- 0.72  # From NIOSH table: 4 lifts/min, 1-2 hours
CM <- 0.95  # Fair coupling

cat("Multiplier Values:\n")
cat("  HM (Horizontal):", round(HM, 3), "\n")
cat("  VM (Vertical):", round(VM, 3), "\n")
cat("  DM (Distance):", round(DM, 3), "\n")
cat("  AM (Asymmetry):", round(AM, 3), "\n")
cat("  FM (Frequency):", FM, "\n")
cat("  CM (Coupling):", CM, "\n")

# Calculate RWL
RWL <- LC * HM * VM * DM * AM * FM * CM
cat("\nRecommended Weight Limit (RWL):", round(RWL, 1), "lb\n")

# Calculate Lifting Index
actual_weight <- 35
LI <- actual_weight / RWL
cat("Lifting Index (LI):", round(LI, 2), "\n")

if (LI <= 1.0) {
  cat("\nRisk Level: LOW - Task is acceptable\n")
} else if (LI <= 3.0) {
  cat("\nRisk Level: MODERATE - Consider engineering controls\n")
} else {
  cat("\nRisk Level: HIGH - Immediate redesign required\n")
}
```

<details>
<summary>Discussion Question: Reducing the Lifting Index</summary>

**Based on the example above, what layout or workstation changes could reduce the Lifting Index?**

**Solutions (in order of effectiveness):**

1. **Reduce horizontal distance (H):** Move conveyor closer to pallet position
   - If H = 10": HM improves from 0.67 to 1.0 → RWL increases by 50%

2. **Raise the starting height (V):** Use elevated pallet positions or pallet lifters
   - If V = 30" (optimal): VM improves from 0.85 to 1.0 → RWL increases by 18%

3. **Eliminate asymmetry (A):** Reposition conveyor directly in front of pallet
   - If A = 0°: AM improves from 0.90 to 1.0 → RWL increases by 11%

4. **Reduce frequency:** Add a second worker or use automation
   - If 1 lift/min: FM improves from 0.72 to 0.94 → RWL increases by 31%

5. **Improve coupling:** Use boxes with good handles
   - If good coupling: CM improves from 0.95 to 1.0 → RWL increases by 5%

**Best solution:** Implement a scissor lift for the pallet (adjustable height) and move the conveyor closer. This addresses the largest multiplier reductions.

</details>

### Ergonomic Workstation Design

```{r ergonomic-zones, echo=FALSE, fig.align="center", fig.cap="Ergonomic Work Zones for Standing Operations", fig.width=8, fig.height=6}
# Work zone diagram
zones <- data.frame(
  zone = c("Primary\nWork Zone", "Secondary\nWork Zone", "Tertiary\n(Occasional)"),
  x = c(0, 0, 0),
  y = c(0, 0, 0),
  radius = c(0.8, 1.3, 1.8),
  fill = c("#2ECC71", "#F39C12", "#E74C3C"),
  alpha = c(0.6, 0.4, 0.2)
)

ggplot() +
  # Zones (draw largest first)
  annotate("rect", xmin = -1.8, xmax = 1.8, ymin = -0.3, ymax = 1.8,
           fill = "#E74C3C", alpha = 0.2) +
  annotate("rect", xmin = -1.3, xmax = 1.3, ymin = -0.3, ymax = 1.3,
           fill = "#F39C12", alpha = 0.3) +
  annotate("rect", xmin = -0.8, xmax = 0.8, ymin = -0.3, ymax = 0.8,
           fill = "#2ECC71", alpha = 0.4) +
  # Worker position
  annotate("point", x = 0, y = -0.5, size = 15, color = "#3498DB") +
  annotate("text", x = 0, y = -0.5, label = "Worker", fontface = "bold", color = "white") +
  # Zone labels
  annotate("text", x = 0, y = 0.4, label = "Primary Zone\n(Frequent tasks)", fontface = "bold", size = 3.5) +
  annotate("text", x = 0, y = 1.0, label = "Secondary Zone\n(Regular tasks)", size = 3) +
  annotate("text", x = 0, y = 1.55, label = "Tertiary Zone\n(Occasional)", size = 3, color = "#7F8C8D") +
  # Dimensions
  annotate("segment", x = -0.8, xend = 0.8, y = -0.1, yend = -0.1,
           arrow = arrow(ends = "both", length = unit(0.1, "cm"))) +
  annotate("text", x = 0, y = -0.2, label = "~16 in", size = 2.5) +
  labs(title = "Ergonomic Work Zones",
       subtitle = "Arrange tools and materials based on frequency of use") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  coord_fixed()
```

**Layout Implications:**

- **Primary zone:** Most frequently used tools and parts
- **Secondary zone:** Regularly used items, occasional reaches
- **Tertiary zone:** Rarely needed items, should trigger redesign if frequent use required

------------------------------------------------------------------------

## Modern Layout Trends and Industry 4.0

### Flexible Manufacturing Layouts

Modern facilities must adapt quickly to changing product demands. Key trends include:

```{r flexible-layout-trends, echo=FALSE}
trends <- tibble(
  Trend = c("Modular Workstations", "Reconfigurable Cells", "Mobile Equipment",
            "Flexible Utilities", "Digital Layout Planning"),
  Description = c(
    "Pre-built workstation modules that can be relocated in hours",
    "Cells with standardized machine interfaces for quick changeover",
    "Equipment on wheels or air bearings for rapid repositioning",
    "Overhead utility drops and floor trenches allow equipment mobility",
    "Digital twins enable virtual layout testing before physical changes"
  ),
  Benefits = c(
    "Rapid response to volume changes, easy expansion",
    "Switch between product families without major capital",
    "Eliminate fixed foundations, reduce floor damage",
    "No hardwired constraints on equipment placement",
    "Reduce trial-and-error, optimize before implementation"
  )
)

trends %>%
  kable(format = "html", caption = "Modern Flexible Layout Trends") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

### Industry 4.0 Layout Considerations

```{r industry-4-layout, echo=FALSE, fig.align="center", fig.cap="Industry 4.0 Enabled Plant Layout Elements", fig.width=10, fig.height=6}
i4_elements <- data.frame(
  element = c("AGV\nRoutes", "5G/WiFi\nCoverage", "Edge\nComputing", "Digital\nTwin",
              "Cobot\nZones", "AR/VR\nStations"),
  x = c(1, 2, 3, 4, 5, 6),
  y = c(2, 2, 2, 2, 2, 2),
  icon = c("🚗", "📶", "💻", "👥", "🤖", "👓"),
  fill = c("#3498DB", "#E74C3C", "#9B59B6", "#2ECC71", "#F39C12", "#1ABC9C")
)

ggplot(i4_elements, aes(x = x, y = y)) +
  geom_tile(aes(fill = fill), width = 0.9, height = 0.8, color = "black") +
  geom_text(aes(label = element), y = 2.1, size = 3, fontface = "bold") +
  scale_fill_identity() +
  # Descriptions below
  annotate("text", x = 1, y = 1.2, label = "Floor markings,\ncharging stations,\ntraffic management", size = 2.5, lineheight = 0.9) +
  annotate("text", x = 2, y = 1.2, label = "Network infrastructure\nfor IoT sensors,\nreal-time data", size = 2.5, lineheight = 0.9) +
  annotate("text", x = 3, y = 1.2, label = "Local processing\nnear machines,\nlow latency", size = 2.5, lineheight = 0.9) +
  annotate("text", x = 4, y = 1.2, label = "Virtual replica\nof physical plant,\nlive updates", size = 2.5, lineheight = 0.9) +
  annotate("text", x = 5, y = 1.2, label = "Safety zones,\nhuman-robot\ncollaboration", size = 2.5, lineheight = 0.9) +
  annotate("text", x = 6, y = 1.2, label = "Training, maintenance\nguidance, remote\nassistance", size = 2.5, lineheight = 0.9) +
  labs(title = "Industry 4.0 Plant Layout Considerations",
       subtitle = "New infrastructure requirements for smart manufacturing") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(0.5, 3)
```

### AGV and AMR Traffic Planning

Automated Guided Vehicles (AGVs) and Autonomous Mobile Robots (AMRs) require careful layout planning:

```{r agv-considerations, echo=FALSE}
agv_planning <- tibble(
  Consideration = c("Route Design", "Charging Locations", "Traffic Intersections",
                    "Floor Requirements", "Safety Zones", "Staging Areas"),
  `Design Guidelines` = c(
    "Unidirectional loops preferred; minimize intersections; avoid steep grades",
    "Opportunity charging at pickup/dropoff points; dedicated charging bays for breaks",
    "Yield zones, traffic signals, or elevation changes at crossings",
    "Smooth, level surfaces; magnetic tape or QR codes for navigation; no oil/water",
    "Minimum 1m clearance from pedestrian paths; light curtains at crossings",
    "Buffer areas for queue management; waiting positions clear of traffic"
  )
)

agv_planning %>%
  kable(format = "html", caption = "AGV/AMR Layout Planning Guidelines") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

<details>
<summary>Video: AGV Systems in Modern Warehouses</summary>

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/quWFjS3Ci7A"
    title="AGV Systems in Modern Manufacturing"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

</details>

------------------------------------------------------------------------

## Layout Simulation Software

Modern plant layout design relies heavily on simulation software to test alternatives before physical implementation.

### Common Layout Planning Software

```{r software-comparison, echo=FALSE}
software <- tibble(
  Software = c("AutoCAD Factory Design Suite", "FlexSim", "Arena", "Plant Simulation (Siemens)", "SketchUp + Extensions"),
  `Primary Use` = c("2D/3D CAD layout design", "3D discrete event simulation", "Process simulation",
                    "Digital factory simulation", "Quick 3D visualization"),
  `Key Features` = c(
    "Extensive equipment libraries, interference checking, material flow analysis",
    "Drag-and-drop modeling, VR capability, real-time 3D animation",
    "Statistical analysis, what-if scenarios, bottleneck identification",
    "Full Siemens integration, AGV simulation, energy analysis",
    "Low cost, easy learning curve, walkthrough capability"
  ),
  `Typical Users` = c("Facility engineers, architects", "Industrial engineers, consultants",
                      "Process engineers, academics", "Large manufacturers (automotive, aerospace)",
                      "Small businesses, initial concepts")
)

software %>%
  kable(format = "html", caption = "Plant Layout Planning Software Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

### Simulation Benefits

```{r simulation-benefits, echo=FALSE, fig.align="center", fig.cap="Benefits of Layout Simulation", fig.width=8, fig.height=5}
benefits <- data.frame(
  benefit = c("Reduce\nCosts", "Minimize\nRisk", "Optimize\nFlow", "Validate\nCapacity", "Improve\nBuy-in"),
  x = 1:5,
  y = c(4, 3.5, 4.2, 3.8, 3.3),
  fill = c("#E74C3C", "#3498DB", "#2ECC71", "#F39C12", "#9B59B6")
)

ggplot(benefits, aes(x = x, y = y)) +
  geom_col(aes(fill = fill), width = 0.7, color = "black") +
  geom_text(aes(label = benefit, y = y + 0.3), fontface = "bold", size = 3.5) +
  scale_fill_identity() +
  labs(title = "Why Simulate Before Building?",
       y = "Relative Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        panel.grid.major.x = element_blank())
```

**ROI of Simulation:**

- **10-20x** return on simulation investment typical
- **30-50%** reduction in layout change costs
- **Weeks to months** saved in ramp-up time
- **Stakeholder alignment** - visual communication of concepts

<details>
<summary>Video: Plant Simulation Demo</summary>

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/b5U6VlgRPnU"
    title="Plant Simulation Software Demo"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>
```

</details>

------------------------------------------------------------------------

## Practice Problems

<details>
<summary>Problem 1: Layout Selection</summary>

**Scenario:** A company manufactures custom kitchen cabinets. Each order is unique, with different dimensions, materials, and finishes. Production volume is about 50 units per month.

**Question:** Which layout type would you recommend and why?

**Answer:** A **process layout** would be most appropriate because:
- High product variety (custom orders)
- Low production volume
- Different operations needed for each order
- Flexibility is more important than efficiency

</details>

<details>
<summary>Problem 2: Line Balancing</summary>

**Given:**
- Total task time: 240 seconds
- Desired output: 30 units per hour
- Available time: 3600 seconds per hour

**Calculate:**
1. Cycle time
2. Theoretical minimum number of stations
3. If you use 3 stations, what is the efficiency?

**Solution:**
1. Cycle time = 3600 / 30 = **120 seconds**
2. TM = 240 / 120 = **2 stations**
3. Efficiency = (240 / (3 × 120)) × 100 = **66.7%**

</details>

<details>
<summary>Problem 3: Warehouse Layout</summary>

**Scenario:** A warehouse has the following items:
- Item X: 500 picks/day
- Item Y: 100 picks/day
- Item Z: 50 picks/day

**Question:** How should these items be positioned relative to the shipping dock?

**Answer:** Using ABC analysis:
- Item X (high frequency): **Closest to dock** (A zone)
- Item Y (medium frequency): **Middle distance** (B zone)
- Item Z (low frequency): **Farthest from dock** (C zone)

</details>

------------------------------------------------------------------------

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: What distinguishes a cellular layout from both process and product layouts?</summary>

**Answer:** A cellular layout combines characteristics of both:

- **From process layout:** Equipment variety within each cell, flexibility to handle part variations
- **From product layout:** Sequential flow within the cell, dedicated equipment for part families
- **Unique characteristics:**
  - Parts grouped into families using Group Technology
  - Cells are self-contained mini-factories
  - Workers often cross-trained to operate multiple machines
  - Reduced material handling compared to process layout
  - More flexibility than pure product layout

</details>

<details>
<summary>Question 2: Calculate the Lifting Index for the following scenario</summary>

**Scenario:** A worker lifts 25 kg boxes from floor level (V=0) to a shelf at waist height. The horizontal distance is 40 cm, vertical travel is 75 cm, no asymmetry, frequency is 2 lifts per minute for 4 hours, and coupling is poor (no handles).

**Given multipliers:**
- LC = 23 kg
- HM = 25/H (H in cm)
- VM = 1 - 0.003|V - 75| (V in cm)
- DM = 0.82 + 4.5/D (D in cm)
- AM = 1.0 (no asymmetry)
- FM = 0.65 (from tables)
- CM = 0.90 (poor coupling)

**Solution:**
```
HM = 25/40 = 0.625
VM = 1 - 0.003|0 - 75| = 1 - 0.225 = 0.775
DM = 0.82 + 4.5/75 = 0.82 + 0.06 = 0.88
AM = 1.0
FM = 0.65
CM = 0.90

RWL = 23 × 0.625 × 0.775 × 0.88 × 1.0 × 0.65 × 0.90
RWL = 23 × 0.625 × 0.775 × 0.88 × 0.65 × 0.90
RWL = 5.7 kg

LI = 25/5.7 = 4.4

Risk Level: HIGH (LI > 3.0) - Immediate redesign required
```

**Recommended actions:** Raise starting height (use pallet lifter), reduce horizontal distance, add handles to boxes, reduce frequency.

</details>

<details>
<summary>Question 3: List three Industry 4.0 technologies that impact plant layout design</summary>

**Answer:** (Any three of the following)

1. **AGVs/AMRs:** Require route planning, charging stations, floor markings, safety zones
2. **Collaborative robots (cobots):** Need safety zones, but smaller footprint than traditional robot cells
3. **Digital twins:** Enable virtual layout testing, reduce physical prototyping
4. **IoT sensors:** Require network infrastructure (5G/WiFi), edge computing locations
5. **AR/VR systems:** Training stations, remote assistance capabilities
6. **Flexible automation:** Modular equipment, quick-connect utilities

</details>

<details>
<summary>Question 4: What are the key differences between food processing plant layouts and general manufacturing?</summary>

**Answer:**

| Aspect | Food Processing | General Manufacturing |
|--------|----------------|----------------------|
| Flow direction | Strictly one-way (raw → finished) | Can have backtracking |
| Zone separation | Physical barriers between raw/clean | Logical separation often sufficient |
| Surfaces | Sanitary design, smooth, cleanable | Durability focused |
| Temperature | Multiple temperature zones (cold chain) | Generally ambient |
| Regulatory | HACCP, FSMA, FDA oversight | OSHA, industry standards |
| Allergen control | Dedicated lines or validated cleaning | Not typically a concern |
| Traceability | Lot-level required by regulation | Often batch-level sufficient |

</details>

<details>
<summary>Question 5: A warehouse has three product categories with the following pick frequencies. Design the storage zones.</summary>

**Data:**
- Category A: 1200 picks/day, 500 SKUs
- Category B: 600 picks/day, 1500 SKUs
- Category C: 200 picks/day, 3000 SKUs

**Solution:**

Using ABC analysis based on pick frequency:
- **Category A** (60% of picks, 10% of SKUs): Prime locations closest to shipping dock
- **Category B** (30% of picks, 30% of SKUs): Secondary locations, moderate distance
- **Category C** (10% of picks, 60% of SKUs): Remote locations, maximum distance from dock

**Additional considerations:**
- Within each zone, use cube utilization for dense storage of slow movers
- Consider pick path optimization (serpentine vs. return routing)
- High-frequency items at ergonomic pick heights (waist level)
- Reserve space near dock for cross-docking high-velocity items

</details>

------------------------------------------------------------------------

## Chapter Summary

```{r chapter-summary, echo=FALSE}
summary_table <- tibble(
  Topic = c("Layout Types", "Process Layout Design", "Product Layout (Line Balancing)",
            "Cellular Manufacturing", "Warehouse Design", "Ergonomics",
            "Modern Trends", "Simulation"),
  `Key Concepts` = c(
    "Fixed-position, Process, Product, Hybrid/Cellular - selected based on volume and variety",
    "From-To matrix, Load-Distance model, Block plans, Closeness relationships",
    "Cycle time, Theoretical minimum stations, Precedence diagrams, Line efficiency",
    "Group Technology, Part families, Self-contained cells, Reduced material handling",
    "ABC analysis, High-frequency items near dock, Pick path optimization",
    "NIOSH lifting equation, RWL, Lifting Index, Work zones, Workstation design",
    "Flexible layouts, Industry 4.0, AGV/AMR planning, Digital twins",
    "FlexSim, Arena, Plant Simulation - virtual testing before physical changes"
  ),
  `Key Formulas` = c(
    "Layout selection: Volume × Variety matrix",
    "Cost = Σ Lij × Dij × C",
    "C = Time/Output; TM = Σti/C; Eff = Σti/(n×C)",
    "Cell efficiency = Output/(Input × Time)",
    "Travel distance = Σ(picks × distance)",
    "RWL = LC×HM×VM×DM×AM×FM×CM; LI = Weight/RWL",
    "ROI = (Savings - Investment)/Investment",
    "Simulation accuracy > 90% typical"
  )
)

summary_table %>%
  kable(format = "html", caption = "Chapter 4 Summary: Plant Layout and Facility Design") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12em", background = "#EBF5FB") %>%
  row_spec(0, bold = TRUE, background = "#4472C4", color = "white")
```

------------------------------------------------------------------------

## References

- Reid, R. D., & Sanders, N. R. (2019). *Operations Management: An Integrated Approach* (7th ed.). Wiley. Chapter 10.
- Groover, M. P. (2020). *Automation, Production Systems, and Computer-Integrated Manufacturing* (5th ed.). Pearson.
- Waters, T. R., Putz-Anderson, V., & Garg, A. (1994). *Applications Manual for the Revised NIOSH Lifting Equation*. NIOSH Publication No. 94-110.
- Tompkins, J. A., White, J. A., Bozer, Y. A., & Tanchoco, J. M. A. (2010). *Facilities Planning* (4th ed.). Wiley.
- FDA. (2021). *Current Good Manufacturing Practice, Hazard Analysis, and Risk-Based Preventive Controls for Human Food*. 21 CFR Part 117.
- OSHA. (2021). *Ergonomics: The Study of Work*. OSHA Publication 3125.

<!--chapter:end:04-Plant-Layout.Rmd-->

# Lean Manufacturing

------------------------------------------------------------------------

```{r setup-ch5, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Define Lean Manufacturing and explain its origins
- Identify and describe the 3 M's of Lean (Muda, Mura, Muri)
- Recognize and eliminate the seven types of waste
- Apply the 5S methodology to workplace organization
- Understand Just-in-Time (JIT) principles and Kanban systems
- Calculate Takt time and apply line balancing concepts
- Implement setup reduction techniques (SMED)

> "Perfection is not attainable. But if we chase perfection, we can catch excellence."
> — Vince Lombardi

------------------------------------------------------------------------

## Introduction to Lean Manufacturing

**Lean Manufacturing** is the systematic elimination of waste. The term can be traced to Jim Womack, Daniel Jones, and Daniel Roos' book *The Machine that Changed the World* (1991), which examined the Toyota Production System.

<details>
<summary>What does "Lean" actually mean?</summary>

The term "Lean" refers to cutting "fat" from production activities — eliminating anything that doesn't add value to the customer. Think of it like a lean athlete: no excess weight, maximum efficiency, peak performance.

</details>

### Definition of Lean

```{r lean-definition, echo=FALSE}
lean_def <- tibble(
  Metric = c("Human effort in factory", "Defects in finished product",
             "Engineering effort", "Factory space for same output",
             "In-process inventories"),
  `Lean Target` = c("Half the hours", "Half the defects",
                    "One-third the hours", "Half the space",
                    "A tenth or less")
)

lean_def %>%
  kable(format = "html", caption = "Lean Manufacturing Targets (Womack, Jones, Roos 1990)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2E7D32", color = "white") %>%
  column_spec(1, bold = TRUE, width = "15em") %>%
  column_spec(2, background = "#E8F5E9", width = "12em")
```

------------------------------------------------------------------------

## Evolution of Manufacturing Systems

Manufacturing has evolved through three major paradigms. Understanding this evolution helps us appreciate why Lean emerged as the dominant philosophy.

```{r manufacturing-evolution, echo=FALSE, fig.align="center", fig.cap="Evolution of Manufacturing Systems", fig.width=10, fig.height=6}
# Create timeline visualization
evolution_data <- data.frame(
  Era = c("Craft", "Mass", "Lean"),
  Year = c(1880, 1920, 1970),
  Volume = c(1, 5, 4),
  Variety = c(5, 1, 4),
  Quality = c(5, 2, 5),
  Cost = c(1, 5, 4)
)

# Reshape for plotting
evolution_long <- evolution_data %>%
  pivot_longer(cols = c(Volume, Variety, Quality, Cost),
               names_to = "Metric", values_to = "Score")

ggplot(evolution_long, aes(x = Era, y = Score, fill = Metric)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.7) +
  scale_fill_manual(values = c("Volume" = "#3498DB", "Variety" = "#E74C3C",
                                "Quality" = "#2ECC71", "Cost" = "#F39C12")) +
  scale_x_discrete(limits = c("Craft", "Mass", "Lean")) +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "", "Medium", "", "High")) +
  labs(title = "Manufacturing Evolution: Comparing Three Paradigms",
       subtitle = "Score comparison across key metrics (1=Low, 5=High)",
       x = "Manufacturing Era", y = "Performance Level") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "bottom",
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )
```

### Comparison of Manufacturing Systems

```{r mfg-comparison-table, echo=FALSE}
mfg_compare <- tibble(
  Characteristic = c("Time Period", "Process", "Workforce", "Components",
                     "Quality", "Cost", "Volume", "Flexibility"),
  `Craft Manufacturing` = c("Late 1800s", "Built on blocks, workers walk around",
                            "Craftsmen with pride", "Hand-crafted, hand-fitted",
                            "Excellent", "Very expensive", "Few produced", "Very high"),
  `Mass Manufacturing` = c("1920s (Ford)", "Assembly line",
                           "Low skilled, simplistic jobs", "Interchangeable parts",
                           "Lower", "Affordable", "Billions - identical", "Very low"),
  `Lean Manufacturing` = c("1970s - Present", "Cells or flexible lines",
                           "Highly skilled, proud of product", "Interchangeable, high variety",
                           "Excellent (mandatory)", "Continuously decreasing", "High volume, high variety", "High")
)

mfg_compare %>%
  kable(format = "html", caption = "Evolution of Manufacturing Systems") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 12) %>%
  row_spec(0, bold = TRUE, background = "#34495E", color = "white") %>%
  column_spec(1, bold = TRUE, background = "#ECF0F1", width = "10em")
```

<details>
<summary>Discussion: Why did Mass Manufacturing dominate for so long?</summary>

Mass manufacturing dominated because:

1. **Economies of scale** - Higher volume = lower unit cost
2. **Predictable demand** - Post-war boom created stable markets
3. **Limited competition** - Few global competitors
4. **Consumer acceptance** - "Any color as long as it's black" (Henry Ford)

**What changed?**
- Global competition (especially from Japan)
- Customers demanded variety and quality
- Product lifecycles shortened
- Technology enabled flexibility

</details>

------------------------------------------------------------------------

## The Toyota Production System (TPS)

The most influential lean manufacturing model is the **Toyota Production System (TPS)**, developed by Taiichi Ohno and Shigeo Shingo at Toyota.

### Historical Context

```{r tps-timeline, echo=FALSE, fig.align="center", fig.cap="Toyota's Journey to Lean Excellence", fig.width=10, fig.height=4}
timeline_data <- data.frame(
  year = c(1949, 1950, 1960, 1970, 1980, 1990),
  event = c("Toyota near\nbankruptcy", "Ohno begins\nJIT development",
            "Kanban system\nimplemented", "TPS refined\nand documented",
            "TPS studied\nby West", "\"Lean\" term\ncoined"),
  y = rep(0, 6)
)

ggplot(timeline_data, aes(x = year, y = y)) +
  geom_hline(yintercept = 0, color = "#2C3E50", size = 2) +
  geom_point(size = 8, color = "#E74C3C") +
  geom_text(aes(label = year), vjust = -2.5, fontface = "bold", size = 4) +
  geom_text(aes(label = event), vjust = 2.5, size = 3, lineheight = 0.8) +
  theme_void() +
  labs(title = "The Evolution of Toyota Production System") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(-1.5, 1.5) +
  xlim(1945, 1995)
```

**In 1949**, Toyota was on the brink of bankruptcy. Ford's car production was at least **8 times more efficient** than Toyota's.

> **Kiichiro Toyoda's Challenge:** "To achieve the same rate of production as the United States in three years."

**Taiichi Ohno** accepted this challenge. Inspired by American supermarkets, he developed the Just-in-Time method.

### Two Pillars of TPS

```{r tps-pillars, echo=FALSE, fig.align="center", fig.cap="The Two Pillars of Toyota Production System", fig.width=8, fig.height=5}
# House of Toyota visualization
ggplot() +
  # Roof
  annotate("polygon", x = c(0, 4, 8), y = c(4.5, 6, 4.5), fill = "#E74C3C", color = "black") +
  annotate("text", x = 4, y = 5, label = "CUSTOMER FOCUS\nHighest Quality, Lowest Cost, Shortest Lead Time",
           fontface = "bold", size = 3.5, color = "white", lineheight = 0.8) +
  # Pillars
  annotate("rect", xmin = 0.5, xmax = 3.5, ymin = 1.5, ymax = 4.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 2, y = 3, label = "JUST-IN-TIME\n\nRight part\nRight amount\nRight time",
           fontface = "bold", size = 3.5, color = "white", lineheight = 0.9) +
  annotate("rect", xmin = 4.5, xmax = 7.5, ymin = 1.5, ymax = 4.5, fill = "#2ECC71", color = "black") +
  annotate("text", x = 6, y = 3, label = "JIDOKA\n(Built-in Quality)\n\nStop and fix\nproblems\nimmediately",
           fontface = "bold", size = 3.5, color = "white", lineheight = 0.9) +
  # Foundation
  annotate("rect", xmin = 0, xmax = 8, ymin = 0, ymax = 1.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 4, y = 0.75,
           label = "FOUNDATION: Standardized Work • Kaizen • Stability • Heijunka",
           fontface = "bold", size = 3.5, color = "white") +
  theme_void() +
  labs(title = "The House of Toyota Production System") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(-0.5, 8.5) + ylim(-0.5, 6.5)
```

**1. Just-in-Time (JIT):** Produce only what is needed, when it is needed, in the amount needed.

**2. Jidoka (Built-in Quality):** Automation with a human touch — stop production immediately when a defect is detected.

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/F5vtCRFRAK0"
    title="Lean Manufacturing - A Pursuit of Perfection"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## The 3 M's of Lean

Lean manufacturing focuses on eliminating three types of inefficiency, known as the **3 M's**:

```{r three-ms, echo=FALSE, fig.align="center", fig.cap="The 3 M's of Lean Manufacturing", fig.width=9, fig.height=5}
# Create 3 M's visualization
ms_data <- data.frame(
  M = c("MUDA", "MURA", "MURI"),
  English = c("Waste", "Inconsistency", "Overburden"),
  x = c(1, 2, 3),
  y = c(1, 1, 1),
  color = c("#E74C3C", "#F39C12", "#9B59B6")
)

ggplot(ms_data, aes(x = x, y = y)) +
  geom_point(aes(color = M), size = 40, alpha = 0.8) +
  geom_text(aes(label = M), fontface = "bold", size = 6, color = "white", vjust = -0.3) +
  geom_text(aes(label = English), size = 4, color = "white", vjust = 1.2) +
  scale_color_manual(values = c("MUDA" = "#E74C3C", "MURA" = "#F39C12", "MURI" = "#9B59B6")) +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  labs(title = "The 3 M's of Lean") +
  xlim(0.3, 3.7) + ylim(0.5, 1.5)
```

```{r three-ms-table, echo=FALSE}
three_ms <- tibble(
  `Japanese` = c("**Muda** (無駄)", "**Mura** (斑)", "**Muri** (無理)"),
  `English` = c("Waste", "Inconsistency/Unevenness", "Overburden/Unreasonableness"),
  `Description` = c("Activities that consume resources without adding value",
                    "Variation and lack of uniformity in processes",
                    "Overburdening people or equipment beyond capacity"),
  `Example` = c("Excess inventory, waiting, defects",
                "Uneven production schedules, variable quality",
                "Unrealistic deadlines, overworked employees")
)

three_ms %>%
  kable(format = "html", caption = "The 3 M's Explained") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, width = "10em")
```

------------------------------------------------------------------------

## The Seven Types of Waste (MUDA)

**Shigeo Shingo** identified seven categories of waste common to manufacturing. These are activities that add cost without adding value.

> "Waste is everything that is not absolutely essential."
> — Hiroyuki Hirano

```{r seven-wastes-viz, echo=FALSE, fig.align="center", fig.cap="The Seven Types of Waste (TIMWOOD)", fig.width=10, fig.height=7}
# Create waste visualization
wastes <- data.frame(
  waste = c("Transport", "Inventory", "Motion", "Waiting",
            "Overproduction", "Over-processing", "Defects"),
  letter = c("T", "I", "M", "W", "O", "O", "D"),
  impact = c(3, 5, 2, 4, 5, 3, 4),
  x = c(1, 2, 3, 4, 5, 6, 7),
  description = c("Moving\nmaterials", "Excess\nstock", "Unnecessary\nmovement",
                  "Idle\ntime", "Making\ntoo much", "Extra\nwork", "Rework/\nscrap")
)

ggplot(wastes, aes(x = reorder(waste, -impact), y = impact)) +
  geom_bar(stat = "identity", fill = "#E74C3C", color = "black", width = 0.7) +
  geom_text(aes(label = letter), y = 0.3, size = 8, fontface = "bold", color = "white") +
  geom_text(aes(label = description, y = impact + 0.3), size = 3, vjust = 0, lineheight = 0.8) +
  scale_y_continuous(limits = c(0, 6), breaks = 1:5,
                     labels = c("Low", "", "Medium", "", "High")) +
  labs(title = "The Seven Wastes: TIMWOOD",
       subtitle = "Ranked by typical impact on manufacturing efficiency",
       x = "Type of Waste", y = "Typical Impact") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

### Detailed Breakdown of the Seven Wastes

```{r seven-wastes-table, echo=FALSE}
wastes_detail <- tibble(
  `#` = 1:7,
  `Waste Type` = c("**Overproduction**", "**Inventory**", "**Waiting**",
                   "**Transportation**", "**Over-processing**", "**Motion**", "**Defects**"),
  `Description` = c("Producing more than needed, earlier than needed",
                    "Excess raw materials, WIP, or finished goods",
                    "Idle time waiting for materials, information, or equipment",
                    "Unnecessary movement of materials between processes",
                    "Doing more work than the customer requires",
                    "Unnecessary movement of people",
                    "Products that don't meet specifications"),
  `Examples` = c("Building to forecast, large batch sizes",
                 "Safety stock, buffer inventory, obsolete stock",
                 "Machine downtime, waiting for approvals",
                 "Long distances between operations, poor layout",
                 "Tighter tolerances than needed, redundant inspections",
                 "Reaching, bending, walking to get tools",
                 "Scrap, rework, warranty claims"),
  `Solution` = c("Pull systems, smaller batches",
                 "JIT delivery, kanban systems",
                 "TPM, better scheduling",
                 "Cellular layout, co-location",
                 "Value engineering, standardization",
                 "5S, ergonomic workstations",
                 "Poka-yoke, root cause analysis")
)

wastes_detail %>%
  kable(format = "html", caption = "The Seven Wastes: Detailed Analysis") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#C0392B", color = "white") %>%
  row_spec(1:2, background = "#FADBD8") %>%
  column_spec(1, width = "3em", bold = TRUE)
```

<details>
<summary>Memory Aid: TIMWOOD</summary>

Use **TIMWOOD** to remember the seven wastes:

- **T**ransportation
- **I**nventory
- **M**otion
- **W**aiting
- **O**verproduction
- **O**ver-processing
- **D**efects

Some people also use **DOWNTIME** (adding "Non-utilized talent" as an 8th waste).

</details>

<details>
<summary>Interactive Exercise: Identify the Waste</summary>

**Scenario 1:** A worker walks 50 feet to get a tool, uses it for 30 seconds, then walks back.

**Answer:** This is **Motion** waste. The solution would be to place tools at the point of use (5S).

**Scenario 2:** A machine produces 1000 parts, but only 800 are needed this week.

**Answer:** This is **Overproduction** waste. The solution would be to implement pull production based on actual demand.

**Scenario 3:** Parts sit in a queue for 3 days before being processed at the next station.

**Answer:** This is both **Inventory** and **Waiting** waste. The solution would be to balance the line and implement one-piece flow.

</details>

------------------------------------------------------------------------

## The 5S Methodology

**5S** is a workplace organization methodology that creates a clean, efficient, and safe working environment.

```{r five-s-viz, echo=FALSE, fig.align="center", fig.cap="The 5S Methodology", fig.width=10, fig.height=6}
# Create 5S circular visualization
five_s <- data.frame(
  step = 1:5,
  japanese = c("Seiri", "Seiton", "Seiso", "Seiketsu", "Shitsuke"),
  english = c("Sort", "Set in Order", "Shine", "Standardize", "Sustain"),
  action = c("Remove\nunnecessary", "A place for\neverything", "Clean\nregularly",
             "Make it\nstandard", "Maintain\ndiscipline"),
  angle = seq(90, -198, length.out = 5),
  color = c("#E74C3C", "#F39C12", "#2ECC71", "#3498DB", "#9B59B6")
)

# Calculate positions on circle
five_s$x <- 2 * cos(five_s$angle * pi / 180)
five_s$y <- 2 * sin(five_s$angle * pi / 180)

ggplot(five_s) +
  # Center circle
  annotate("point", x = 0, y = 0, size = 25, color = "#2C3E50") +
  annotate("text", x = 0, y = 0, label = "5S", size = 10, color = "white", fontface = "bold") +
  # Outer circles
  geom_point(aes(x = x, y = y, color = japanese), size = 22, alpha = 0.9) +
  geom_text(aes(x = x, y = y + 0.15, label = paste0(step, "S")),
            size = 5, fontface = "bold", color = "white") +
  geom_text(aes(x = x, y = y - 0.15, label = japanese),
            size = 3.5, color = "white") +
  # Labels outside
  geom_text(aes(x = x * 1.6, y = y * 1.6, label = english),
            size = 4, fontface = "bold") +
  geom_text(aes(x = x * 1.9, y = y * 1.9, label = action),
            size = 3, lineheight = 0.8) +
  scale_color_manual(values = c("Seiri" = "#E74C3C", "Seiton" = "#F39C12",
                                "Seiso" = "#2ECC71", "Seiketsu" = "#3498DB",
                                "Shitsuke" = "#9B59B6")) +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  labs(title = "The 5S Methodology for Workplace Organization") +
  coord_fixed() +
  xlim(-4.5, 4.5) + ylim(-4.5, 4.5)
```

```{r five-s-table, echo=FALSE}
five_s_detail <- tibble(
  `Step` = c("1S", "2S", "3S", "4S", "5S"),
  `Japanese` = c("**Seiri**", "**Seiton**", "**Seiso**", "**Seiketsu**", "**Shitsuke**"),
  `English` = c("Sort", "Set in Order", "Shine", "Standardize", "Sustain"),
  `Action` = c("Remove unnecessary items from the workplace",
               "Organize items so they are easy to find and use",
               "Clean the workplace regularly",
               "Create standards for maintaining 1S-3S",
               "Build discipline to maintain standards"),
  `Key Question` = c("Do we need this?", "Where does this belong?",
                     "Is everything clean?", "How do we keep it this way?",
                     "Are we following our standards?")
)

five_s_detail %>%
  kable(format = "html", caption = "The 5S Steps Explained") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  row_spec(1, background = "#FADBD8") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3, background = "#D5F5E3") %>%
  row_spec(4, background = "#D6EAF8") %>%
  row_spec(5, background = "#E8DAEF")
```

### Visual Factory

> "The ability to understand the status of a production area in **5 minutes or less** by simple observation without use of computers or speaking to anyone."

A well-implemented 5S creates a **visual factory** where problems are immediately apparent.

------------------------------------------------------------------------

## Just-in-Time (JIT) Production

### The JIT Philosophy

> "Deliver the right material, in the exact quantity, with perfect quality, in the right place, just before it is needed."
> — Ohno and Shingo

```{r jit-concept, echo=FALSE, fig.align="center", fig.cap="Just-in-Time: The Right Everything", fig.width=9, fig.height=5}
jit_elements <- data.frame(
  element = c("Right Part", "Right Quantity", "Right Quality",
              "Right Place", "Right Time"),
  x = c(1, 2, 3, 4, 5),
  y = rep(1, 5),
  icon = c("Part", "Qty", "Quality", "Place", "Time")
)

ggplot(jit_elements, aes(x = x, y = y)) +
  # Arrows connecting elements
  geom_segment(aes(x = x + 0.3, xend = x + 0.7, y = y, yend = y),
               data = jit_elements[1:4,],
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1.5) +
  # Circles
  geom_point(size = 20, color = "#3498DB") +
  geom_text(aes(label = element), size = 3, fontface = "bold", color = "white",
            lineheight = 0.8) +
  # Final output
  annotate("point", x = 6.5, y = 1, size = 25, color = "#2ECC71") +
  annotate("text", x = 6.5, y = 1, label = "CUSTOMER\nSATISFACTION",
           size = 3.5, fontface = "bold", color = "white", lineheight = 0.9) +
  geom_segment(aes(x = 5.4, xend = 5.9, y = 1, yend = 1),
               arrow = arrow(length = unit(0.3, "cm")), color = "#2C3E50", size = 2) +
  theme_void() +
  labs(title = "Just-in-Time: Delivering Value to the Customer") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(0.3, 7.2)
```

### Push vs. Pull Systems

```{r push-pull-viz, echo=FALSE, fig.align="center", fig.cap="Push vs. Pull Production Systems", fig.width=10, fig.height=6}
# Create comparison visualization
par(mfrow = c(2, 1))

# Push system data
push_data <- data.frame(
  station = c("Forecast", "Station 1", "Station 2", "Station 3", "Customer"),
  x = 1:5,
  y = rep(2, 5),
  inventory = c(0, 30, 50, 40, 10)
)

# Pull system data
pull_data <- data.frame(
  station = c("Supplier", "Station 1", "Station 2", "Station 3", "Customer"),
  x = 1:5,
  y = rep(1, 5),
  inventory = c(5, 5, 5, 5, 0)
)

# Combine for ggplot
push_data$system <- "PUSH System (Traditional)"
pull_data$system <- "PULL System (Lean/JIT)"
combined <- rbind(push_data, pull_data)
combined$y <- ifelse(combined$system == "PUSH System (Traditional)", 2, 1)

ggplot(combined, aes(x = x, y = y)) +
  # Station boxes
  geom_tile(fill = "#3498DB", width = 0.8, height = 0.3, color = "black") +
  geom_text(aes(label = station), size = 3, fontface = "bold", color = "white") +
  # Inventory indicators
  geom_point(aes(y = y + 0.25, size = inventory), color = "#E74C3C", alpha = 0.7) +
  geom_text(aes(y = y + 0.25, label = inventory), size = 2.5, color = "white", fontface = "bold") +
  # Arrows
  geom_segment(data = combined[combined$x < 5,],
               aes(x = x + 0.45, xend = x + 0.55, y = y, yend = y),
               arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  # Labels
  annotate("text", x = 0.3, y = 2, label = "PUSH", hjust = 1, fontface = "bold", size = 5, color = "#E74C3C") +
  annotate("text", x = 0.3, y = 1, label = "PULL", hjust = 1, fontface = "bold", size = 5, color = "#2ECC71") +
  # Information flow arrows
  annotate("segment", x = 1, xend = 5, y = 2.5, yend = 2.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "#F39C12", size = 1) +
  annotate("text", x = 3, y = 2.6, label = "Information Flow →", color = "#F39C12", size = 3) +
  annotate("segment", x = 5, xend = 1, y = 0.5, yend = 0.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "#2ECC71", size = 1) +
  annotate("text", x = 3, y = 0.4, label = "← Signal/Kanban", color = "#2ECC71", size = 3) +
  scale_size_continuous(range = c(3, 15), guide = "none") +
  theme_void() +
  labs(title = "Push vs. Pull: A Visual Comparison",
       subtitle = "Circle size represents inventory level at each station") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-0.2, 5.5) + ylim(0.2, 2.8)
```

```{r push-pull-table, echo=FALSE}
push_pull <- tibble(
  Aspect = c("Production trigger", "Information flow", "Inventory levels",
             "Flexibility", "Problem visibility", "Customer responsiveness"),
  `Push System` = c("Forecast/Schedule", "Forward (upstream to downstream)",
                    "High (buffers at each station)", "Low",
                    "Problems hidden by inventory", "Slow"),
  `Pull System` = c("Actual demand/Kanban signal", "Backward (downstream to upstream)",
                    "Low (minimal buffers)", "High",
                    "Problems immediately visible", "Fast")
)

push_pull %>%
  kable(format = "html", caption = "Push vs. Pull System Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em") %>%
  column_spec(2, background = "#FADBD8") %>%
  column_spec(3, background = "#D5F5E3")
```

### Kanban System

**Kanban** (看板) is Japanese for "signboard" or "billboard." It's a scheduling system for lean and JIT production.

```{r kanban-example, echo=FALSE, fig.align="center", fig.cap="Example Kanban Card", fig.width=7, fig.height=4}
ggplot() +
  # Card border
  annotate("rect", xmin = 0, xmax = 7, ymin = 0, ymax = 4,
           fill = "white", color = "black", size = 2) +
  # Header
  annotate("rect", xmin = 0, xmax = 7, ymin = 3.2, ymax = 4,
           fill = "#3498DB", color = "black") +
  annotate("text", x = 3.5, y = 3.6, label = "PRODUCTION KANBAN",
           fontface = "bold", size = 5, color = "white") +
  # Content
  annotate("text", x = 0.3, y = 2.8, label = "Part Number:", hjust = 0, size = 3.5) +
  annotate("text", x = 3, y = 2.8, label = "3278784", hjust = 0, size = 3.5, fontface = "bold") +
  annotate("text", x = 0.3, y = 2.4, label = "Part Name:", hjust = 0, size = 3.5) +
  annotate("text", x = 3, y = 2.4, label = "Securing Bracket", hjust = 0, size = 3.5, fontface = "bold") +
  annotate("text", x = 0.3, y = 2.0, label = "From Process:", hjust = 0, size = 3.5) +
  annotate("text", x = 3, y = 2.0, label = "CNC Turning (CNC-6)", hjust = 0, size = 3.5, fontface = "bold") +
  annotate("text", x = 0.3, y = 1.6, label = "To Process:", hjust = 0, size = 3.5) +
  annotate("text", x = 3, y = 1.6, label = "CNC Machining (CNC-M7)", hjust = 0, size = 3.5, fontface = "bold") +
  annotate("text", x = 0.3, y = 1.0, label = "Container Qty:", hjust = 0, size = 3.5) +
  annotate("text", x = 2.5, y = 1.0, label = "12", hjust = 0, size = 4, fontface = "bold") +
  annotate("text", x = 4, y = 1.0, label = "Container Type:", hjust = 0, size = 3.5) +
  annotate("text", x = 6, y = 1.0, label = "A1", hjust = 0, size = 4, fontface = "bold") +
  # Barcode placeholder
  annotate("rect", xmin = 5, xmax = 6.8, ymin = 1.8, ymax = 2.8, fill = "#ECF0F1", color = "black") +
  annotate("text", x = 5.9, y = 2.3, label = "|||||||||||", size = 5) +
  theme_void() +
  labs(title = "Sample Production Kanban Card") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 12))
```

------------------------------------------------------------------------

## Key Time Metrics

Understanding time metrics is essential for lean manufacturing analysis and improvement.

### Definitions

```{r time-metrics-viz, echo=FALSE, fig.align="center", fig.cap="Relationship Between Time Metrics", fig.width=10, fig.height=5}
ggplot() +
  # Lead Time bar (longest)
  annotate("rect", xmin = 0, xmax = 10, ymin = 2.5, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 5, y = 2.75, label = "LEAD TIME (Order to Delivery)", color = "white", fontface = "bold") +
  # Throughput Time bar
  annotate("rect", xmin = 1, xmax = 9, ymin = 1.5, ymax = 2, fill = "#F39C12", alpha = 0.8) +
  annotate("text", x = 5, y = 1.75, label = "THROUGHPUT TIME (Start to Finish)", color = "white", fontface = "bold") +
  # Cycle Times
  annotate("rect", xmin = 1.5, xmax = 3, ymin = 0.5, ymax = 1, fill = "#3498DB", alpha = 0.8) +
  annotate("rect", xmin = 3.5, xmax = 5, ymin = 0.5, ymax = 1, fill = "#3498DB", alpha = 0.8) +
  annotate("rect", xmin = 5.5, xmax = 7, ymin = 0.5, ymax = 1, fill = "#3498DB", alpha = 0.8) +
  annotate("rect", xmin = 7.5, xmax = 8.5, ymin = 0.5, ymax = 1, fill = "#3498DB", alpha = 0.8) +
  annotate("text", x = 2.25, y = 0.75, label = "Op 1", color = "white", size = 3) +
  annotate("text", x = 4.25, y = 0.75, label = "Op 2", color = "white", size = 3) +
  annotate("text", x = 6.25, y = 0.75, label = "Op 3", color = "white", size = 3) +
  annotate("text", x = 8, y = 0.75, label = "Op 4", color = "white", size = 3) +
  annotate("text", x = 5, y = 0.2, label = "CYCLE TIMES (Individual Operations)", fontface = "bold") +
  # Takt Time reference line
  annotate("segment", x = 0, xend = 10, y = 3.5, yend = 3.5,
           linetype = "dashed", color = "#2ECC71", size = 1.5) +
  annotate("text", x = 5, y = 3.7, label = "TAKT TIME (Customer Demand Rate)",
           color = "#2ECC71", fontface = "bold") +
  theme_void() +
  labs(title = "Understanding Time Metrics in Manufacturing") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(-0.2, 4)
```

### Formulas and Calculations

**Takt Time** — The pace of production to meet customer demand:

$$\text{Takt Time} = \frac{\text{Available Production Time}}{\text{Customer Demand}}$$

**Cycle Time** — Time to complete one unit at a workstation:

$$\text{Cycle Time} = \frac{\text{Net Operating Time}}{\text{Units Produced}}$$

**Throughput Time** — Total time from start to finish:

$$\text{Throughput Time} = \text{Processing} + \text{Inspection} + \text{Queue} + \text{Move Time}$$

### Interactive Example: Calculating Takt Time

```{r takt-calculation, echo=TRUE}
# Given data
available_time_per_day <- 8 * 60  # 8 hours = 480 minutes
breaks_and_meetings <- 60         # 60 minutes for breaks/meetings
customer_demand <- 240            # 240 units per day

# Calculate net available time
net_available_time <- available_time_per_day - breaks_and_meetings
cat("Net Available Time:", net_available_time, "minutes/day\n")

# Calculate Takt Time
takt_time <- net_available_time / customer_demand
cat("Takt Time:", takt_time, "minutes per unit\n")
cat("Takt Time:", takt_time * 60, "seconds per unit\n")

# Interpretation
cat("\n--- Interpretation ---\n")
cat("To meet customer demand, we must produce 1 unit every",
    takt_time, "minutes (", takt_time * 60, "seconds).\n")
```

<details>
<summary>Practice Problem: Calculate Your Takt Time</summary>

**Given:**
- Shift length: 10 hours
- Two 15-minute breaks and one 30-minute lunch
- Customer requires 300 units per shift

**Calculate:**
1. Net available production time
2. Takt time in minutes
3. Takt time in seconds

**Solution:**
```
Net time = (10 × 60) - (15 + 15 + 30) = 600 - 60 = 540 minutes
Takt time = 540 / 300 = 1.8 minutes = 108 seconds per unit
```

</details>

------------------------------------------------------------------------

## Setup Reduction (SMED)

**SMED** (Single Minute Exchange of Dies) is a methodology developed by Shigeo Shingo to dramatically reduce changeover time.

### The SMED Concept

```{r smed-viz, echo=FALSE, fig.align="center", fig.cap="SMED: Internal vs External Setup", fig.width=10, fig.height=5}
# Before SMED
before <- data.frame(
  activity = c("Get tools", "Remove old die", "Install new die", "Adjust settings", "Get materials", "First article"),
  time = c(15, 30, 45, 20, 10, 10),
  type = c("External", "Internal", "Internal", "Internal", "External", "Internal"),
  x_start = c(0, 15, 45, 90, 110, 120),
  scenario = "BEFORE SMED"
)
before$x_end <- before$x_start + before$time

# After SMED
after <- data.frame(
  activity = c("Install new die", "Adjust settings", "First article"),
  time = c(30, 15, 5),
  type = c("Internal", "Internal", "Internal"),
  x_start = c(0, 30, 45),
  scenario = "AFTER SMED"
)
after$x_end <- after$x_start + after$time

ggplot() +
  # Before SMED bars
  geom_rect(data = before, aes(xmin = x_start, xmax = x_end, ymin = 1.6, ymax = 2,
                                fill = type), color = "black") +
  geom_text(data = before, aes(x = (x_start + x_end)/2, y = 1.8, label = activity),
            size = 2.5, angle = 0) +
  # After SMED bars
  geom_rect(data = after, aes(xmin = x_start, xmax = x_end, ymin = 0.6, ymax = 1,
                               fill = type), color = "black") +
  geom_text(data = after, aes(x = (x_start + x_end)/2, y = 0.8, label = activity),
            size = 2.5, angle = 0) +
  # Labels
  annotate("text", x = -10, y = 1.8, label = "BEFORE\n(130 min)", hjust = 1, fontface = "bold", size = 3) +
  annotate("text", x = -10, y = 0.8, label = "AFTER\n(50 min)", hjust = 1, fontface = "bold", size = 3) +
  # External activities done in parallel
  annotate("rect", xmin = -50, xmax = 0, ymin = 0.4, ymax = 0.6, fill = "#3498DB", alpha = 0.5) +
  annotate("text", x = -25, y = 0.5, label = "External done\nduring production", size = 2.5, color = "white") +
  scale_fill_manual(values = c("Internal" = "#E74C3C", "External" = "#3498DB"),
                    name = "Setup Type") +
  theme_void() +
  labs(title = "SMED: From 130 Minutes to 50 Minutes",
       subtitle = "External activities moved to run during production") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10),
        legend.position = "bottom") +
  xlim(-55, 135)
```

### SMED Methodology

```{r smed-steps, echo=FALSE}
smed_steps <- tibble(
  Step = c("1", "2", "3", "4"),
  Action = c("**Document current process**",
             "**Separate internal and external**",
             "**Convert internal to external**",
             "**Streamline all operations**"),
  Description = c("Video the entire changeover, identify all steps",
                  "Internal = machine must be stopped; External = can be done while running",
                  "Find ways to perform 'internal' tasks while machine is running",
                  "Reduce time for remaining internal tasks through better methods"),
  Example = c("Time each step of die change",
              "Getting tools = external; Removing die = internal",
              "Pre-stage next die, pre-heat tools",
              "Use quick-release clamps instead of bolts")
)

smed_steps %>%
  kable(format = "html", caption = "The Four Steps of SMED") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, width = "5em", bold = TRUE)
```

<details>
<summary>Case Study: Press Setup Reduction</summary>

**Problem:** Presses were idle more than 50% of the time due to setup.
- Average production run: 1-2 days
- Setup time: 1-2 days

**Root Cause Analysis:**
- Using standard bolt fasteners with open-end wrenches
- No pre-staging of tools or dies
- Sequential operations that could be parallel

**Solutions Implemented:**

| Change | Time Saved |
|--------|------------|
| Socket sets + power tools | 10% |
| Quick-release clamps | 50% |
| Pre-staging materials | 20% |
| Parallel operations | 20% |

**Result:** Setup time reduced from 1-2 days to 4-6 hours, with a target of under 1 hour.

</details>

------------------------------------------------------------------------

## Kaizen: Continuous Improvement

**Kaizen** (改善) means "change for the better" — the philosophy of continuous, incremental improvement.

### Kaizen Principles

```{r kaizen-cycle, echo=FALSE, fig.align="center", fig.cap="The Kaizen Continuous Improvement Cycle", fig.width=8, fig.height=8}
# Create PDCA cycle
pdca <- data.frame(
  step = c("PLAN", "DO", "CHECK", "ACT"),
  angle = c(45, 315, 225, 135),
  color = c("#3498DB", "#2ECC71", "#F39C12", "#E74C3C"),
  description = c("Identify\nopportunity", "Test\nsolution", "Measure\nresults", "Standardize\nor adjust")
)

pdca$x <- 2 * cos(pdca$angle * pi / 180)
pdca$y <- 2 * sin(pdca$angle * pi / 180)

ggplot(pdca) +
  # Center
  annotate("point", x = 0, y = 0, size = 30, color = "#2C3E50") +
  annotate("text", x = 0, y = 0, label = "KAIZEN\n改善", size = 6, color = "white",
           fontface = "bold", lineheight = 0.8) +
  # Outer circles
  geom_point(aes(x = x, y = y, color = step), size = 25, alpha = 0.9) +
  geom_text(aes(x = x, y = y + 0.1, label = step), size = 5, fontface = "bold", color = "white") +
  geom_text(aes(x = x, y = y - 0.25, label = description), size = 3, color = "white", lineheight = 0.8) +
  # Arrows
  annotate("curve", x = 1.5, xend = 1.5, y = 2, yend = -0.5,
           arrow = arrow(length = unit(0.3, "cm")), curvature = 0.5, color = "#2C3E50", size = 1) +
  annotate("curve", x = 1.5, xend = -1.5, y = -2, yend = -1.5,
           arrow = arrow(length = unit(0.3, "cm")), curvature = 0.5, color = "#2C3E50", size = 1) +
  annotate("curve", x = -1.5, xend = -1.5, y = -2, yend = 0.5,
           arrow = arrow(length = unit(0.3, "cm")), curvature = 0.5, color = "#2C3E50", size = 1) +
  annotate("curve", x = -1.5, xend = 1.5, y = 2, yend = 1.5,
           arrow = arrow(length = unit(0.3, "cm")), curvature = 0.5, color = "#2C3E50", size = 1) +
  scale_color_manual(values = c("PLAN" = "#3498DB", "DO" = "#2ECC71",
                                "CHECK" = "#F39C12", "ACT" = "#E74C3C")) +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  labs(title = "Plan-Do-Check-Act: The Engine of Kaizen") +
  coord_fixed() +
  xlim(-3.5, 3.5) + ylim(-3.5, 3.5)
```

### Key Kaizen Concepts

- **Everyone participates** — from CEO to frontline workers
- **Small, incremental changes** — not major overhauls
- **Focus on process** — blame the process, not the person
- **Data-driven decisions** — measure before and after
- **Standardize improvements** — lock in gains

------------------------------------------------------------------------

## Value Stream Mapping (VSM)

**Value Stream Mapping** is a lean tool for analyzing the flow of materials and information required to bring a product to the customer.

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/GQSq54OcgCA"
    title="Value Stream Mapping"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

### VSM Symbols

```{r vsm-metrics, echo=FALSE}
vsm_metrics <- tibble(
  Metric = c("**Process Time (PT)**", "**Lead Time (LT)**", "**Changeover Time (C/O)**",
             "**Uptime**", "**Takt Time**", "**WIP Inventory**"),
  Description = c("Time to actually process one unit",
                  "Total time from raw material to finished good",
                  "Time to switch between products",
                  "Percentage of time equipment is available",
                  "Required pace to meet demand",
                  "Units waiting between processes"),
  `Typical Location` = c("In process box", "Timeline at bottom",
                         "In process box", "In process box",
                         "Noted on map", "Triangle symbol between processes")
)

vsm_metrics %>%
  kable(format = "html", caption = "Key Metrics in Value Stream Maps") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white")
```

------------------------------------------------------------------------

## Summary

```{r summary-table-lean, echo=FALSE}
summary_data <- tibble(
  Concept = c("**Lean Manufacturing**", "**3 M's**", "**7 Wastes**", "**5S**",
              "**JIT**", "**Kanban**", "**SMED**", "**Kaizen**"),
  Definition = c("Systematic elimination of waste",
                 "Muda (waste), Mura (inconsistency), Muri (overburden)",
                 "TIMWOOD: Transport, Inventory, Motion, Waiting, Overproduction, Over-processing, Defects",
                 "Sort, Set in Order, Shine, Standardize, Sustain",
                 "Right part, right quantity, right quality, right place, right time",
                 "Visual signal system for pull production",
                 "Single Minute Exchange of Dies - rapid changeover",
                 "Continuous incremental improvement"),
  `Key Benefit` = c("Reduced cost, improved quality",
                    "Framework for identifying improvement opportunities",
                    "Systematic waste identification",
                    "Organized, efficient workplace",
                    "Minimal inventory, fast response",
                    "Controlled WIP, smooth flow",
                    "Flexibility, reduced batch sizes",
                    "Engaged workforce, sustained improvement")
)

summary_data %>%
  kable(format = "html", caption = "Lean Manufacturing: Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "12em")
```

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: What are the seven types of waste, and which is often considered the most impactful?</summary>

The seven types of waste (TIMWOOD) are:
1. **T**ransportation
2. **I**nventory
3. **M**otion
4. **W**aiting
5. **O**verproduction
6. **O**ver-processing
7. **D**efects

**Inventory** is often considered the most impactful because it hides other problems, ties up capital, and can become obsolete.

</details>

<details>
<summary>Question 2: Explain the difference between Push and Pull production systems.</summary>

**Push System:**
- Production based on forecasts
- Materials pushed through the system
- Results in high inventory
- Problems hidden by buffer stock

**Pull System:**
- Production triggered by actual demand
- Materials pulled by downstream operations
- Minimal inventory
- Problems immediately visible

</details>

<details>
<summary>Question 3: Calculate the Takt time for a facility with 450 minutes of available time and demand of 150 units.</summary>

$$\text{Takt Time} = \frac{450 \text{ minutes}}{150 \text{ units}} = 3 \text{ minutes per unit}$$

This means we need to produce one unit every 3 minutes (180 seconds) to meet customer demand.

</details>

<details>
<summary>Question 4: What is the difference between internal and external setup in SMED?</summary>

**Internal Setup:** Activities that can ONLY be performed when the machine is stopped (e.g., physically removing the old die).

**External Setup:** Activities that CAN be performed while the machine is still running (e.g., getting tools, pre-staging the next die, preparing materials).

The key to SMED is converting as many internal activities to external as possible.

</details>

------------------------------------------------------------------------

## References

- Womack, J., Jones, D., & Roos, D. (1990). *The Machine that Changed the World*.
- Ohno, T. (1988). *Toyota Production System: Beyond Large-Scale Production*.
- Shingo, S. (1985). *A Revolution in Manufacturing: The SMED System*.
- Liker, J. (2004). *The Toyota Way*.
- Wang, H.P., Chang, T.C., & Wysk, R.A. (2007). *Computer Aided Manufacturing*, Chapter 18.

<!--chapter:end:05-Lean-Manufacturing.Rmd-->

# Machine Guarding and Functional Safety

------------------------------------------------------------------------

```{r setup-ch6, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Apply the Hierarchy of Controls to manufacturing safety design
- Identify and specify appropriate physical guarding and interlock systems
- Select and position presence-sensing devices (light curtains, area scanners)
- Calculate safety distances for protective device placement
- Understand collaborative robot safety requirements
- Design emergency stop systems according to standards
- Differentiate between safety integrity levels (SIL) and performance levels (PL)

> "Safety isn't expensive, it's priceless."
> — Anonymous

------------------------------------------------------------------------

## Introduction: The Safety Hierarchy

In process engineering, safety is not merely a feature added at the end of a project; it is a **fundamental design constraint**. Before deploying safety devices, the engineer must apply the **Hierarchy of Controls** — a systematic approach to eliminating or reducing workplace hazards.

```{r hierarchy-controls-viz, echo=FALSE, fig.align="center", fig.cap="The Hierarchy of Controls (Most to Least Effective)", fig.width=9, fig.height=7}
# Create pyramid visualization
hierarchy_data <- data.frame(
  level = factor(c("Elimination", "Substitution", "Engineering Controls",
                   "Administrative Controls", "PPE"),
                 levels = c("PPE", "Administrative Controls", "Engineering Controls",
                           "Substitution", "Elimination")),
  effectiveness = c(5, 4, 3, 2, 1),
  width = c(2, 3, 4, 5, 6),
  y = c(5, 4, 3, 2, 1),
  description = c("Physically remove the hazard",
                  "Replace with less hazardous option",
                  "Isolate people from hazard",
                  "Change work procedures",
                  "Protect the worker"),
  color = c("#27AE60", "#2ECC71", "#3498DB", "#F39C12", "#E74C3C")
)

ggplot(hierarchy_data, aes(x = 0, y = y)) +
  # Pyramid levels
  geom_tile(aes(width = width, height = 0.9, fill = level), color = "white", size = 2) +
  # Level names
  geom_text(aes(label = level), fontface = "bold", color = "white", size = 5) +
  # Descriptions on the right
  geom_text(aes(x = 3.5, label = description), hjust = 0, size = 3.5, color = "#2C3E50") +
  # Effectiveness arrow
  annotate("segment", x = -4, xend = -4, y = 0.5, yend = 5.5,
           arrow = arrow(length = unit(0.4, "cm"), ends = "last"),
           color = "#2C3E50", size = 1.5) +
  annotate("text", x = -4.5, y = 3, label = "More\nEffective",
           angle = 90, vjust = 0, fontface = "bold", size = 4) +
  scale_fill_manual(values = c("Elimination" = "#27AE60", "Substitution" = "#2ECC71",
                               "Engineering Controls" = "#3498DB",
                               "Administrative Controls" = "#F39C12",
                               "PPE" = "#E74C3C")) +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  labs(title = "The Hierarchy of Controls",
       subtitle = "Always start at the top and work down") +
  xlim(-5.5, 7)
```

```{r hierarchy-table, echo=FALSE}
hierarchy_detail <- tibble(
  `Priority` = 1:5,
  `Control Level` = c("**Elimination**", "**Substitution**", "**Engineering Controls**",
                      "**Administrative Controls**", "**PPE**"),
  `Description` = c("Physically remove the hazard entirely",
                    "Replace with something less hazardous",
                    "Isolate people from the hazard through design",
                    "Change the way people work",
                    "Protect the worker with equipment"),
  `Example` = c("Eliminate pinch point by redesigning mechanism",
                "Use lower voltage (24V DC instead of 120V AC)",
                "Install machine guarding, light curtains, interlocks",
                "Safety procedures, training, warning signs, lock-out/tag-out",
                "Safety glasses, gloves, steel-toe boots, hearing protection"),
  `Effectiveness` = c("Most Effective", "Very Effective", "Effective",
                      "Less Effective", "Least Effective")
)

hierarchy_detail %>%
  kable(format = "html", caption = "Hierarchy of Controls: Detailed Breakdown") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#D5F5E3") %>%
  row_spec(3, background = "#D6EAF8") %>%
  row_spec(4, background = "#FEF9E7") %>%
  row_spec(5, background = "#FADBD8") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

<details>
<summary>Discussion: Why not just rely on PPE?</summary>

**PPE (Personal Protective Equipment)** is the least effective control because:

1. **It doesn't eliminate the hazard** — the danger still exists
2. **It depends on human compliance** — workers may forget or choose not to wear it
3. **It can fail** — equipment degrades, doesn't fit properly, or is damaged
4. **It's the last line of defense** — if PPE fails, the worker is exposed

**Key Principle:** The more we can design out hazards through engineering controls, the less we depend on human behavior to keep people safe.

> "If you have to post a warning sign, you've already failed at design."

</details>

------------------------------------------------------------------------

## Physical Guarding and Interlocks

Physical barriers are the most intuitive form of protection. They create a "hard" separation between the operator and moving parts, ensuring that humans cannot enter the danger zone during machine operation.

```{r guarding-types-viz, echo=FALSE, fig.align="center", fig.cap="Types of Physical Guarding", fig.width=10, fig.height=6}
# Create visualization of different guard types
guard_data <- data.frame(
  type = c("Fixed Guard", "Interlocked Gate", "Adjustable Guard", "Self-Adjusting Guard"),
  x = c(1, 2, 3, 4),
  protection = c(5, 5, 3, 3),
  flexibility = c(1, 3, 4, 5),
  cost = c(1, 3, 2, 4),
  color = c("#3498DB", "#E74C3C", "#F39C12", "#9B59B6")
)

guard_long <- guard_data %>%
  select(type, x, protection, flexibility) %>%
  pivot_longer(cols = c(protection, flexibility),
               names_to = "metric", values_to = "value")

ggplot(guard_long, aes(x = type, y = value, fill = metric)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.7) +
  scale_fill_manual(values = c("protection" = "#27AE60", "flexibility" = "#3498DB"),
                    labels = c("Flexibility", "Protection Level"),
                    name = "Metric") +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "", "Medium", "", "High")) +
  labs(title = "Comparison of Physical Guard Types",
       subtitle = "Protection vs. Flexibility trade-off",
       x = "Guard Type", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 20, hjust = 1, size = 10),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

### Fixed Guards

**Fixed guards** are permanent barriers that require tools to remove. They are the simplest and most reliable form of protection.

```{r fixed-guard-table, echo=FALSE}
fixed_guards <- tibble(
  `Characteristic` = c("Construction", "Removal", "Best Application",
                       "Advantages", "Disadvantages"),
  `Description` = c("Wire mesh, polycarbonate sheets, or solid metal panels",
                    "Requires tools (screws, bolts) to remove",
                    "Areas that need infrequent access for maintenance only",
                    "Simple, reliable, low cost, no moving parts to fail",
                    "Impedes visibility, slows maintenance, can be removed and not replaced")
)

fixed_guards %>%
  kable(format = "html", caption = "Fixed Guards: Key Characteristics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Interlocked Guards

**Interlocked guards** are access points equipped with sensors. When the guard is opened, the safety controller initiates a stop.

```{r interlock-diagram, echo=FALSE, fig.align="center", fig.cap="Interlocked Guard Operation Principle", fig.width=10, fig.height=5}
ggplot() +
  # Machine representation
  annotate("rect", xmin = 3, xmax = 7, ymin = 1, ymax = 4,
           fill = "#95A5A6", color = "black", size = 1) +
  annotate("text", x = 5, y = 2.5, label = "MACHINE\n(Hazard Zone)",
           fontface = "bold", size = 4) +
  # Guard door - closed position
  annotate("rect", xmin = 2.8, xmax = 3, ymin = 1.5, ymax = 3.5,
           fill = "#F39C12", color = "black", size = 1) +
  annotate("text", x = 1.8, y = 2.5, label = "Guard\nDoor", size = 3) +
  # Interlock switch
  annotate("point", x = 2.9, y = 3.3, size = 4, color = "#E74C3C") +
  annotate("text", x = 2.2, y = 3.5, label = "Interlock\nSwitch", size = 2.5) +
  # Safety controller
  annotate("rect", xmin = 0.5, xmax = 1.5, ymin = 0.5, ymax = 1.5,
           fill = "#2ECC71", color = "black") +
  annotate("text", x = 1, y = 1, label = "Safety\nPLC", size = 3, fontface = "bold") +
  # Connection lines
  annotate("segment", x = 2.9, xend = 1.5, y = 3.3, yend = 1.5,
           linetype = "dashed", color = "#E74C3C", size = 1) +
  annotate("segment", x = 1.5, xend = 3, y = 1, yend = 1,
           arrow = arrow(length = unit(0.2, "cm")), color = "#2ECC71", size = 1) +
  # Labels
  annotate("text", x = 2.25, y = 0.7, label = "Stop Signal", size = 3, color = "#2ECC71") +
  # Status indicators
  annotate("rect", xmin = 8, xmax = 10, ymin = 3, ymax = 4, fill = "#D5F5E3", color = "black") +
  annotate("text", x = 9, y = 3.5, label = "Door Closed\n= Machine Runs", size = 3) +
  annotate("rect", xmin = 8, xmax = 10, ymin = 1.5, ymax = 2.5, fill = "#FADBD8", color = "black") +
  annotate("text", x = 9, y = 2, label = "Door Open\n= Machine Stops", size = 3) +
  theme_void() +
  labs(title = "Interlocked Guard System",
       subtitle = "Opening the guard door breaks the safety circuit") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

### Stop Categories

When an interlock is triggered, the machine must stop. The **stop category** determines how this happens:

```{r stop-categories, echo=FALSE}
stop_cat <- tibble(
  `Category` = c("**Category 0**", "**Category 1**", "**Category 2**"),
  `Type` = c("Uncontrolled Stop", "Controlled Stop", "Controlled Stop"),
  `Method` = c("Immediate removal of power to actuators",
               "Controlled deceleration, then power removed",
               "Controlled stop with power maintained"),
  `Application` = c("Emergency stops, dangerous machines",
                    "High-inertia machines, robots",
                    "Process that cannot be interrupted abruptly"),
  `Example` = c("Press brake E-stop", "Industrial robot guard open", "CNC spindle during tool change")
)

stop_cat %>%
  kable(format = "html", caption = "Machine Stop Categories (IEC 60204-1)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

### Trapped Key Systems (Lock-Out/Tag-Out)

**Trapped key systems** use a mechanical sequence to ensure that a machine cannot be energized unless all access keys are returned to the control panel.

```{r loto-sequence, echo=FALSE, fig.align="center", fig.cap="Trapped Key System Sequence", fig.width=10, fig.height=4}
loto_steps <- data.frame(
  step = 1:5,
  action = c("Turn off\nmachine", "Lock out\npower", "Remove key\nfrom panel",
             "Key opens\naccess gate", "Gate key\ntrapped inside"),
  x = 1:5
)

ggplot(loto_steps, aes(x = x, y = 1)) +
  # Step circles
  geom_point(size = 18, color = "#3498DB") +
  geom_text(aes(label = step), color = "white", fontface = "bold", size = 6) +
  # Action labels
  geom_text(aes(y = 0.5, label = action), size = 3, lineheight = 0.8) +
  # Arrows
  geom_segment(data = loto_steps[1:4,],
               aes(x = x + 0.4, xend = x + 0.6, y = 1, yend = 1),
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  # Return arrow
  annotate("curve", x = 5, xend = 1, y = 1.6, yend = 1.6,
           curvature = -0.3, arrow = arrow(length = unit(0.2, "cm")),
           color = "#27AE60", size = 1, linetype = "dashed") +
  annotate("text", x = 3, y = 1.85, label = "To restart: Reverse sequence",
           color = "#27AE60", fontface = "italic", size = 3) +
  theme_void() +
  labs(title = "Trapped Key System: Ensuring Safe Access",
       subtitle = "Machine cannot restart until key is returned") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(0, 2.2)
```

<details>
<summary>Case Study: The Fatal Bypass</summary>

**Incident:** A maintenance worker was killed when a robot arm unexpectedly activated while he was inside a robotic cell.

**What Happened:**
- The guard interlock had been bypassed with a "defeat device" (a magnet taped to fool the sensor)
- Workers had bypassed the interlock because it slowed down troubleshooting
- The bypass had been in place for months without management knowledge

**Root Causes:**
1. Interlock caused inconvenience during frequent troubleshooting
2. No monitoring system to detect bypasses
3. Culture that tolerated "workarounds"

**Lessons Learned:**
- Design interlocks that don't impede normal operations
- Use tamper-evident or tamper-resistant devices
- Regular safety audits to detect bypasses
- Zero-tolerance policy for defeating safety devices

> **Never bypass a safety device, even temporarily.**

</details>

------------------------------------------------------------------------

## Presence-Sensing Devices

Presence-sensing devices allow for a **"fence-less" environment**, improving visibility and ergonomics while maintaining high safety levels. They detect when a person enters a hazardous zone and trigger a machine stop.

```{r presence-sensing-overview, echo=FALSE, fig.align="center", fig.cap="Types of Presence-Sensing Devices", fig.width=10, fig.height=6}
sensing_data <- data.frame(
  device = c("Light Curtain", "Area Scanner", "Pressure Mat", "Safety Radar"),
  detection = c("Line/Plane", "2D Area", "Floor Area", "3D Volume"),
  range = c("Short", "Medium-Long", "Short", "Long"),
  flexibility = c(2, 5, 2, 5),
  cost = c(3, 4, 2, 5),
  x = 1:4
)

sensing_long <- sensing_data %>%
  pivot_longer(cols = c(flexibility, cost), names_to = "metric", values_to = "value")

ggplot(sensing_long, aes(x = device, y = value, fill = metric)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.7) +
  scale_fill_manual(values = c("flexibility" = "#3498DB", "cost" = "#E74C3C"),
                    labels = c("Relative Cost", "Flexibility"),
                    name = "Metric") +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "", "Medium", "", "High")) +
  labs(title = "Presence-Sensing Device Comparison",
       x = "Device Type", y = "Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text.x = element_text(size = 10),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

### Light Curtains

**Light curtains** use a transmitter and receiver to create an array of infrared beams. If any beam is broken, the safety circuit is interrupted.

```{r light-curtain-diagram, echo=FALSE, fig.align="center", fig.cap="Light Curtain Operating Principle", fig.width=10, fig.height=6}
ggplot() +
  # Transmitter
  annotate("rect", xmin = 0, xmax = 0.5, ymin = 0, ymax = 5,
           fill = "#3498DB", color = "black") +
  annotate("text", x = 0.25, y = 5.3, label = "Transmitter\n(TX)", size = 3, fontface = "bold") +
  # Receiver
  annotate("rect", xmin = 4.5, xmax = 5, ymin = 0, ymax = 5,
           fill = "#E74C3C", color = "black") +
  annotate("text", x = 4.75, y = 5.3, label = "Receiver\n(RX)", size = 3, fontface = "bold") +
  # Beam lines
  annotate("segment", x = rep(0.5, 10), xend = rep(4.5, 10),
           y = seq(0.25, 4.75, 0.5), yend = seq(0.25, 4.75, 0.5),
           color = "#F39C12", size = 0.8, linetype = "dotted") +
  # Machine/hazard behind
  annotate("rect", xmin = 5.5, xmax = 8, ymin = 0.5, ymax = 4.5,
           fill = "#95A5A6", color = "black") +
  annotate("text", x = 6.75, y = 2.5, label = "HAZARD\nZONE", fontface = "bold", size = 4) +
  # Hand breaking beam
  annotate("point", x = 2.5, y = 2.5, size = 15, color = "#E67E22") +
  annotate("text", x = 2.5, y = 2.5, label = "Hand", size = 3, color = "white") +
  # Broken beam indication
  annotate("segment", x = 0.5, xend = 2.2, y = 2.5, yend = 2.5,
           color = "#E74C3C", size = 1.5) +
  annotate("text", x = 1.35, y = 2.8, label = "Beam\nBroken!", color = "#E74C3C",
           size = 3, fontface = "bold") +
  # Safety controller
  annotate("rect", xmin = 6, xmax = 7.5, ymin = -1.2, ymax = -0.3,
           fill = "#2ECC71", color = "black") +
  annotate("text", x = 6.75, y = -0.75, label = "Safety\nController", size = 3) +
  # Connections
  annotate("segment", x = 4.75, xend = 6.75, y = 0, yend = -0.3,
           linetype = "dashed", color = "#2C3E50") +
  # Resolution indicator
  annotate("segment", x = -0.5, xend = -0.5, y = 0.25, yend = 0.75,
           arrow = arrow(length = unit(0.1, "cm"), ends = "both"), color = "#2C3E50") +
  annotate("text", x = -1, y = 0.5, label = "Resolution\n(14mm typical)", size = 2.5) +
  theme_void() +
  labs(title = "Light Curtain: Detection Through Beam Interruption",
       subtitle = "Any object larger than the resolution will trigger a stop") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-1.5, 8.5) + ylim(-1.5, 6)
```

```{r light-curtain-specs, echo=FALSE}
lc_specs <- tibble(
  `Parameter` = c("Resolution", "Height", "Range", "Response Time", "Application"),
  `Finger Detection (14mm)` = c("14mm beam spacing", "150-1800mm", "0.5-20m",
                                 "5-15ms", "Point of operation guarding"),
  `Hand Detection (30mm)` = c("30mm beam spacing", "300-1800mm", "0.5-20m",
                               "10-20ms", "Perimeter guarding"),
  `Body Detection (40mm+)` = c("40mm+ beam spacing", "900-2000mm", "0.5-30m",
                                "15-30ms", "Area access detection")
)

lc_specs %>%
  kable(format = "html", caption = "Light Curtain Specifications by Application") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#F39C12", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

### Laser Area Scanners

**Laser area scanners** use LiDAR technology to monitor a 2D plane. They are highly flexible and allow for programmable zones.

```{r area-scanner-diagram, echo=FALSE, fig.align="center", fig.cap="Laser Area Scanner Zones", fig.width=10, fig.height=8}
# Create polar plot for scanner zones
angles <- seq(0, 270, length.out = 100)
warning_r <- 3
safety_r <- 2

# Convert to cartesian
warning_x <- warning_r * cos(angles * pi / 180)
warning_y <- warning_r * sin(angles * pi / 180)
safety_x <- safety_r * cos(angles * pi / 180)
safety_y <- safety_r * sin(angles * pi / 180)

ggplot() +
  # Warning zone (outer)
  annotate("polygon",
           x = c(0, warning_x, 0),
           y = c(0, warning_y, 0),
           fill = "#F39C12", alpha = 0.4) +
  # Safety zone (inner)
  annotate("polygon",
           x = c(0, safety_x, 0),
           y = c(0, safety_y, 0),
           fill = "#E74C3C", alpha = 0.4) +
  # Scanner unit
  annotate("point", x = 0, y = 0, size = 8, color = "#2C3E50") +
  annotate("text", x = 0, y = -0.5, label = "Scanner", fontface = "bold", size = 3) +
  # Zone labels
  annotate("text", x = 2.5, y = 2.5, label = "WARNING ZONE\n(Machine slows/alarms)",
           color = "#F39C12", fontface = "bold", size = 3.5) +
  annotate("text", x = 1.2, y = 1.2, label = "SAFETY ZONE\n(Machine stops)",
           color = "#E74C3C", fontface = "bold", size = 3.5) +
  # Machine
  annotate("rect", xmin = -2, xmax = 0, ymin = -2, ymax = 0,
           fill = "#95A5A6", color = "black") +
  annotate("text", x = -1, y = -1, label = "Machine", fontface = "bold", size = 4, color = "white") +
  # Person approaching
  annotate("point", x = 2.5, y = 0.5, size = 10, color = "#3498DB") +
  annotate("text", x = 2.5, y = 0.5, label = "O", size = 5, color = "white") +
  annotate("text", x = 2.5, y = -0.2, label = "Worker", size = 3) +
  # Scan lines
  annotate("segment", x = 0, xend = 2.5, y = 0, yend = 2.5,
           linetype = "dotted", color = "#2C3E50", alpha = 0.5) +
  annotate("segment", x = 0, xend = 3, y = 0, yend = 0,
           linetype = "dotted", color = "#2C3E50", alpha = 0.5) +
  annotate("segment", x = 0, xend = 0, y = 0, yend = 3,
           linetype = "dotted", color = "#2C3E50", alpha = 0.5) +
  theme_void() +
  coord_fixed() +
  labs(title = "Laser Area Scanner: Programmable Safety Zones",
       subtitle = "270° scanning field with configurable warning and safety zones") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-3, 4) + ylim(-2.5, 4)
```

```{r scanner-comparison, echo=FALSE}
scanner_compare <- tibble(
  `Feature` = c("Detection Type", "Flexibility", "Zone Configuration",
                "Cost", "Best Use Case", "Environmental Limits"),
  `Light Curtains` = c("Vertical/Linear Barrier", "Fixed installation",
                       "Single detection plane", "Generally lower ($1,000-5,000)",
                       "Clear entry/exit points, press brakes",
                       "Dust/debris can cause false trips"),
  `Area Scanners` = c("Horizontal/Area Coverage", "Programmable zones",
                      "Multiple warning + safety zones", "Higher ($3,000-10,000)",
                      "Large open floors, AGV paths, flexible cells",
                      "More tolerant of dust, outdoor rated available")
)

scanner_compare %>%
  kable(format = "html", caption = "Light Curtains vs. Area Scanners") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Pressure-Sensitive Safety Mats

**Pressure-sensitive mats** detect the presence of a person standing on them. They are used primarily in legacy systems or specific zones where optical sensors may be obscured.

```{r pressure-mat-diagram, echo=FALSE, fig.align="center", fig.cap="Pressure-Sensitive Safety Mat Construction", fig.width=9, fig.height=5}
ggplot() +
  # Mat cross-section
  annotate("rect", xmin = 0, xmax = 8, ymin = 0, ymax = 0.3,
           fill = "#7F8C8D", color = "black") +
  annotate("text", x = 4, y = 0.15, label = "Bottom plate (conductive)",
           size = 3, color = "white") +
  annotate("rect", xmin = 0, xmax = 8, ymin = 0.3, ymax = 0.5,
           fill = "#2ECC71", color = "black") +
  annotate("text", x = 4, y = 0.4, label = "Spacer layer (normally open)",
           size = 3, color = "white") +
  annotate("rect", xmin = 0, xmax = 8, ymin = 0.5, ymax = 0.8,
           fill = "#7F8C8D", color = "black") +
  annotate("text", x = 4, y = 0.65, label = "Top plate (conductive)",
           size = 3, color = "white") +
  annotate("rect", xmin = 0, xmax = 8, ymin = 0.8, ymax = 1,
           fill = "#34495E", color = "black") +
  annotate("text", x = 4, y = 0.9, label = "Protective cover (rubber)",
           size = 3, color = "white") +
  # Person standing
  annotate("point", x = 6, y = 1.5, size = 12, color = "#3498DB") +
  annotate("segment", x = 6, xend = 6, y = 1.3, yend = 1.0,
           size = 2, color = "#3498DB") +
  # Compression
  annotate("segment", x = 5.5, xend = 6.5, y = 1.1, yend = 1.1,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), color = "#E74C3C") +
  annotate("text", x = 6, y = 1.2, label = "Pressure", size = 3, color = "#E74C3C") +
  # Connection to controller
  annotate("rect", xmin = -1.5, xmax = -0.5, ymin = 0.2, ymax = 0.6,
           fill = "#2ECC71", color = "black") +
  annotate("text", x = -1, y = 0.4, label = "Safety\nRelay", size = 2.5) +
  annotate("segment", x = 0, xend = -0.5, y = 0.4, yend = 0.4,
           linetype = "dashed", color = "#2C3E50") +
  theme_void() +
  labs(title = "Pressure-Sensitive Safety Mat",
       subtitle = "When stepped on, conductive plates make contact and complete the circuit") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(-0.3, 2)
```

<details>
<summary>When to Use Pressure Mats vs. Optical Sensors</summary>

**Use Pressure Mats When:**
- Environment has heavy dust, smoke, or steam (blinds optical sensors)
- Detection area is well-defined and doesn't change
- Workers need to stand in a specific location
- Budget is limited

**Use Optical Sensors When:**
- Flexibility in zone configuration is needed
- Environment is relatively clean
- Detection area is large or needs to change
- Higher integrity level is required

**Hybrid Approach:** Many modern systems use both — area scanners for perimeter protection and pressure mats for specific danger zones near the machine.

</details>

------------------------------------------------------------------------

## Control-Actuated Safety Devices

These devices ensure that the operator's body—specifically their hands—is in a predetermined **safe location** before the machine can cycle.

### Two-Hand Controls

**Two-hand controls** are common in pressing or stamping operations. To initiate a cycle, the operator must press two buttons simultaneously.

```{r two-hand-diagram, echo=FALSE, fig.align="center", fig.cap="Two-Hand Control System", fig.width=10, fig.height=6}
ggplot() +
  # Control panel
  annotate("rect", xmin = 2, xmax = 6, ymin = 0, ymax = 2,
           fill = "#F1C40F", color = "black", size = 1.5) +
  # Buttons
  annotate("point", x = 3, y = 1, size = 15, color = "#E74C3C") +
  annotate("point", x = 5, y = 1, size = 15, color = "#E74C3C") +
  annotate("text", x = 3, y = 1, label = "L", color = "white", fontface = "bold", size = 5) +
  annotate("text", x = 5, y = 1, label = "R", color = "white", fontface = "bold", size = 5) +
  # Hands
  annotate("point", x = 3, y = 2.5, size = 12, color = "#E67E22") +
  annotate("point", x = 5, y = 2.5, size = 12, color = "#E67E22") +
  annotate("text", x = 3, y = 2.5, label = "L", size = 4, color = "white") +
  annotate("text", x = 5, y = 2.5, label = "R", size = 4, color = "white") +
  # Arrows showing press
  annotate("segment", x = 3, xend = 3, y = 2.2, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  annotate("segment", x = 5, xend = 5, y = 2.2, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  # Machine
  annotate("rect", xmin = 1, xmax = 7, ymin = -2.5, ymax = -0.5,
           fill = "#95A5A6", color = "black") +
  annotate("text", x = 4, y = -1.5, label = "PRESS", fontface = "bold", size = 5) +
  # Time requirement
  annotate("rect", xmin = 0, xmax = 2.5, ymin = 2.5, ymax = 4,
           fill = "#D5F5E3", color = "#27AE60") +
  annotate("text", x = 1.25, y = 3.25,
           label = "Both buttons\npressed within\n0.5 seconds",
           size = 3, lineheight = 0.9) +
  # Safety note
  annotate("rect", xmin = 5.5, xmax = 8, ymin = 2.5, ymax = 4,
           fill = "#FADBD8", color = "#E74C3C") +
  annotate("text", x = 6.75, y = 3.25,
           label = "Anti-tie-down\nprevents\nbypassing",
           size = 3, lineheight = 0.9) +
  theme_void() +
  labs(title = "Two-Hand Control: Both Hands Must Be on Buttons",
       subtitle = "Ensures operator's hands are away from the danger zone during machine cycle") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(-3, 4.5)
```

> **Anti-Tie-Down Requirement:** Modern systems require both buttons to be pressed within **0.5 seconds** of each other. This prevents operators from taping one button down to work with one hand.

```{r two-hand-requirements, echo=FALSE}
two_hand_req <- tibble(
  `Requirement` = c("Synchronous activation", "Continuous pressure",
                    "Release before restart", "Button spacing",
                    "Guards around buttons"),
  `Standard Value` = c("Within 0.5 seconds", "Must be held throughout cycle",
                       "Both must be released before next cycle",
                       "Minimum 260mm (10 inches) apart",
                       "Prevent accidental activation"),
  `Purpose` = c("Prevents one-hand operation", "Ensures hands stay on controls",
                "Prevents automatic cycling", "Cannot press both with one hand/arm",
                "Prevents hip, elbow, or object activation")
)

two_hand_req %>%
  kable(format = "html", caption = "Two-Hand Control Requirements") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Enable/Deadman Switches

**Enable switches** (also called deadman switches) are used during **Teach Mode** for robotics. The operator must hold a three-position trigger in the **middle** position.

```{r enable-switch-diagram, echo=FALSE, fig.align="center", fig.cap="Three-Position Enable Switch Operation", fig.width=10, fig.height=5}
ggplot() +
  # Position 1 - Released
  annotate("rect", xmin = 0, xmax = 2.5, ymin = 0, ymax = 3,
           fill = "#FADBD8", color = "#E74C3C", size = 1) +
  annotate("text", x = 1.25, y = 2.5, label = "Position 1\nRELEASED",
           fontface = "bold", size = 3.5) +
  annotate("text", x = 1.25, y = 1.5, label = "Robot\nSTOPS",
           size = 4, color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 1.25, y = 0.5, label = "Panic response:\nlet go = stop",
           size = 2.5, fontface = "italic") +
  # Position 2 - Middle
  annotate("rect", xmin = 3, xmax = 5.5, ymin = 0, ymax = 3,
           fill = "#D5F5E3", color = "#27AE60", size = 1) +
  annotate("text", x = 4.25, y = 2.5, label = "Position 2\nMIDDLE",
           fontface = "bold", size = 3.5) +
  annotate("text", x = 4.25, y = 1.5, label = "Robot\nENABLED",
           size = 4, color = "#27AE60", fontface = "bold") +
  annotate("text", x = 4.25, y = 0.5, label = "Active hold:\ncontrolled operation",
           size = 2.5, fontface = "italic") +
  # Position 3 - Fully pressed
  annotate("rect", xmin = 6, xmax = 8.5, ymin = 0, ymax = 3,
           fill = "#FADBD8", color = "#E74C3C", size = 1) +
  annotate("text", x = 7.25, y = 2.5, label = "Position 3\nFULLY PRESSED",
           fontface = "bold", size = 3.5) +
  annotate("text", x = 7.25, y = 1.5, label = "Robot\nSTOPS",
           size = 4, color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 7.25, y = 0.5, label = "Startle response:\nsqueeze = stop",
           size = 2.5, fontface = "italic") +
  # Arrows
  annotate("segment", x = 2.5, xend = 3, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), size = 1) +
  annotate("segment", x = 5.5, xend = 6, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), size = 1) +
  theme_void() +
  labs(title = "Three-Position Enable Switch",
       subtitle = "Only the middle position allows robot motion") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(-0.5, 3.5)
```

<details>
<summary>Why Three Positions?</summary>

The three-position design accounts for **two natural human reactions** to danger:

1. **Panic (Release):** When frightened, people often release what they're holding — robot stops.
2. **Startle (Squeeze):** When startled, people often grip tighter — robot stops.

Only a deliberate, controlled **middle hold** allows the robot to move. This is fundamental to safe teach pendant operation.

</details>

------------------------------------------------------------------------

## Collaborative Robotics (Cobots)

**Collaborative robots (cobots)** represent a shift from "separation" to "collaboration." They rely on sophisticated internal sensors rather than external cages, allowing humans and robots to work in the same space.

```{r cobot-comparison-guarding, echo=FALSE, fig.align="center", fig.cap="Traditional Robot vs. Collaborative Robot", fig.width=10, fig.height=6}
ggplot() +
  # Traditional Robot
  annotate("rect", xmin = 0, xmax = 4, ymin = 0, ymax = 5,
           fill = "#ECF0F1", color = "black") +
  annotate("text", x = 2, y = 5.3, label = "TRADITIONAL ROBOT",
           fontface = "bold", size = 4) +
  # Cage
  annotate("rect", xmin = 0.3, xmax = 3.7, ymin = 0.3, ymax = 4.7,
           fill = NA, color = "#E74C3C", size = 1.5, linetype = "dashed") +
  annotate("text", x = 2, y = 4.3, label = "Safety Cage", color = "#E74C3C", size = 3) +
  # Robot
  annotate("point", x = 2, y = 2, size = 20, color = "#3498DB") +
  annotate("text", x = 2, y = 2, label = "Robot", color = "white", size = 3) +
  # Worker outside
  annotate("point", x = 0, y = 2.5, size = 10, color = "#27AE60") +
  annotate("text", x = -0.5, y = 2.5, label = "Worker\n(Outside)", size = 2.5) +

  # Collaborative Robot
  annotate("rect", xmin = 5.5, xmax = 9.5, ymin = 0, ymax = 5,
           fill = "#D5F5E3", color = "black") +
  annotate("text", x = 7.5, y = 5.3, label = "COLLABORATIVE ROBOT",
           fontface = "bold", size = 4) +
  # No cage - open workspace
  # Robot
  annotate("point", x = 7.5, y = 2.5, size = 20, color = "#2ECC71") +
  annotate("text", x = 7.5, y = 2.5, label = "Cobot", color = "white", size = 3) +
  # Worker beside robot
  annotate("point", x = 6.3, y = 2.5, size = 10, color = "#3498DB") +
  annotate("text", x = 5.8, y = 2.5, label = "Worker\n(Beside)", size = 2.5) +
  # Force sensors indication
  annotate("segment", x = 7.5, xend = 6.5, y = 2.5, yend = 2.5,
           arrow = arrow(length = unit(0.1, "cm"), ends = "both"),
           color = "#F39C12", size = 1.5) +
  annotate("text", x = 7, y = 3, label = "Force\nLimited", size = 2.5, color = "#F39C12") +
  theme_void() +
  labs(title = "Traditional vs. Collaborative Robots",
       subtitle = "Cobots enable human-robot collaboration without physical barriers") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-1, 10)
```

### Collaborative Operation Methods

ISO 10218 and ISO/TS 15066 define **four methods** for safe collaborative operation:

```{r cobot-methods, echo=FALSE}
cobot_methods <- tibble(
  `Method` = c("**Safety-Rated Monitored Stop**",
               "**Hand Guiding**",
               "**Speed and Separation Monitoring**",
               "**Power and Force Limiting**"),
  `How It Works` = c("Robot stops when human enters workspace, resumes when clear",
                     "Operator physically guides robot through motions",
                     "Robot slows or stops based on human proximity",
                     "Robot limits force/power to safe levels on contact"),
  `Sensors Used` = c("Area scanners, light curtains",
                     "Force/torque sensors in joints",
                     "Area scanners, radar, cameras",
                     "Joint torque sensors"),
  `Application` = c("Large robot needing occasional access",
                    "Teaching, positioning",
                    "Shared workspace with varying proximity",
                    "Direct contact applications")
)

cobot_methods %>%
  kable(format = "html", caption = "Four Methods of Collaborative Robot Operation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2ECC71", color = "white") %>%
  column_spec(1, bold = TRUE, width = "15em")
```

### Power and Force Limiting (PFL)

The most common cobot safety method is **Power and Force Limiting**. The robot detects a change in torque in its joints. If it bumps into a human, it stops before a regulated amount of force is exceeded.

```{r pfl-limits, echo=FALSE}
pfl_limits <- tibble(
  `Body Region` = c("Skull/Forehead", "Face", "Neck", "Back/Shoulders",
                    "Chest", "Abdomen", "Hand/Fingers"),
  `Maximum Pressure (N/cm²)` = c(130, 65, 145, 210, 140, 110, 300),
  `Maximum Force (N)` = c(130, 65, 150, 210, 140, 110, 140),
  `Risk Level` = c("Critical", "Critical", "Critical", "Moderate",
                   "Moderate", "Moderate", "Lower")
)

pfl_limits %>%
  kable(format = "html", caption = "ISO/TS 15066 Biomechanical Limits (Quasi-static contact)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  row_spec(1:3, background = "#FADBD8") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

<details>
<summary>Discussion: Are Cobots Always Safe?</summary>

**Common Misconception:** "Cobots are safe, so we don't need to do a risk assessment."

**Reality:** Cobots are *potentially* safe, but a **risk assessment is always required**.

**Factors that can make a cobot unsafe:**

1. **End-of-arm tooling** — A soft gripper is different from a sharp blade
2. **Workpiece** — Carrying a heavy or sharp object increases risk
3. **Speed** — Even force-limited robots can cause injury at high speed
4. **Application** — Some tasks bring humans closer to hazards
5. **Environment** — Slippery floors, confined spaces, etc.

> **Every collaborative application requires a documented risk assessment per ISO 12100.**

</details>

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/u48fm391FGk"
    title="Collaborative Robot Safety Explained"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## Safety Distance Calculation

A safety device cannot be placed arbitrarily. It must be far enough away that the machine comes to a **complete halt** before the human can reach the hazard.

### The Safety Distance Formula

The minimum safety distance $S$ is calculated as:

$$S = (K \times T) + C$$

Where:

- **$K$**: The hand/body approach speed (standardized values)
- **$T$**: The total stopping time of the system (device response + machine stop time)
- **$C$**: The "penetration depth" (how far a hand can reach through before being detected)

```{r safety-distance-viz, echo=FALSE, fig.align="center", fig.cap="Safety Distance Components", fig.width=10, fig.height=5}
ggplot() +
  # Light curtain
  annotate("rect", xmin = 0, xmax = 0.3, ymin = 0, ymax = 4,
           fill = "#F39C12", color = "black") +
  annotate("text", x = 0.15, y = 4.3, label = "Light\nCurtain", size = 3) +
  # Machine/hazard
  annotate("rect", xmin = 5.5, xmax = 8, ymin = 0.5, ymax = 3.5,
           fill = "#E74C3C", color = "black") +
  annotate("text", x = 6.75, y = 2, label = "HAZARD\nZONE",
           fontface = "bold", size = 4, color = "white") +
  # Safety distance arrow
  annotate("segment", x = 0.3, xend = 5.5, y = -0.5, yend = -0.5,
           arrow = arrow(length = unit(0.2, "cm"), ends = "both"),
           color = "#3498DB", size = 1.5) +
  annotate("text", x = 2.9, y = -1, label = "S = Safety Distance",
           fontface = "bold", size = 4, color = "#3498DB") +
  # C - penetration depth
  annotate("segment", x = -0.5, xend = 0.3, y = 2, yend = 2,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"),
           color = "#9B59B6", size = 1) +
  annotate("text", x = -0.1, y = 2.5, label = "C",
           fontface = "bold", size = 4, color = "#9B59B6") +
  # Human approach
  annotate("point", x = -1.5, y = 2, size = 15, color = "#27AE60") +
  annotate("text", x = -1.5, y = 2, label = "O", size = 5, color = "white") +
  annotate("segment", x = -1, xend = 0, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm")), color = "#27AE60", size = 1) +
  annotate("text", x = -0.5, y = 1.5, label = "K (approach\nspeed)",
           size = 3, color = "#27AE60") +
  # Formula box
  annotate("rect", xmin = 2, xmax = 5, ymin = 4.2, ymax = 5.2,
           fill = "#D6EAF8", color = "#3498DB") +
  annotate("text", x = 3.5, y = 4.7, label = "S = (K × T) + C",
           fontface = "bold", size = 5) +
  theme_void() +
  labs(title = "Safety Distance: Ensuring Time to Stop",
       subtitle = "The device must be far enough that the machine stops before the person reaches the hazard") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-2.5, 8.5) + ylim(-1.5, 5.5)
```

### Standard Values for K

```{r k-values, echo=FALSE}
k_values <- tibble(
  `Approach Type` = c("Hand/Arm Approach (fast)", "Hand/Arm Approach (normal)",
                      "Walking Approach", "Standing Reach"),
  `K Value (mm/s)` = c("2000", "1600", "1600", "0 (static)"),
  `When to Use` = c("Close approach to point of operation",
                    "General approach to machines",
                    "Area access detection",
                    "Worker already in position")
)

k_values %>%
  kable(format = "html", caption = "Standard Approach Speed Values (ISO 13855)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  column_spec(1, bold = TRUE, width = "15em")
```

### Penetration Depth (C)

The penetration depth depends on the **resolution** of the sensing device:

```{r c-values, echo=FALSE}
c_values <- tibble(
  `Resolution (mm)` = c("≤14", ">14 to ≤20", ">20 to ≤30", ">30 to ≤40", ">40"),
  `C Value (mm)` = c("0", "80", "130", "240", "850"),
  `Detection Type` = c("Finger detection", "Finger/Hand", "Hand detection",
                       "Hand/Arm", "Body detection")
)

c_values %>%
  kable(format = "html", caption = "Penetration Depth Values Based on Resolution") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white")
```

### Example Calculation

```{r safety-calc-example, echo=TRUE}
# Given parameters
K <- 2000        # Approach speed (mm/s) - fast hand approach
T_device <- 0.020  # Light curtain response time (20 ms = 0.020 s)
T_machine <- 0.150 # Machine stopping time (150 ms = 0.150 s)
C <- 0           # Penetration depth for 14mm resolution

# Calculate total stopping time
T_total <- T_device + T_machine
cat("Total stopping time (T):", T_total * 1000, "ms\n")

# Calculate minimum safety distance
S <- (K * T_total) + C
cat("Minimum safety distance (S):", S, "mm\n")
cat("Minimum safety distance (S):", S / 25.4, "inches\n")

# Interpretation
cat("\n--- Interpretation ---\n")
cat("The light curtain must be at least", S, "mm from the hazard.\n")
cat("This ensures the machine stops before a person can reach the danger zone.\n")
```

<details>
<summary>Practice Problem: Calculate Safety Distance</summary>

**Given:**
- Light curtain resolution: 30mm (hand detection)
- Light curtain response time: 15ms
- Machine stopping time: 200ms
- Application: Operator hand approach

**Calculate the minimum safety distance.**

**Solution:**
```
K = 1600 mm/s (normal hand approach)
T = 0.015 + 0.200 = 0.215 seconds
C = 130 mm (for 30mm resolution)

S = (K × T) + C
S = (1600 × 0.215) + 130
S = 344 + 130
S = 474 mm (approximately 18.7 inches)
```

The light curtain must be installed at least **474mm** from the nearest hazard point.

</details>

------------------------------------------------------------------------

## Emergency Stop (E-Stop) Systems

The **Emergency Stop** is the "last resort" — it is not a safety device but a **complementary protective measure**. It must be available to stop the machine when all other measures have failed.

```{r estop-design, echo=FALSE, fig.align="center", fig.cap="E-Stop Design Requirements", fig.width=10, fig.height=6}
ggplot() +
  # E-Stop button
  annotate("rect", xmin = 3, xmax = 7, ymin = 1, ymax = 5,
           fill = "#F1C40F", color = "black", size = 2) +
  annotate("point", x = 5, y = 3, size = 40, color = "#E74C3C") +
  annotate("text", x = 5, y = 3, label = "STOP",
           fontface = "bold", size = 6, color = "white") +
  # Requirements callouts
  # Red mushroom head
  annotate("segment", x = 5.8, xend = 8, y = 3.5, yend = 4.5, color = "#2C3E50") +
  annotate("label", x = 8.5, y = 4.5, label = "Red mushroom head\n(palm-operated)",
           size = 3, fill = "#D5F5E3") +
  # Yellow background
  annotate("segment", x = 6.5, xend = 8, y = 1.5, yend = 0.5, color = "#2C3E50") +
  annotate("label", x = 8.5, y = 0.5, label = "Yellow background\n(high contrast)",
           size = 3, fill = "#FEF9E7") +
  # Self-latching
  annotate("segment", x = 3.5, xend = 1.5, y = 3.5, yend = 4.5, color = "#2C3E50") +
  annotate("label", x = 1, y = 4.5, label = "Self-latching\n(stays pressed)",
           size = 3, fill = "#D6EAF8") +
  # Manual reset
  annotate("segment", x = 3.5, xend = 1.5, y = 2.5, yend = 1.5, color = "#2C3E50") +
  annotate("label", x = 1, y = 1.5, label = "Manual reset\n(twist or key)",
           size = 3, fill = "#FADBD8") +
  theme_void() +
  labs(title = "Emergency Stop Button Design Requirements",
       subtitle = "IEC 60204-1 / NFPA 79 Standards") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

```{r estop-requirements, echo=FALSE}
estop_req <- tibble(
  `Requirement` = c("Color", "Shape", "Background", "Operation", "Reset",
                    "Accessibility", "Wiring", "Function"),
  `Standard` = c("Red (RAL 3000 or equivalent)",
                 "Mushroom head (palm or fist operated)",
                 "Yellow (high contrast)",
                 "Self-latching (stays activated when pressed)",
                 "Manual reset required (twist, pull, or key)",
                 "Within easy reach of all operators",
                 "Normally closed contacts (fail-safe)",
                 "Category 0 or Category 1 stop")
)

estop_req %>%
  kable(format = "html", caption = "E-Stop Requirements per IEC 60204-1") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

### E-Stop Pull Cords

For long conveyors or machines where an operator cannot quickly reach a fixed button, **pull cords** provide continuous E-Stop coverage.

```{r pull-cord-diagram, echo=FALSE, fig.align="center", fig.cap="E-Stop Pull Cord System", fig.width=10, fig.height=4}
ggplot() +
  # Conveyor representation
  annotate("rect", xmin = 0, xmax = 10, ymin = 0.8, ymax = 1.2,
           fill = "#95A5A6", color = "black") +
  annotate("text", x = 5, y = 1, label = "CONVEYOR", size = 3, color = "white") +
  # Pull cord
  annotate("segment", x = 0.5, xend = 9.5, y = 2, yend = 2,
           color = "#E74C3C", size = 2) +
  # Switches at ends
  annotate("rect", xmin = 0.2, xmax = 0.8, ymin = 1.7, ymax = 2.3,
           fill = "#F1C40F", color = "black") +
  annotate("rect", xmin = 9.2, xmax = 9.8, ymin = 1.7, ymax = 2.3,
           fill = "#F1C40F", color = "black") +
  # Pull indication
  annotate("segment", x = 5, xend = 5, y = 2, yend = 2.8,
           arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  annotate("text", x = 5, y = 3.1, label = "Pull from\nanywhere", size = 3) +
  # Worker positions
  annotate("point", x = c(2, 5, 8), y = rep(0.3, 3), size = 8, color = "#3498DB") +
  annotate("text", x = c(2, 5, 8), y = rep(-0.2, 3), label = "Worker", size = 2.5) +
  theme_void() +
  labs(title = "E-Stop Pull Cord: Full-Length Coverage",
       subtitle = "Worker can trigger emergency stop from any position along the conveyor") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(-0.5, 3.5)
```

<details>
<summary>Common E-Stop Mistakes</summary>

**Mistake 1: Using E-Stop for normal stopping**
- E-Stops are for emergencies only
- Normal stops should use a separate control
- Frequent E-Stop use causes wear and desensitizes operators

**Mistake 2: E-Stop that doesn't stop everything**
- All hazardous motion must stop
- Auxiliary equipment (conveyors, feeders) often forgotten
- Review entire system, not just the primary machine

**Mistake 3: Automatic restart after E-Stop reset**
- Machine must NOT automatically restart when E-Stop is released
- Separate "Start" action required
- This prevents unexpected motion after reset

**Mistake 4: Hidden or blocked E-Stops**
- E-Stops must be visible and accessible
- Guard placement sometimes blocks access
- Regular audits needed to ensure accessibility

</details>

------------------------------------------------------------------------

## Functional Safety Standards

Modern safety systems must meet specific **performance levels** to ensure reliability. Two main frameworks exist:

### Safety Integrity Levels (SIL) - IEC 62061

```{r sil-levels, echo=FALSE}
sil_data <- tibble(
  `SIL Level` = c("SIL 1", "SIL 2", "SIL 3"),
  `PFH Range` = c("≥10⁻⁶ to <10⁻⁵", "≥10⁻⁷ to <10⁻⁶", "≥10⁻⁸ to <10⁻⁷"),
  `Approximate Meaning` = c("Dangerous failure less than once per 11 years",
                             "Dangerous failure less than once per 114 years",
                             "Dangerous failure less than once per 1,140 years"),
  `Typical Application` = c("Low-risk tasks", "Most industrial machinery", "High-risk processes")
)

sil_data %>%
  kable(format = "html", caption = "Safety Integrity Levels (PFH = Probability of Dangerous Failure per Hour)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3, background = "#FADBD8") %>%
  column_spec(1, bold = TRUE)
```

### Performance Levels (PL) - ISO 13849-1

```{r pl-levels, echo=FALSE}
pl_data <- tibble(
  `Performance Level` = c("PL a", "PL b", "PL c", "PL d", "PL e"),
  `PFH Range` = c("≥10⁻⁵ to <10⁻⁴", "≥3×10⁻⁶ to <10⁻⁵",
                  "≥10⁻⁶ to <3×10⁻⁶", "≥10⁻⁷ to <10⁻⁶", "≥10⁻⁸ to <10⁻⁷"),
  `Risk Reduction` = c("Lowest", "Low", "Medium", "High", "Highest"),
  `Equivalent SIL` = c("< SIL 1", "SIL 1", "SIL 1", "SIL 2", "SIL 3")
)

pl_data %>%
  kable(format = "html", caption = "Performance Levels per ISO 13849-1") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  column_spec(1, bold = TRUE)
```

```{r sil-pl-relationship, echo=FALSE, fig.align="center", fig.cap="Relationship Between SIL and PL", fig.width=8, fig.height=5}
rel_data <- data.frame(
  x = c(1, 2, 3, 4, 5),
  pl = c("PL a", "PL b", "PL c", "PL d", "PL e"),
  sil = c(0.5, 1, 1, 2, 3),
  color = c("#D5F5E3", "#D5F5E3", "#FEF9E7", "#FEF9E7", "#FADBD8")
)

ggplot(rel_data, aes(x = x, y = sil)) +
  geom_bar(stat = "identity", fill = rel_data$color, color = "black", width = 0.8) +
  geom_text(aes(label = pl), vjust = -0.5, fontface = "bold", size = 4) +
  geom_hline(yintercept = c(1, 2, 3), linetype = "dashed", color = "#7F8C8D") +
  annotate("text", x = 5.5, y = 1, label = "SIL 1", hjust = 0, size = 3) +
  annotate("text", x = 5.5, y = 2, label = "SIL 2", hjust = 0, size = 3) +
  annotate("text", x = 5.5, y = 3, label = "SIL 3", hjust = 0, size = 3) +
  scale_y_continuous(breaks = 0:3, limits = c(0, 3.5)) +
  scale_x_continuous(breaks = 1:5, labels = rel_data$pl) +
  labs(title = "Performance Level to SIL Equivalence",
       x = "Performance Level (ISO 13849-1)",
       y = "Approximate SIL Equivalent") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    panel.grid.minor = element_blank()
  )
```

<details>
<summary>Which Standard to Use: SIL or PL?</summary>

**Use ISO 13849-1 (Performance Levels) when:**
- Designing safety functions for standard machinery
- Using off-the-shelf safety components
- Simpler systems with well-defined safety functions

**Use IEC 62061 (SIL) when:**
- Complex programmable systems (safety PLCs)
- Process industries
- When customer or regulation specifies SIL

**Note:** Many modern systems use both standards, as they are harmonized and can be used together. The choice often depends on industry practice and customer requirements.

</details>

------------------------------------------------------------------------

## Risk Assessment Process

Before selecting any safety device, a **risk assessment** must be performed. This is required by ISO 12100.

```{r risk-assessment-process, echo=FALSE, fig.align="center", fig.cap="Risk Assessment Process (ISO 12100)", fig.width=10, fig.height=7}
steps <- data.frame(
  step = 1:5,
  label = c("Determine\nLimits", "Identify\nHazards", "Estimate\nRisk",
            "Evaluate\nRisk", "Reduce\nRisk"),
  y = 5:1
)

ggplot(steps, aes(x = 3, y = y)) +
  # Step boxes
  geom_tile(width = 4, height = 0.8, fill = "#3498DB", color = "black") +
  geom_text(aes(label = paste0("Step ", step, ": ", label)),
            color = "white", fontface = "bold", size = 4, lineheight = 0.8) +
  # Arrows
  geom_segment(data = steps[1:4,], aes(x = 3, xend = 3, y = y - 0.5, yend = y - 0.9),
               arrow = arrow(length = unit(0.2, "cm")), color = "#2C3E50", size = 1) +
  # Iteration arrow
  annotate("curve", x = 5.5, xend = 5.5, y = 1, yend = 5,
           curvature = 0.3, arrow = arrow(length = unit(0.2, "cm")),
           color = "#E74C3C", size = 1) +
  annotate("text", x = 6.2, y = 3, label = "Iterate until\nrisk is\nacceptable",
           size = 3, color = "#E74C3C", hjust = 0, lineheight = 0.9) +
  # Side descriptions
  annotate("text", x = 0.3, y = 5, label = "Machine function,\noperator tasks,\nenvironment",
           size = 2.5, hjust = 1, lineheight = 0.9) +
  annotate("text", x = 0.3, y = 4, label = "All hazards\nthroughout\nlifecycle",
           size = 2.5, hjust = 1, lineheight = 0.9) +
  annotate("text", x = 0.3, y = 3, label = "Severity ×\nProbability ×\nExposure",
           size = 2.5, hjust = 1, lineheight = 0.9) +
  annotate("text", x = 0.3, y = 2, label = "Is risk\nacceptable?",
           size = 2.5, hjust = 1, lineheight = 0.9) +
  annotate("text", x = 0.3, y = 1, label = "Apply hierarchy\nof controls",
           size = 2.5, hjust = 1, lineheight = 0.9) +
  theme_void() +
  labs(title = "Risk Assessment Process",
       subtitle = "Systematic approach to identifying and reducing machine hazards") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-0.5, 7)
```

### Risk Estimation

Risk is typically estimated using three factors:

```{r risk-matrix, echo=FALSE, fig.align="center", fig.cap="Risk Estimation Matrix", fig.width=9, fig.height=6}
# Create risk matrix
risk_matrix <- expand.grid(
  Severity = c("Minor", "Moderate", "Serious", "Fatal"),
  Probability = c("Remote", "Unlikely", "Possible", "Probable")
)
risk_matrix$Risk <- c(
  "Low", "Low", "Medium", "Medium",
  "Low", "Medium", "Medium", "High",
  "Medium", "Medium", "High", "High",
  "Medium", "High", "High", "Critical"
)
risk_matrix$RiskNum <- c(1,1,2,2, 1,2,2,3, 2,2,3,3, 2,3,3,4)

ggplot(risk_matrix, aes(x = Probability, y = Severity, fill = Risk)) +
  geom_tile(color = "white", size = 1.5) +
  geom_text(aes(label = Risk), fontface = "bold", size = 4) +
  scale_fill_manual(values = c("Low" = "#27AE60", "Medium" = "#F39C12",
                               "High" = "#E74C3C", "Critical" = "#8E44AD")) +
  scale_x_discrete(limits = c("Remote", "Unlikely", "Possible", "Probable"),
                   position = "top") +
  scale_y_discrete(limits = c("Minor", "Moderate", "Serious", "Fatal")) +
  labs(title = "Risk Assessment Matrix",
       x = "Probability of Occurrence",
       y = "Severity of Harm") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "bottom",
    axis.text = element_text(size = 10, face = "bold"),
    panel.grid = element_blank()
  )
```

------------------------------------------------------------------------

## Summary

```{r summary-table-ch6, echo=FALSE}
summary_data <- tibble(
  `Topic` = c("**Hierarchy of Controls**", "**Physical Guarding**", "**Presence Sensing**",
              "**Control-Actuated Devices**", "**Collaborative Robots**",
              "**Safety Distance**", "**E-Stop Systems**", "**Functional Safety**"),
  `Key Points` = c("Elimination > Substitution > Engineering > Administrative > PPE",
                   "Fixed guards, interlocked gates, trapped key systems",
                   "Light curtains, area scanners, pressure mats",
                   "Two-hand controls, enable/deadman switches",
                   "PFL, speed/separation monitoring, hand guiding",
                   "S = (K × T) + C formula for device placement",
                   "Red mushroom on yellow, self-latching, manual reset",
                   "SIL (IEC 62061) and PL (ISO 13849-1) standards"),
  `Critical Remember` = c("Always start at the top of the hierarchy",
                          "Stop category (0, 1, 2) determines how machine stops",
                          "Resolution determines detection capability",
                          "Anti-tie-down prevents one-hand bypass",
                          "Risk assessment required for every cobot application",
                          "Include device response AND machine stop time",
                          "E-Stop is last resort, not normal operation",
                          "Required performance level from risk assessment")
)

summary_data %>%
  kable(format = "html", caption = "Machine Guarding and Safety: Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "15em")
```

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: What are the five levels of the Hierarchy of Controls, and why is PPE the least effective?</summary>

The five levels are (from most to least effective):

1. **Elimination** — Physically remove the hazard
2. **Substitution** — Replace with something less hazardous
3. **Engineering Controls** — Isolate people from the hazard
4. **Administrative Controls** — Change how people work
5. **PPE** — Protect the worker with equipment

**PPE is least effective because:**
- The hazard still exists
- It depends on human compliance
- Equipment can fail or be worn incorrectly
- It's the last line of defense

</details>

<details>
<summary>Question 2: A light curtain has a response time of 12ms and resolution of 14mm. The machine takes 180ms to stop. Calculate the minimum safety distance for hand approach.</summary>

**Given:**
- K = 2000 mm/s (hand approach, use higher value for safety)
- T = 0.012 + 0.180 = 0.192 seconds
- C = 0 mm (14mm resolution)

**Calculation:**
$$S = (K \times T) + C$$
$$S = (2000 \times 0.192) + 0$$
$$S = 384 \text{ mm}$$

The light curtain must be installed at least **384mm** (approximately 15 inches) from the hazard.

</details>

<details>
<summary>Question 3: Explain why a three-position enable switch stops the robot in both position 1 (released) and position 3 (fully pressed).</summary>

The three-position design accounts for two natural human reactions to danger:

**Position 1 (Released):**
- When frightened, people often release what they're holding (panic response)
- Robot stops immediately

**Position 3 (Fully Pressed):**
- When startled, people often grip tighter (startle response)
- Robot stops immediately

**Position 2 (Middle):**
- Only a deliberate, controlled hold allows operation
- Requires conscious effort to maintain
- This ensures the operator is alert and in control

</details>

<details>
<summary>Question 4: What are the four methods of collaborative robot operation according to ISO 10218?</summary>

1. **Safety-Rated Monitored Stop**
   - Robot stops when human enters workspace
   - Resumes when human leaves
   - Uses area scanners or light curtains

2. **Hand Guiding**
   - Operator physically guides robot
   - Force/torque sensors enable safe teaching

3. **Speed and Separation Monitoring**
   - Robot speed varies based on human proximity
   - Uses external sensors to track human position

4. **Power and Force Limiting (PFL)**
   - Robot limits contact force to safe levels
   - Built-in joint torque sensors
   - Most common cobot method

</details>

<details>
<summary>Question 5: What are the requirements for an E-Stop button according to IEC 60204-1?</summary>

**Physical Requirements:**
- **Color:** Red
- **Shape:** Mushroom head (palm or fist operated)
- **Background:** Yellow (high contrast)

**Functional Requirements:**
- **Self-latching:** Stays activated when pressed
- **Manual reset:** Requires deliberate action to release
- **Accessibility:** Within easy reach of all operators
- **Wiring:** Normally closed contacts (fail-safe)
- **Function:** Category 0 or Category 1 stop
- **No automatic restart:** Separate start action required after reset

</details>

------------------------------------------------------------------------

## References

- ISO 12100:2010 — Safety of machinery — General principles for design — Risk assessment and risk reduction
- ISO 13849-1:2015 — Safety of machinery — Safety-related parts of control systems
- ISO 13855:2010 — Safety of machinery — Positioning of safeguards with respect to approach speeds
- ISO 10218-1/2:2011 — Robots and robotic devices — Safety requirements for industrial robots
- ISO/TS 15066:2016 — Robots and robotic devices — Collaborative robots
- IEC 60204-1:2016 — Safety of machinery — Electrical equipment of machines
- IEC 62061:2021 — Safety of machinery — Functional safety of safety-related control systems
- OSHA 29 CFR 1910.212 — General requirements for all machines
- ANSI/RIA TR R15.306 — Task-based risk assessment methodology

------------------------------------------------------------------------

<!--chapter:end:06-Machine-Guadring-and-Safety.Rmd-->

# Ergonomics in Automated Manufacturing

------------------------------------------------------------------------

```{r setup-ch7, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Define ergonomics and explain its importance in manufacturing
- Identify the seven major ergonomic risk factors
- Recognize common musculoskeletal disorders (MSDs) and their causes
- Apply ergonomic design principles to workstation design
- Conduct a REBA (Rapid Entire Body Assessment) analysis
- Understand the role of AI and automation in ergonomic assessment
- Design workstations that optimize human performance and safety

> "Ergonomics is the science of fitting the job to the worker, not forcing the worker to fit the job."
> — International Ergonomics Association

------------------------------------------------------------------------

## What is Ergonomics?

**Ergonomics** (from Greek *ergon* = work, *nomos* = laws) is the scientific discipline focused on understanding the interactions between humans and other elements of a system, with the goal of optimizing human well-being and overall system performance.

```{r ergonomics-definition, echo=FALSE, fig.align="center", fig.cap="The Three Domains of Ergonomics", fig.width=10, fig.height=6}
# Create Venn-like diagram for ergonomics domains
ggplot() +
  # Physical domain

  annotate("point", x = 1, y = 2, size = 45, color = "#3498DB", alpha = 0.6) +
  annotate("text", x = 1, y = 2.3, label = "PHYSICAL", fontface = "bold", size = 5, color = "#2C3E50") +
  annotate("text", x = 1, y = 1.7, label = "Anatomy\nPhysiology\nBiomechanics", size = 3, lineheight = 0.9) +
  # Cognitive domain
  annotate("point", x = 3, y = 2, size = 45, color = "#E74C3C", alpha = 0.6) +
  annotate("text", x = 3, y = 2.3, label = "COGNITIVE", fontface = "bold", size = 5, color = "#2C3E50") +
  annotate("text", x = 3, y = 1.7, label = "Mental processes\nPerception\nDecision making", size = 3, lineheight = 0.9) +
  # Organizational domain
  annotate("point", x = 2, y = 0.5, size = 45, color = "#27AE60", alpha = 0.6) +
  annotate("text", x = 2, y = 0.8, label = "ORGANIZATIONAL", fontface = "bold", size = 5, color = "#2C3E50") +
  annotate("text", x = 2, y = 0.2, label = "Work systems\nTeamwork\nScheduling", size = 3, lineheight = 0.9) +
  # Center - Human
  annotate("point", x = 2, y = 1.5, size = 20, color = "#F39C12") +
  annotate("text", x = 2, y = 1.5, label = "HUMAN", fontface = "bold", size = 4, color = "white") +
  theme_void() +
  labs(title = "The Three Domains of Ergonomics",
       subtitle = "Ergonomics considers the whole human experience at work") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-0.5, 4.5) + ylim(-0.8, 3.5)
```

```{r ergonomics-domains-table, echo=FALSE}
domains <- tibble(
  `Domain` = c("**Physical Ergonomics**", "**Cognitive Ergonomics**", "**Organizational Ergonomics**"),
  `Focus` = c("Human body's response to physical stress",
              "Mental processes and human-system interaction",
              "Optimization of sociotechnical systems"),
  `Key Topics` = c("Posture, material handling, repetitive motion, workplace layout, safety",
                   "Mental workload, decision-making, human-computer interaction, training",
                   "Communication, teamwork, work schedules, quality management"),
  `Manufacturing Example` = c("Designing assembly workstations to reduce reaching",
                               "Designing HMI screens for quick comprehension",
                               "Implementing job rotation to reduce fatigue")
)

domains %>%
  kable(format = "html", caption = "The Three Domains of Ergonomics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Why Ergonomics Matters in Manufacturing

```{r why-ergonomics, echo=FALSE, fig.align="center", fig.cap="The Business Case for Ergonomics", fig.width=10, fig.height=5}
benefits <- data.frame(
  category = c("Injury Reduction", "Productivity", "Quality", "Turnover", "Absenteeism"),
  improvement = c(59, 25, 46, 48, 58),
  color = c("#E74C3C", "#3498DB", "#27AE60", "#F39C12", "#9B59B6")
)

ggplot(benefits, aes(x = reorder(category, improvement), y = improvement, fill = category)) +
  geom_bar(stat = "identity", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(improvement, "%")), hjust = -0.2, fontface = "bold", size = 4) +
  coord_flip() +
  scale_fill_manual(values = c("Injury Reduction" = "#E74C3C", "Productivity" = "#3498DB",
                               "Quality" = "#27AE60", "Turnover" = "#F39C12",
                               "Absenteeism" = "#9B59B6")) +
  scale_y_continuous(limits = c(0, 75)) +
  labs(title = "Average Improvements from Ergonomic Interventions",
       subtitle = "Based on Washington State Department of Labor studies",
       x = "", y = "Improvement (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "none",
    panel.grid.minor = element_blank()
  )
```

<details>
<summary>The Cost of Ignoring Ergonomics</summary>

**Direct Costs:**
- Workers' compensation claims
- Medical expenses
- Legal fees
- Increased insurance premiums

**Indirect Costs (often 4-10x direct costs):**
- Lost productivity
- Training replacement workers
- Reduced quality
- Overtime to cover absent workers
- Administrative time
- Low morale

**Statistics:**
- MSDs account for **33%** of all workplace injuries
- Average MSD claim costs **$15,000-$20,000**
- Lost workdays due to MSDs average **12 days** per case
- Carpal tunnel surgery costs approximately **$30,000** per case (including lost time)

</details>

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/dloyfUXjJzs"
    title="Introduction to Workplace Ergonomics"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## The Seven Ergonomic Risk Factors

The **Initial Ergonomic Risk Assessment (INERA)** identifies seven primary risk factors that contribute to musculoskeletal disorders. Understanding these factors is the first step in prevention.

```{r risk-factors-viz, echo=FALSE, fig.align="center", fig.cap="The Seven Ergonomic Risk Factors", fig.width=10, fig.height=8}
risk_factors <- data.frame(
  factor = c("Awkward\nPostures", "Repetition", "Force", "Static\nPositions",
             "Contact\nStress", "Vibration", "Environmental\nFactors"),
  risk_level = c(5, 5, 4, 4, 3, 3, 3),
  x = c(1, 2, 3, 4, 5, 6, 7),
  color = c("#E74C3C", "#E74C3C", "#F39C12", "#F39C12", "#3498DB", "#3498DB", "#3498DB")
)

ggplot(risk_factors, aes(x = x, y = risk_level, fill = factor)) +
  geom_bar(stat = "identity", color = "black", width = 0.8) +
  geom_text(aes(label = factor, y = risk_level/2), color = "white",
            fontface = "bold", size = 3.5, lineheight = 0.8) +
  scale_fill_manual(values = c("Awkward\nPostures" = "#E74C3C", "Repetition" = "#C0392B",
                               "Force" = "#F39C12", "Static\nPositions" = "#E67E22",
                               "Contact\nStress" = "#3498DB", "Vibration" = "#2980B9",
                               "Environmental\nFactors" = "#1ABC9C")) +
  scale_x_continuous(breaks = 1:7, labels = 1:7) +
  scale_y_continuous(breaks = 1:5, labels = c("Low", "", "Medium", "", "High")) +
  labs(title = "The Seven Ergonomic Risk Factors",
       subtitle = "Height indicates relative frequency of causing MSDs",
       x = "Risk Factor Number", y = "Risk Level") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "none",
    panel.grid.minor = element_blank()
  )
```

```{r risk-factors-table, echo=FALSE}
risk_detail <- tibble(
  `#` = 1:7,
  `Risk Factor` = c("**Awkward Postures**", "**Repetition**", "**Force**",
                    "**Static Positions**", "**Contact Stress**",
                    "**Vibration**", "**Environmental Factors**"),
  `Definition` = c("Positions that deviate from neutral body alignment",
                   "Performing the same motion repeatedly",
                   "Amount of physical effort required to do a task",
                   "Maintaining the same position for extended periods",
                   "Pressure from hard surfaces or edges on body tissues",
                   "Oscillating movements transferred to the body",
                   "Temperature, lighting, noise affecting work performance"),
  `Examples` = c("Bent wrist, raised arms, twisted back, kneeling",
                 "Assembly line tasks, typing, packaging",
                 "Lifting heavy objects, pushing/pulling, gripping tools",
                 "Standing in one spot, holding arms overhead",
                 "Resting wrists on desk edge, kneeling on hard floor",
                 "Power tools, driving forklifts, jackhammers",
                 "Cold environments, poor lighting, excessive noise"),
  `Body Areas Affected` = c("Back, neck, shoulders, wrists, knees",
                            "Hands, wrists, shoulders, neck",
                            "Back, shoulders, hands, arms",
                            "Legs, back, shoulders, neck",
                            "Hands, knees, forearms",
                            "Hands, arms, spine",
                            "Eyes, ears, overall fatigue")
)

risk_detail %>%
  kable(format = "html", caption = "The Seven Ergonomic Risk Factors Explained") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(1:2, background = "#FADBD8") %>%
  row_spec(3:4, background = "#FEF9E7") %>%
  row_spec(5:7, background = "#D6EAF8") %>%
  column_spec(1, bold = TRUE, width = "3em")
```

### Risk Factor 1: Awkward Postures

**Neutral posture** is the position where joints are naturally aligned, minimizing stress on muscles, tendons, and skeletal system. Any deviation from neutral increases injury risk.

```{r posture-zones, echo=FALSE, fig.align="center", fig.cap="Posture Risk Zones", fig.width=10, fig.height=6}
# Create posture zone visualization
ggplot() +
  # Green zone - Neutral
  annotate("rect", xmin = 0, xmax = 3, ymin = 0, ymax = 3, fill = "#27AE60", alpha = 0.7) +
  annotate("text", x = 1.5, y = 2.5, label = "GREEN ZONE", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 1.5, y = 1.5, label = "Neutral Posture\n\nJoints at midpoint\nBalanced muscle load\nMinimal stress",
           size = 3.5, color = "white", lineheight = 0.9) +
  # Yellow zone - Moderate
  annotate("rect", xmin = 3.5, xmax = 6.5, ymin = 0, ymax = 3, fill = "#F39C12", alpha = 0.7) +
  annotate("text", x = 5, y = 2.5, label = "YELLOW ZONE", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 5, y = 1.5, label = "Moderate Deviation\n\nJoints partially flexed\nSome muscle strain\nAcceptable briefly",
           size = 3.5, color = "white", lineheight = 0.9) +
  # Red zone - Extreme
  annotate("rect", xmin = 7, xmax = 10, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.7) +
  annotate("text", x = 8.5, y = 2.5, label = "RED ZONE", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 8.5, y = 1.5, label = "Extreme Posture\n\nJoints at end range\nHigh muscle strain\nAvoid if possible",
           size = 3.5, color = "white", lineheight = 0.9) +
  theme_void() +
  labs(title = "Posture Risk Zones: Traffic Light System",
       subtitle = "Design workstations to keep workers in the green zone") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

```{r neutral-postures, echo=FALSE}
neutral <- tibble(
  `Body Part` = c("**Head/Neck**", "**Shoulders**", "**Elbows**", "**Wrists**", "**Back**", "**Hips/Knees**"),
  `Neutral Position` = c("Balanced on spine, looking straight ahead",
                         "Relaxed, arms at sides",
                         "Close to body, bent 90-120°",
                         "Straight, in line with forearm",
                         "Natural S-curve maintained",
                         "Thighs parallel to floor, feet flat"),
  `Awkward Position` = c("Bent forward >20°, tilted, twisted",
                         "Raised, reaching overhead, behind body",
                         "Fully extended or tightly bent",
                         "Bent up/down, twisted side-to-side",
                         "Bent forward, twisted, arched",
                         "Squatting, kneeling, twisted"),
  `Risk` = c("Neck pain, headaches", "Shoulder impingement, rotator cuff",
             "Tennis elbow, golfer's elbow", "Carpal tunnel, tendinitis",
             "Low back pain, disc herniation", "Knee injuries, hip pain")
)

neutral %>%
  kable(format = "html", caption = "Neutral vs. Awkward Postures by Body Part") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em") %>%
  column_spec(3, background = "#FADBD8")
```

### Risk Factor 2: Repetition

**Repetitive motion** is one of the most significant risk factors in manufacturing. The risk increases with:

- **Frequency:** How often the motion occurs
- **Duration:** How long the task is performed
- **Recovery time:** Rest between repetitions

```{r repetition-thresholds, echo=FALSE}
repetition <- tibble(
  `Cycle Time` = c("> 30 seconds", "15-30 seconds", "< 15 seconds"),
  `Repetitions/Hour` = c("< 120", "120-240", "> 240"),
  `Risk Level` = c("Low", "Moderate", "High"),
  `Action Required` = c("Monitor", "Investigate and consider changes", "Immediate intervention needed")
)

repetition %>%
  kable(format = "html", caption = "Repetition Risk Thresholds") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#C0392B", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3, background = "#FADBD8")
```

### Risk Factor 3: Force

The amount of **physical effort** required significantly impacts injury risk. Force requirements depend on:

```{r force-factors, echo=FALSE, fig.align="center", fig.cap="Factors Affecting Force Requirements", fig.width=9, fig.height=5}
force_data <- data.frame(
  factor = c("Object Weight", "Grip Type", "Posture", "Friction", "Acceleration"),
  impact = c(5, 4, 4, 3, 3),
  example = c("Heavier = more force", "Pinch vs. power grip", "Awkward = more force",
              "Slippery = more grip", "Fast moves = more force")
)

ggplot(force_data, aes(x = reorder(factor, impact), y = impact)) +
  geom_bar(stat = "identity", fill = "#F39C12", color = "black", width = 0.7) +
  geom_text(aes(label = example), hjust = -0.1, size = 3) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 7)) +
  labs(title = "Factors That Increase Force Requirements",
       x = "", y = "Relative Impact") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    panel.grid.minor = element_blank()
  )
```

<details>
<summary>Interactive Exercise: Identify the Risk Factors</summary>

**Scenario:** An assembly line worker performs the following task 400 times per shift:

1. Reaches overhead to grab a part from a bin
2. Holds the part while inserting 4 screws with a power screwdriver
3. Places the completed assembly on a conveyor
4. The workstation has poor lighting and the floor is concrete

**Identify all risk factors present:**

**Answer:**
1. **Awkward Posture** - Reaching overhead
2. **Repetition** - 400 cycles per shift
3. **Force** - Gripping parts, controlling screwdriver
4. **Static Position** - Holding part during assembly
5. **Vibration** - Power screwdriver
6. **Contact Stress** - Standing on concrete (feet)
7. **Environmental** - Poor lighting

*This task has ALL SEVEN risk factors present!*

</details>

------------------------------------------------------------------------

## Musculoskeletal Disorders (MSDs)

**Musculoskeletal Disorders (MSDs)** are injuries and disorders affecting muscles, nerves, tendons, ligaments, joints, cartilage, and spinal discs. They are the most common and costly occupational health problem.

```{r msd-body-map, echo=FALSE, fig.align="center", fig.cap="Common MSDs by Body Region", fig.width=10, fig.height=8}
# Create body map visualization
ggplot() +
  # Body outline (simplified)
  # Head
  annotate("point", x = 5, y = 9, size = 20, color = "#F5CBA7") +
  # Neck
  annotate("rect", xmin = 4.7, xmax = 5.3, ymin = 8, ymax = 8.5, fill = "#F5CBA7") +
  # Torso
  annotate("rect", xmin = 3.5, xmax = 6.5, ymin = 4, ymax = 8, fill = "#F5CBA7") +
  # Arms
  annotate("rect", xmin = 2, xmax = 3.5, ymin = 5.5, ymax = 8, fill = "#F5CBA7") +
  annotate("rect", xmin = 6.5, xmax = 8, ymin = 5.5, ymax = 8, fill = "#F5CBA7") +
  # Forearms
  annotate("rect", xmin = 1, xmax = 2, ymin = 4, ymax = 5.5, fill = "#F5CBA7") +
  annotate("rect", xmin = 8, xmax = 9, ymin = 4, ymax = 5.5, fill = "#F5CBA7") +
  # Hands
  annotate("point", x = 1.5, y = 3.5, size = 8, color = "#F5CBA7") +
  annotate("point", x = 8.5, y = 3.5, size = 8, color = "#F5CBA7") +
  # Legs
  annotate("rect", xmin = 3.8, xmax = 4.8, ymin = 0.5, ymax = 4, fill = "#F5CBA7") +
  annotate("rect", xmin = 5.2, xmax = 6.2, ymin = 0.5, ymax = 4, fill = "#F5CBA7") +

  # MSD labels with lines
  # Neck
  annotate("point", x = 5, y = 8.2, size = 4, color = "#E74C3C") +
  annotate("segment", x = 5.3, xend = 7, y = 8.2, yend = 8.5) +
  annotate("label", x = 7.5, y = 8.5, label = "Neck:\nTension neck syndrome\nCervical radiculopathy",
           size = 2.5, hjust = 0, fill = "#FADBD8") +
  # Shoulder
  annotate("point", x = 3.5, y = 7.5, size = 4, color = "#E74C3C") +
  annotate("segment", x = 3.2, xend = 1.5, y = 7.5, yend = 7.5) +
  annotate("label", x = 0, y = 7.5, label = "Shoulder:\nRotator cuff tendinitis\nImpingement syndrome",
           size = 2.5, hjust = 0, fill = "#FADBD8") +
  # Elbow
  annotate("point", x = 2, y = 5.5, size = 4, color = "#E74C3C") +
  annotate("segment", x = 1.7, xend = 0.5, y = 5.5, yend = 5.5) +
  annotate("label", x = 0, y = 5.5, label = "Elbow:\nTennis elbow\nGolfer's elbow",
           size = 2.5, hjust = 0, fill = "#FADBD8") +
  # Wrist/Hand
  annotate("point", x = 1.5, y = 4, size = 4, color = "#E74C3C") +
  annotate("segment", x = 1.2, xend = 0.5, y = 3.5, yend = 3) +
  annotate("label", x = 0, y = 3, label = "Wrist/Hand:\nCarpal tunnel syndrome\nTendinitis\nTrigger finger",
           size = 2.5, hjust = 0, fill = "#FADBD8") +
  # Low back
  annotate("point", x = 5, y = 5, size = 4, color = "#E74C3C") +
  annotate("segment", x = 6.5, xend = 8, y = 5, yend = 5) +
  annotate("label", x = 8, y = 5, label = "Low Back:\nLumbar strain\nHerniated disc\nSciatica",
           size = 2.5, hjust = 0, fill = "#FADBD8") +
  # Knee
  annotate("point", x = 5.7, y = 2.5, size = 4, color = "#E74C3C") +
  annotate("segment", x = 6, xend = 8, y = 2.5, yend = 2.5) +
  annotate("label", x = 8, y = 2.5, label = "Knee:\nBursitis\nMeniscus injury",
           size = 2.5, hjust = 0, fill = "#FADBD8") +

  theme_void() +
  labs(title = "Common MSDs in Manufacturing",
       subtitle = "Red dots indicate high-risk body regions") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(-1, 11) + ylim(0, 10)
```

```{r msd-table, echo=FALSE}
msd_detail <- tibble(
  `Disorder` = c("**Carpal Tunnel Syndrome**", "**Tendinitis**", "**Low Back Pain**",
                 "**Rotator Cuff Injury**", "**Epicondylitis**", "**Trigger Finger**"),
  `Description` = c("Compression of median nerve in the wrist",
                    "Inflammation of tendons from overuse",
                    "Strain or injury to muscles/discs of lower back",
                    "Damage to shoulder tendons",
                    "Inflammation of elbow tendons (tennis/golfer's elbow)",
                    "Finger gets stuck in bent position"),
  `Causes` = c("Repetitive wrist motions, forceful gripping, vibration",
               "Repetitive motions, awkward postures, force",
               "Heavy lifting, bending, twisting, vibration",
               "Overhead work, repetitive shoulder motion",
               "Repetitive arm/wrist motions, forceful gripping",
               "Repetitive gripping, hand tools"),
  `Symptoms` = c("Numbness, tingling, weakness in hand",
                 "Pain, swelling, stiffness in affected area",
                 "Pain, stiffness, limited mobility",
                 "Pain, weakness, limited range of motion",
                 "Pain on outside (tennis) or inside (golfer's) of elbow",
                 "Clicking, locking of finger")
)

msd_detail %>%
  kable(format = "html", caption = "Common Musculoskeletal Disorders in Manufacturing") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### The MSD Development Cycle

MSDs typically develop gradually through a predictable cycle:

```{r msd-cycle, echo=FALSE, fig.align="center", fig.cap="The MSD Development Cycle", fig.width=10, fig.height=6}
cycle_data <- data.frame(
  stage = c("Exposure", "Fatigue", "Discomfort", "Pain", "Injury", "Disability"),
  x = c(1, 2, 3, 4, 5, 6),
  severity = c(1, 2, 3, 4, 5, 5),
  color = c("#27AE60", "#2ECC71", "#F39C12", "#E67E22", "#E74C3C", "#8E44AD"),
  recovery = c("Easy", "Easy", "Moderate", "Difficult", "Very Difficult", "May be permanent")
)

ggplot(cycle_data, aes(x = x, y = severity)) +
  geom_line(size = 2, color = "#2C3E50") +
  geom_point(aes(color = stage), size = 15) +
  geom_text(aes(label = stage), color = "white", fontface = "bold", size = 3) +
  geom_text(aes(y = severity - 0.8, label = recovery), size = 3, fontface = "italic") +
  scale_color_manual(values = c("Exposure" = "#27AE60", "Fatigue" = "#2ECC71",
                                "Discomfort" = "#F39C12", "Pain" = "#E67E22",
                                "Injury" = "#E74C3C", "Disability" = "#8E44AD")) +
  annotate("segment", x = 1, xend = 3, y = 5.5, yend = 5.5,
           arrow = arrow(length = unit(0.3, "cm"), ends = "both"), color = "#27AE60", size = 1.5) +
  annotate("text", x = 2, y = 5.8, label = "PREVENTION WINDOW", color = "#27AE60", fontface = "bold") +
  labs(title = "MSD Development: From Exposure to Disability",
       subtitle = "Early intervention is critical - recovery difficulty increases at each stage",
       x = "Progression", y = "Severity") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "none",
    axis.text.x = element_blank(),
    panel.grid = element_blank()
  )
```

<details>
<summary>Warning Signs: When to Take Action</summary>

**Early Warning Signs (Act Immediately):**
- Persistent fatigue in specific body parts
- Discomfort during or after work
- Tightness or stiffness
- Minor aching or soreness

**Serious Warning Signs (Seek Medical Attention):**
- Persistent pain that doesn't go away with rest
- Numbness or tingling
- Loss of strength or grip
- Swelling or inflammation
- Reduced range of motion
- Pain that wakes you at night

> **Key Message:** Report symptoms early! The earlier the intervention, the better the outcome.

</details>

------------------------------------------------------------------------

## Preventing MSDs: Best Practices

Prevention is far more effective and less costly than treatment. Here are evidence-based strategies for MSD prevention:

```{r prevention-hierarchy, echo=FALSE, fig.align="center", fig.cap="MSD Prevention Hierarchy", fig.width=10, fig.height=6}
prevention <- data.frame(
  level = factor(c("Engineering Controls", "Administrative Controls", "Work Practice Controls"),
                 levels = c("Work Practice Controls", "Administrative Controls", "Engineering Controls")),
  effectiveness = c(5, 3, 2),
  y = c(3, 2, 1),
  width = c(3, 4, 5),
  description = c("Modify equipment,\ntools, workstations",
                  "Job rotation,\nwork-rest schedules",
                  "Training,\nproper techniques")
)

ggplot(prevention, aes(x = 0, y = y)) +
  geom_tile(aes(width = width, height = 0.8, fill = level), color = "white", size = 2) +
  geom_text(aes(label = level), fontface = "bold", color = "white", size = 5) +
  geom_text(aes(x = 3.5, label = description), hjust = 0, size = 3.5, lineheight = 0.9) +
  scale_fill_manual(values = c("Engineering Controls" = "#27AE60",
                               "Administrative Controls" = "#F39C12",
                               "Work Practice Controls" = "#3498DB")) +
  annotate("segment", x = -3, xend = -3, y = 0.5, yend = 3.5,
           arrow = arrow(length = unit(0.3, "cm")), color = "#2C3E50", size = 1.5) +
  annotate("text", x = -3.5, y = 2, label = "More\nEffective",
           angle = 90, fontface = "bold", size = 4) +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  labs(title = "MSD Prevention: Hierarchy of Controls") +
  xlim(-4.5, 7)
```

```{r prevention-strategies, echo=FALSE}
strategies <- tibble(
  `Strategy` = c("**Maintain Neutral Posture**", "**Reduce Repetition**",
                 "**Minimize Force**", "**Avoid Static Positions**",
                 "**Eliminate Contact Stress**", "**Control Vibration**",
                 "**Optimize Environment**", "**Allow Recovery**"),
  `Engineering Solutions` = c("Adjustable workstations, proper tool selection",
                              "Automation, job rotation between stations",
                              "Mechanical assists, better handles, lighter parts",
                              "Sit-stand workstations, adjustable fixtures",
                              "Padding, rounded edges, anti-fatigue mats",
                              "Vibration-dampening tools, isolation mounts",
                              "Proper lighting, climate control, noise reduction",
                              "Rest break areas, micro-break reminders"),
  `Worker Actions` = c("Awareness of body position, stretching",
                       "Vary tasks when possible",
                       "Use tools properly, ask for help with heavy items",
                       "Shift weight, change positions frequently",
                       "Use padding, wear appropriate PPE",
                       "Limit exposure time, grip tools lightly",
                       "Report issues, use available controls",
                       "Take breaks, report fatigue")
)

strategies %>%
  kable(format = "html", caption = "MSD Prevention Strategies") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "14em")
```

### Proper Lifting Technique

Improper lifting is a leading cause of back injuries. The NIOSH lifting equation provides guidelines, but proper technique is fundamental.

```{r lifting-technique, echo=FALSE, fig.align="center", fig.cap="Proper Lifting Technique", fig.width=10, fig.height=6}
ggplot() +
  # Step boxes
  # Step 1
  annotate("rect", xmin = 0, xmax = 2, ymin = 3, ymax = 5, fill = "#3498DB", color = "black") +
  annotate("text", x = 1, y = 4.5, label = "1. PLAN", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 1, y = 3.8, label = "Test weight\nClear path\nGet help if needed",
           color = "white", size = 2.5, lineheight = 0.9) +
  # Step 2
  annotate("rect", xmin = 2.5, xmax = 4.5, ymin = 3, ymax = 5, fill = "#27AE60", color = "black") +
  annotate("text", x = 3.5, y = 4.5, label = "2. POSITION", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 3.5, y = 3.8, label = "Feet shoulder-width\nClose to load\nBend knees",
           color = "white", size = 2.5, lineheight = 0.9) +
  # Step 3
  annotate("rect", xmin = 5, xmax = 7, ymin = 3, ymax = 5, fill = "#F39C12", color = "black") +
  annotate("text", x = 6, y = 4.5, label = "3. GRIP", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 6, y = 3.8, label = "Firm grip\nUse handles\nHold close",
           color = "white", size = 2.5, lineheight = 0.9) +
  # Step 4
  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 3, ymax = 5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 8.5, y = 4.5, label = "4. LIFT", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 8.5, y = 3.8, label = "Straighten legs\nKeep back straight\nDon't twist",
           color = "white", size = 2.5, lineheight = 0.9) +
  # DO section
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 0.5, ymax = 2.5, fill = "#D5F5E3", color = "#27AE60") +
  annotate("text", x = 2.5, y = 2.2, label = "DO:", fontface = "bold", color = "#27AE60", size = 4) +
  annotate("text", x = 2.5, y = 1.3, label = "• Lift with legs\n• Keep load close\n• Pivot feet to turn\n• Ask for help",
           size = 3, lineheight = 0.9, hjust = 0.5) +
  # DON'T section
  annotate("rect", xmin = 5, xmax = 9, ymin = 0.5, ymax = 2.5, fill = "#FADBD8", color = "#E74C3C") +
  annotate("text", x = 7, y = 2.2, label = "DON'T:", fontface = "bold", color = "#E74C3C", size = 4) +
  annotate("text", x = 7, y = 1.3, label = "• Lift with back\n• Reach and lift\n• Twist while lifting\n• Jerk the load",
           size = 3, lineheight = 0.9, hjust = 0.5) +
  theme_void() +
  labs(title = "The Four Steps of Safe Lifting") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
```

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/BhlTumeGKpw&t"
    title="Safe Manual Handling and Lifting Techniques"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## Ergonomic Design Principles

Effective ergonomic design follows established principles that account for human capabilities and limitations.

```{r design-principles, echo=FALSE, fig.align="center", fig.cap="Ergonomic Design Principles", fig.width=10, fig.height=8}
principles <- data.frame(
  principle = c("Neutral Posture", "Anthropometry", "Reduce Force",
                "Reduce Motion", "Work Height", "Minimize Static Load",
                "Environment", "Cognitive Design"),
  x = c(1, 2, 3, 4, 1, 2, 3, 4),
  y = c(2, 2, 2, 2, 1, 1, 1, 1)
)

ggplot(principles, aes(x = x, y = y)) +
  geom_tile(width = 0.9, height = 0.8, fill = "#3498DB", color = "white", size = 2) +
  geom_text(aes(label = principle), color = "white", fontface = "bold", size = 3.5,
            lineheight = 0.9) +
  theme_void() +
  labs(title = "Eight Core Ergonomic Design Principles",
       subtitle = "Apply these principles to every workstation design") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  ylim(0.3, 2.7)
```

```{r principles-detail, echo=FALSE}
principles_detail <- tibble(
  `Principle` = c("**1. Neutral Posture**", "**2. Accommodate Anthropometry**",
                  "**3. Reduce Excessive Force**", "**4. Reduce Excessive Motion**",
                  "**5. Optimize Work Height**", "**6. Minimize Static Load**",
                  "**7. Environmental Conditions**", "**8. Cognitive Support**"),
  `Description` = c("Design to promote natural, balanced body positions",
                    "Accommodate different body sizes (5th-95th percentile)",
                    "Minimize force requirements for all tasks",
                    "Reduce extreme motions, frequencies, and durations",
                    "Match work surface height to task requirements",
                    "Avoid holding same position for extended periods",
                    "Optimize lighting, temperature, noise, air quality",
                    "Design interfaces for easy understanding and use"),
  `Implementation` = c("Adjustable workstations, proper tool angles, monitor height",
                       "Adjustable equipment, multiple sizes available, reach considerations",
                       "Mechanical assists, better handles, reduce weight, improve grip",
                       "Bring work closer, eliminate unnecessary steps, use fixtures",
                       "Precision work higher, heavy work lower, adjustable surfaces",
                       "Support arms, provide seating options, allow movement",
                       "Task lighting, climate control, noise barriers, ventilation",
                       "Clear displays, logical controls, consistent feedback")
)

principles_detail %>%
  kable(format = "html", caption = "Ergonomic Design Principles in Detail") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2980B9", color = "white") %>%
  column_spec(1, bold = TRUE, width = "14em")
```

### Anthropometry: Designing for Human Dimensions

**Anthropometry** is the scientific study of human body measurements. Workstations must accommodate the range of workers who will use them.

```{r anthropometry-viz, echo=FALSE, fig.align="center", fig.cap="Anthropometric Design Considerations", fig.width=10, fig.height=6}
# Create percentile visualization
ggplot() +
  # Distribution curve
  stat_function(fun = dnorm, args = list(mean = 170, sd = 10),
                xlim = c(140, 200), size = 2, color = "#3498DB") +
  # Percentile lines
  geom_vline(xintercept = 153.5, linetype = "dashed", color = "#E74C3C", size = 1) +
  geom_vline(xintercept = 170, linetype = "dashed", color = "#F39C12", size = 1) +
  geom_vline(xintercept = 186.5, linetype = "dashed", color = "#27AE60", size = 1) +
  # Labels
  annotate("text", x = 153.5, y = 0.035, label = "5th\npercentile",
           size = 3, color = "#E74C3C", vjust = 0) +
  annotate("text", x = 170, y = 0.042, label = "50th\npercentile",
           size = 3, color = "#F39C12", vjust = 0) +
  annotate("text", x = 186.5, y = 0.035, label = "95th\npercentile",
           size = 3, color = "#27AE60", vjust = 0) +
  # Design range
  annotate("segment", x = 153.5, xend = 186.5, y = -0.002, yend = -0.002,
           arrow = arrow(length = unit(0.2, "cm"), ends = "both"),
           color = "#9B59B6", size = 1.5) +
  annotate("text", x = 170, y = -0.005, label = "Design Range (90% of population)",
           color = "#9B59B6", fontface = "bold", size = 3.5) +
  scale_x_continuous(breaks = seq(140, 200, 10)) +
  labs(title = "Anthropometric Distribution: Stature Example",
       subtitle = "Design should accommodate 5th to 95th percentile",
       x = "Height (cm)", y = "Probability Density") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
```

```{r anthropometry-table, echo=FALSE}
anthro_data <- tibble(
  `Measurement` = c("Stature (Standing Height)", "Eye Height (Standing)",
                    "Shoulder Height", "Elbow Height", "Knuckle Height",
                    "Sitting Height", "Seated Eye Height", "Seated Elbow Height",
                    "Thigh Clearance", "Forward Reach"),
  `5th % Female (cm)` = c(150, 138, 121, 93, 64, 79, 68, 18, 12, 64),
  `50th % Combined (cm)` = c(170, 158, 140, 104, 74, 87, 76, 24, 15, 73),
  `95th % Male (cm)` = c(188, 176, 158, 117, 85, 97, 85, 31, 19, 84),
  `Design Application` = c("Overhead clearance, door height",
                           "Display/sign height",
                           "Shelf maximum height",
                           "Work surface height (standing)",
                           "Handle height for pulling",
                           "Overhead clearance (seated)",
                           "Monitor height (seated)",
                           "Armrest, work surface height",
                           "Under-desk clearance",
                           "Maximum reach distance")
)

anthro_data %>%
  kable(format = "html", caption = "Key Anthropometric Measurements for Workstation Design") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "14em")
```

### Work Surface Height Guidelines

```{r work-height, echo=FALSE, fig.align="center", fig.cap="Recommended Work Surface Heights", fig.width=10, fig.height=6}
height_data <- data.frame(
  task = c("Precision Work", "Light Assembly", "Heavy Work"),
  standing_low = c(100, 85, 70),
  standing_high = c(110, 95, 85),
  seated_low = c(70, 60, NA),
  seated_high = c(75, 65, NA)
)

ggplot() +
  # Standing heights
  annotate("rect", xmin = 0.7, xmax = 1.3, ymin = 100, ymax = 110,
           fill = "#3498DB", alpha = 0.7) +
  annotate("rect", xmin = 1.7, xmax = 2.3, ymin = 85, ymax = 95,
           fill = "#27AE60", alpha = 0.7) +
  annotate("rect", xmin = 2.7, xmax = 3.3, ymin = 70, ymax = 85,
           fill = "#F39C12", alpha = 0.7) +
  # Labels
  annotate("text", x = 1, y = 115, label = "Precision\n100-110cm", size = 3, lineheight = 0.9) +
  annotate("text", x = 2, y = 100, label = "Light Assembly\n85-95cm", size = 3, lineheight = 0.9) +
  annotate("text", x = 3, y = 90, label = "Heavy Work\n70-85cm", size = 3, lineheight = 0.9) +
  # Reference line - elbow height
  annotate("segment", x = 0.5, xend = 3.5, y = 105, yend = 105,
           linetype = "dashed", color = "#E74C3C", size = 1) +
  annotate("text", x = 3.7, y = 105, label = "Elbow Height\n(standing)",
           hjust = 0, size = 3, color = "#E74C3C") +
  scale_y_continuous(breaks = seq(60, 120, 10), limits = c(60, 120)) +
  scale_x_continuous(breaks = 1:3, labels = c("Precision", "Light Assembly", "Heavy Work")) +
  labs(title = "Optimal Standing Work Surface Heights by Task Type",
       subtitle = "Heights in cm from floor - adjust based on worker height",
       x = "Task Type", y = "Height (cm)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    panel.grid.minor = element_blank()
  )
```

<details>
<summary>Discussion: Why Different Heights for Different Tasks?</summary>

**Precision Work (100-110 cm):**
- Requires close visual inspection
- Hands need to be at or above eye level
- Examples: Electronics assembly, inspection, watchmaking

**Light Assembly (85-95 cm):**
- General manipulation tasks
- Hands at about elbow height
- Examples: Packaging, general assembly, sorting

**Heavy Work (70-85 cm):**
- Requires pushing, pressing, or lifting
- Lower height allows use of body weight
- Examples: Packing boxes, pressing operations, heavy assembly

**Key Principle:** The work surface height should allow the worker to maintain **neutral posture** while performing the specific task.

</details>

------------------------------------------------------------------------

## Ergonomic Assessment Tools

Several standardized tools help assess ergonomic risk and guide interventions. Understanding these tools is essential for the process engineer.

```{r assessment-tools, echo=FALSE}
tools <- tibble(
  `Tool` = c("**RULA**", "**REBA**", "**NIOSH Lifting Equation**",
             "**OCRA**", "**EAWS**", "**Snook Tables**"),
  `Full Name` = c("Rapid Upper Limb Assessment",
                  "Rapid Entire Body Assessment",
                  "NIOSH Lifting Equation",
                  "Occupational Repetitive Action",
                  "Ergonomic Assessment Worksheet",
                  "Snook Psychophysical Tables"),
  `Focus Area` = c("Upper body postures",
                   "Whole body postures",
                   "Manual lifting tasks",
                   "Repetitive upper limb tasks",
                   "Comprehensive workstation",
                   "Manual material handling"),
  `Best Used For` = c("Sedentary/computer work, assembly",
                      "Manufacturing, healthcare, varied postures",
                      "Lifting, lowering, carrying tasks",
                      "Assembly lines, repetitive manufacturing",
                      "Complete workstation analysis",
                      "Push, pull, lift, lower, carry tasks")
)

tools %>%
  kable(format = "html", caption = "Common Ergonomic Assessment Tools") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

### REBA: Rapid Entire Body Assessment

**REBA** is one of the most widely used ergonomic assessment tools in manufacturing. It evaluates the whole body posture and provides a risk score.

```{r reba-overview, echo=FALSE, fig.align="center", fig.cap="REBA Assessment Framework", fig.width=10, fig.height=7}
ggplot() +
  # Group A box
  annotate("rect", xmin = 0, xmax = 4, ymin = 4, ymax = 7, fill = "#3498DB", color = "black") +
  annotate("text", x = 2, y = 6.5, label = "GROUP A", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 2, y = 5.5, label = "Trunk Score (1-5)\nNeck Score (1-3)\nLegs Score (1-4)",
           size = 3.5, color = "white", lineheight = 0.9) +
  # Group B box
  annotate("rect", xmin = 5, xmax = 9, ymin = 4, ymax = 7, fill = "#E74C3C", color = "black") +
  annotate("text", x = 7, y = 6.5, label = "GROUP B", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 7, y = 5.5, label = "Upper Arm Score (1-6)\nLower Arm Score (1-2)\nWrist Score (1-3)",
           size = 3.5, color = "white", lineheight = 0.9) +
  # Score A
  annotate("rect", xmin = 1, xmax = 3, ymin = 2.5, ymax = 3.5, fill = "#2980B9", color = "black") +
  annotate("text", x = 2, y = 3, label = "Score A\n+ Load/Force", size = 3, color = "white", lineheight = 0.9) +
  # Score B
  annotate("rect", xmin = 6, xmax = 8, ymin = 2.5, ymax = 3.5, fill = "#C0392B", color = "black") +
  annotate("text", x = 7, y = 3, label = "Score B\n+ Coupling", size = 3, color = "white", lineheight = 0.9) +
  # Arrows down
  annotate("segment", x = 2, xend = 2, y = 4, yend = 3.5, arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 7, xend = 7, y = 4, yend = 3.5, arrow = arrow(length = unit(0.2, "cm"))) +
  # Score C
  annotate("rect", xmin = 3, xmax = 6, ymin = 1, ymax = 2, fill = "#27AE60", color = "black") +
  annotate("text", x = 4.5, y = 1.5, label = "Score C\n+ Activity", size = 3, color = "white", lineheight = 0.9) +
  # Arrows to C
  annotate("segment", x = 2, xend = 3.5, y = 2.5, yend = 2, arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 7, xend = 5.5, y = 2.5, yend = 2, arrow = arrow(length = unit(0.2, "cm"))) +
  # Final Score
  annotate("rect", xmin = 3, xmax = 6, ymin = -0.5, ymax = 0.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 4.5, y = 0, label = "REBA SCORE\n(1-15)", fontface = "bold", size = 4, color = "white", lineheight = 0.9) +
  annotate("segment", x = 4.5, xend = 4.5, y = 1, yend = 0.5, arrow = arrow(length = unit(0.2, "cm"))) +
  theme_void() +
  labs(title = "REBA Assessment Structure",
       subtitle = "Combines posture scores with load, coupling, and activity factors") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

### REBA Scoring Tables

**Trunk Posture Scoring:**

```{r reba-trunk, echo=FALSE}
trunk <- tibble(
  `Position` = c("Upright (0°)", "0-20° flexion/extension", "20-60° flexion, >20° extension",
                 ">60° flexion"),
  `Score` = c(1, 2, 3, 4),
  `Adjustment` = c("—", "+1 if twisted", "+1 if twisted", "+1 if twisted or side-bending")
)

trunk %>%
  kable(format = "html", caption = "REBA Trunk Posture Scores") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#D5F5E3") %>%
  row_spec(3, background = "#FEF9E7") %>%
  row_spec(4, background = "#FADBD8")
```

**Neck Posture Scoring:**

```{r reba-neck, echo=FALSE}
neck <- tibble(
  `Position` = c("0-20° flexion", ">20° flexion or extension"),
  `Score` = c(1, 2),
  `Adjustment` = c("+1 if twisted or side-bending", "+1 if twisted or side-bending")
)

neck %>%
  kable(format = "html", caption = "REBA Neck Posture Scores") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white")
```

**REBA Action Levels:**

```{r reba-action, echo=FALSE}
action <- tibble(
  `REBA Score` = c("1", "2-3", "4-7", "8-10", "11-15"),
  `Risk Level` = c("Negligible", "Low", "Medium", "High", "Very High"),
  `Action` = c("None necessary", "May be necessary", "Necessary",
               "Necessary soon", "Necessary NOW")
)

action %>%
  kable(format = "html", caption = "REBA Action Levels") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#F39C12", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#D5F5E3") %>%
  row_spec(3, background = "#FEF9E7") %>%
  row_spec(4, background = "#FADBD8") %>%
  row_spec(5, background = "#E74C3C", color = "white")
```

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/wRxLNzgGSBg"
    title="REBA Assessment Tutorial"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

### REBA Example Calculation

```{r reba-example, echo=TRUE}
# REBA Assessment Example: Assembly Worker

# Group A Scores (Trunk, Neck, Legs)
trunk_score <- 3      # 20-60° forward bend
neck_score <- 2       # >20° flexion
legs_score <- 1       # Bilateral weight bearing

# Look up Table A score (trunk + neck + legs)
# For this combination: Score A = 4
table_a_score <- 4

# Load/Force Score
load_force <- 1       # 5-10 kg intermittent

# Score A with load
score_a <- table_a_score + load_force
cat("Score A (posture + load):", score_a, "\n")

# Group B Scores (Upper arm, Lower arm, Wrist)
upper_arm_score <- 3  # 45-90° flexion
lower_arm_score <- 2  # <60° or >100° flexion
wrist_score <- 2      # >15° flexion/extension

# Look up Table B score
# For this combination: Score B = 5
table_b_score <- 5

# Coupling Score
coupling <- 1         # Acceptable grip

# Score B with coupling
score_b <- table_b_score + coupling
cat("Score B (posture + coupling):", score_b, "\n")

# Look up Table C (Score A × Score B)
# For Score A = 5 and Score B = 6: Score C = 8
score_c <- 8

# Activity Score
activity <- 1         # One or more body parts static >1 min

# Final REBA Score
reba_final <- score_c + activity
cat("\n=== FINAL REBA SCORE:", reba_final, "===\n")

# Interpretation
cat("\nInterpretation:\n")
if (reba_final <= 1) {
  cat("Risk Level: Negligible - No action necessary\n")
} else if (reba_final <= 3) {
  cat("Risk Level: Low - Action may be necessary\n")
} else if (reba_final <= 7) {
  cat("Risk Level: Medium - Action necessary\n")
} else if (reba_final <= 10) {
  cat("Risk Level: High - Action necessary soon\n")
} else {
  cat("Risk Level: Very High - Action necessary NOW\n")
}
```

<details>
<summary>Practice Problem: REBA Assessment</summary>

**Scenario:** A worker is performing a task with the following postures:

- **Trunk:** 30° forward flexion, twisted
- **Neck:** 15° flexion
- **Legs:** Weight on one leg
- **Upper Arm:** 60° flexion, shoulder raised
- **Lower Arm:** 80° flexion
- **Wrist:** Neutral
- **Load:** 8 kg carried
- **Coupling:** Fair grip (handles exist but not ideal)
- **Activity:** Repeated small range actions

**Calculate the REBA score and determine the action level.**

**Solution:**
```
Trunk: 3 + 1 (twisted) = 4
Neck: 1 (0-20° flexion)
Legs: 2 (weight on one leg)
Table A = 5
Load/Force = 1 (5-10kg)
Score A = 6

Upper Arm: 3 + 1 (raised) = 4
Lower Arm: 1 (60-100°)
Wrist: 1 (neutral)
Table B = 4
Coupling = 1 (fair)
Score B = 5

Table C (Score A=6, Score B=5) = 8
Activity = +1 (repeated actions)
REBA Score = 9

Risk Level: HIGH - Action necessary soon
```

</details>

### NIOSH Lifting Equation

The **NIOSH Lifting Equation** calculates a **Recommended Weight Limit (RWL)** for lifting tasks.

$$RWL = LC \times HM \times VM \times DM \times AM \times FM \times CM$$

Where:

```{r niosh-factors, echo=FALSE}
niosh <- tibble(
  `Factor` = c("LC", "HM", "VM", "DM", "AM", "FM", "CM"),
  `Name` = c("Load Constant", "Horizontal Multiplier", "Vertical Multiplier",
             "Distance Multiplier", "Asymmetric Multiplier", "Frequency Multiplier",
             "Coupling Multiplier"),
  `Value` = c("23 kg (51 lb)", "25/H", "1 - 0.003|V-75|", "0.82 + 4.5/D",
              "1 - 0.0032A", "Table lookup", "Table lookup"),
  `Description` = c("Maximum weight under ideal conditions",
                    "H = horizontal distance from midpoint between ankles to hands (cm)",
                    "V = vertical height of hands at start (cm)",
                    "D = vertical travel distance (cm)",
                    "A = angle of asymmetry (degrees)",
                    "Based on lift frequency and duration",
                    "Based on hand-load coupling quality")
)

niosh %>%
  kable(format = "html", caption = "NIOSH Lifting Equation Factors") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

**Lifting Index (LI)** indicates risk level:

$$LI = \frac{\text{Actual Weight}}{\text{RWL}}$$

```{r li-interpretation, echo=FALSE}
li_interp <- tibble(
  `Lifting Index` = c("LI ≤ 1.0", "1.0 < LI ≤ 2.0", "2.0 < LI ≤ 3.0", "LI > 3.0"),
  `Risk` = c("Low", "Moderate", "High", "Very High"),
  `Action` = c("Task acceptable for most workers",
               "Some workers may be at risk - consider changes",
               "Many workers at risk - changes recommended",
               "Unacceptable - immediate changes required")
)

li_interp %>%
  kable(format = "html", caption = "Lifting Index Interpretation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3, background = "#FADBD8") %>%
  row_spec(4, background = "#E74C3C", color = "white")
```

```{r niosh-example, echo=TRUE}
# NIOSH Lifting Equation Example

# Task parameters
H <- 40    # Horizontal distance (cm)
V <- 30    # Vertical height at start (cm)
D <- 60    # Vertical travel distance (cm)
A <- 30    # Asymmetry angle (degrees)
F <- 2     # Lifts per minute
duration <- 2  # Hours of lifting

# Constants
LC <- 23   # Load constant (kg)

# Calculate multipliers
HM <- 25 / H
VM <- 1 - 0.003 * abs(V - 75)
DM <- 0.82 + 4.5 / D
AM <- 1 - 0.0032 * A

# Frequency multiplier (from table, for 2 lifts/min, 2 hours, V<75cm)
FM <- 0.84

# Coupling multiplier (assume "fair" coupling)
CM <- 0.95

cat("Multipliers:\n")
cat("HM =", round(HM, 3), "\n")
cat("VM =", round(VM, 3), "\n")
cat("DM =", round(DM, 3), "\n")
cat("AM =", round(AM, 3), "\n")
cat("FM =", FM, "\n")
cat("CM =", CM, "\n\n")

# Calculate RWL
RWL <- LC * HM * VM * DM * AM * FM * CM
cat("Recommended Weight Limit (RWL):", round(RWL, 1), "kg\n\n")

# Calculate Lifting Index for actual load
actual_weight <- 15  # kg
LI <- actual_weight / RWL
cat("Actual Weight:", actual_weight, "kg\n")
cat("Lifting Index (LI):", round(LI, 2), "\n\n")

# Interpretation
if (LI <= 1.0) {
  cat("Risk Level: LOW - Task acceptable\n")
} else if (LI <= 2.0) {
  cat("Risk Level: MODERATE - Consider changes\n")
} else if (LI <= 3.0) {
  cat("Risk Level: HIGH - Changes recommended\n")
} else {
  cat("Risk Level: VERY HIGH - Immediate changes required\n")
}
```

------------------------------------------------------------------------

## AI-Powered Ergonomic Assessment

Artificial intelligence is revolutionizing ergonomic assessment by enabling **real-time, automated analysis** of worker postures without disrupting operations.

```{r ai-tools-viz, echo=FALSE, fig.align="center", fig.cap="AI Ergonomics Assessment Pipeline", fig.width=10, fig.height=5}
ggplot() +
  # Input
  annotate("rect", xmin = 0, xmax = 2, ymin = 1, ymax = 3, fill = "#3498DB", color = "black") +
  annotate("text", x = 1, y = 2.5, label = "INPUT", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 1, y = 1.7, label = "Video/\nWearables", color = "white", size = 3) +
  # Processing
  annotate("rect", xmin = 3, xmax = 5, ymin = 1, ymax = 3, fill = "#9B59B6", color = "black") +
  annotate("text", x = 4, y = 2.5, label = "AI PROCESSING", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 4, y = 1.7, label = "Pose\nEstimation", color = "white", size = 3) +
  # Analysis
  annotate("rect", xmin = 6, xmax = 8, ymin = 1, ymax = 3, fill = "#E74C3C", color = "black") +
  annotate("text", x = 7, y = 2.5, label = "ANALYSIS", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 7, y = 1.7, label = "REBA/RULA\nScoring", color = "white", size = 3) +
  # Output
  annotate("rect", xmin = 9, xmax = 11, ymin = 1, ymax = 3, fill = "#27AE60", color = "black") +
  annotate("text", x = 10, y = 2.5, label = "OUTPUT", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 10, y = 1.7, label = "Risk Report\nAlerts", color = "white", size = 3) +
  # Arrows
  annotate("segment", x = 2, xend = 3, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 5, xend = 6, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 8, xend = 9, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  theme_void() +
  labs(title = "AI-Powered Ergonomic Assessment Pipeline",
       subtitle = "From video input to automated risk assessment") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

```{r ai-tools-table, echo=FALSE}
ai_tools <- tibble(
  `Tool` = c("**TuMeke Ergonomics**", "**VelocityEHS**", "**Protex AI**",
             "**SoterTask**", "**Viso.ai**", "**ErgoPlus Platform**"),
  `Technology` = c("Computer vision + wearables",
                   "AI video analysis",
                   "Real-time video AI",
                   "Wearable sensors + AI",
                   "Custom AI models",
                   "Mobile app + AI"),
  `Key Features` = c("Real-time REBA scoring, multi-camera support",
                     "Automated job analysis, risk prioritization",
                     "Privacy-preserving analysis, floor-wide monitoring",
                     "Wearable clips, real-time coaching, haptic feedback",
                     "Custom pose detection, integration APIs",
                     "Mobile assessment, improvement tracking"),
  `Best For` = c("Manufacturing, warehousing",
                 "Enterprise-wide programs",
                 "Large facilities, privacy-conscious",
                 "Individual worker coaching",
                 "Custom integrations",
                 "Field assessments")
)

ai_tools %>%
  kable(format = "html", caption = "AI-Powered Ergonomic Assessment Tools") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Benefits of AI Ergonomic Assessment

```{r ai-benefits, echo=FALSE, fig.align="center", fig.cap="Traditional vs. AI Ergonomic Assessment", fig.width=10, fig.height=6}
comparison <- data.frame(
  metric = c("Time per Assessment", "Assessments per Day",
             "Consistency", "Real-time Feedback", "Cost per Assessment"),
  traditional = c(30, 5, 60, 0, 100),
  ai = c(1, 500, 95, 100, 5),
  metric_label = c("Minutes", "Count", "% Consistent", "% Available", "$ (relative)")
)

comparison_long <- comparison %>%
  pivot_longer(cols = c(traditional, ai), names_to = "method", values_to = "value")

ggplot(comparison_long, aes(x = metric, y = value, fill = method)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(value, ifelse(metric %in% c("Consistency", "Real-time Feedback"), "%", ""))),
            position = position_dodge(width = 0.7), vjust = -0.5, size = 3) +
  scale_fill_manual(values = c("traditional" = "#E74C3C", "ai" = "#27AE60"),
                    labels = c("AI-Powered", "Traditional"),
                    name = "Method") +
  labs(title = "Traditional vs. AI Ergonomic Assessment Comparison",
       x = "", y = "Value (scale varies by metric)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text.x = element_text(angle = 20, hjust = 1),
    legend.position = "bottom"
  )
```

```{=html}
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/yt9LY28qGwU"
    title="AI Ergonomics Assessment - TuMeke Demo"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>
```

------------------------------------------------------------------------

## Ergonomics in Automated Manufacturing

Industrial automation inherently involves the mechanization of processes traditionally carried out by human operators. In the automation design phase, engineers must strike a balance between mechanization and the necessary human interaction with these systems.

### Human-Automation Interaction Points

```{r automation-interaction, echo=FALSE, fig.align="center", fig.cap="Ergonomic Considerations in Automated Systems", fig.width=10, fig.height=7}
ggplot() +
  # Central automation system
  annotate("rect", xmin = 3, xmax = 7, ymin = 2, ymax = 5, fill = "#95A5A6", color = "black") +
  annotate("text", x = 5, y = 3.5, label = "AUTOMATED\nSYSTEM", fontface = "bold", size = 5) +
  # Interaction points
  # Loading/Unloading
  annotate("rect", xmin = 0, xmax = 2.5, ymin = 4, ymax = 5.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 1.25, y = 4.75, label = "Loading/\nUnloading", size = 3, color = "white") +
  annotate("segment", x = 2.5, xend = 3, y = 4.75, yend = 4,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  # HMI
  annotate("rect", xmin = 0, xmax = 2.5, ymin = 2, ymax = 3.5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 1.25, y = 2.75, label = "HMI\nOperation", size = 3, color = "white") +
  annotate("segment", x = 2.5, xend = 3, y = 2.75, yend = 3.5,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  # Maintenance
  annotate("rect", xmin = 7.5, xmax = 10, ymin = 4, ymax = 5.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 8.75, y = 4.75, label = "Maintenance\nAccess", size = 3, color = "white") +
  annotate("segment", x = 7.5, xend = 7, y = 4.75, yend = 4,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  # Quality Check
  annotate("rect", xmin = 7.5, xmax = 10, ymin = 2, ymax = 3.5, fill = "#27AE60", color = "black") +
  annotate("text", x = 8.75, y = 2.75, label = "Quality\nInspection", size = 3, color = "white") +
  annotate("segment", x = 7.5, xend = 7, y = 2.75, yend = 3.5,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  # Supervision
  annotate("rect", xmin = 3.5, xmax = 6.5, ymin = 5.5, ymax = 7, fill = "#9B59B6", color = "black") +
  annotate("text", x = 5, y = 6.25, label = "Supervision/\nMonitoring", size = 3, color = "white") +
  annotate("segment", x = 5, xend = 5, y = 5.5, yend = 5,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  theme_void() +
  labs(title = "Human-Automation Interaction Points",
       subtitle = "Each interaction point requires ergonomic design consideration") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

```{r automation-ergo, echo=FALSE}
automation_ergo <- tibble(
  `Interaction Point` = c("**Loading/Unloading**", "**HMI Operation**", "**Maintenance**",
                          "**Quality Inspection**", "**Supervision**"),
  `Ergonomic Challenges` = c("Repetitive motion, lifting, reaching, awkward postures",
                              "Static posture, visual strain, cognitive load",
                              "Awkward access, confined spaces, tool use",
                              "Static positions, visual strain, fine motor tasks",
                              "Sedentary position, cognitive fatigue, vigilance"),
  `Design Solutions` = c("Height-adjustable conveyors, lift assists, indexing fixtures",
                         "Adjustable screens, proper height, clear interface design",
                         "Adequate access space, tool organization, proper lighting",
                         "Adjustable fixtures, magnification, ergonomic seating",
                         "Multiple monitors at eye level, alert systems, task variety")
)

automation_ergo %>%
  kable(format = "html", caption = "Ergonomic Considerations for Automated Systems") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#34495E", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Collaborative Robot Ergonomics

Cobots present unique ergonomic opportunities and challenges:

```{r cobot-ergo, echo=FALSE}
cobot_ergo <- tibble(
  `Aspect` = c("**Task Allocation**", "**Workstation Layout**", "**Pacing**",
               "**Force Assistance**", "**Cognitive Load**"),
  `Opportunity` = c("Robot handles heavy, repetitive, or precision tasks",
                    "Shared workspace allows flexible positioning",
                    "Robot adapts to human pace, not vice versa",
                    "Robot provides powered assist for lifting",
                    "Robot handles routine tasks, human focuses on judgment"),
  `Challenge` = c("Determining optimal task division",
                  "Ensuring adequate space for human movement",
                  "Avoiding pressure from robot efficiency",
                  "Proper force limits to prevent injury on contact",
                  "Maintaining situational awareness")
)

cobot_ergo %>%
  kable(format = "html", caption = "Ergonomic Considerations for Collaborative Robots") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2ECC71", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

------------------------------------------------------------------------

## Employer Responsibilities

Employers have both legal and ethical obligations to protect workers from ergonomic hazards.

```{r employer-responsibilities, echo=FALSE}
employer_resp <- tibble(
  `Responsibility` = c("**Management Commitment**", "**Worker Involvement**",
                       "**Training**", "**Hazard Identification**",
                       "**Early Reporting**", "**Hazard Control**", "**Program Evaluation**"),
  `Actions` = c("Allocate resources, set goals, lead by example",
                "Include workers in assessments, design teams, solution development",
                "Ergonomics awareness, proper techniques, symptom recognition",
                "Regular assessments, worker surveys, injury analysis",
                "Non-punitive reporting system, prompt response to symptoms",
                "Engineering controls, work organization, PPE as last resort",
                "Track injuries, measure improvements, adjust programs")
)

employer_resp %>%
  kable(format = "html", caption = "Employer Ergonomics Program Responsibilities") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#C0392B", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

<details>
<summary>OSHA Ergonomics Guidelines</summary>

While OSHA does not have a specific ergonomics standard, employers are still responsible under the **General Duty Clause** (Section 5(a)(1)) which requires employers to provide a workplace "free from recognized hazards."

**OSHA's Recommended Program Elements:**
1. Management leadership
2. Worker participation
3. Hazard identification and assessment
4. Hazard prevention and control
5. Education and training
6. Program evaluation

**Industry-Specific Guidelines:**
- Poultry Processing
- Nursing Homes
- Retail Grocery Stores
- Shipyards

Visit: [OSHA Ergonomics eTool](https://www.osha.gov/ergonomics)

</details>

------------------------------------------------------------------------

## Case Study: Ergonomics in Automated Assembly

**Company:** Automotive parts manufacturer

**Problem:** High rate of upper extremity MSDs in assembly department
- 15 recordable injuries per year
- Lost workdays averaging 20 days per case
- Workers' comp costs exceeding $300,000 annually

**Assessment Findings:**

```{r case-study-findings, echo=FALSE}
findings <- tibble(
  `Workstation` = c("Sub-assembly", "Main line", "Inspection", "Packaging"),
  `Primary Issues` = c("Overhead reaching, high repetition",
                       "Forward bending, static standing",
                       "Awkward wrist postures, visual strain",
                       "Lifting, carrying, repetition"),
  `REBA Score` = c(9, 8, 7, 10),
  `Risk Level` = c("High", "High", "Medium", "Very High")
)

findings %>%
  kable(format = "html", caption = "Ergonomic Assessment Findings") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(4, background = "#FADBD8", bold = TRUE)
```

**Interventions Implemented:**

1. **Sub-assembly:**
   - Tilting fixtures to bring work closer
   - Parts bins repositioned to eliminate overhead reaching
   - Cobot added for repetitive insertion tasks

2. **Main line:**
   - Height-adjustable workstations installed
   - Anti-fatigue mats added
   - Job rotation implemented

3. **Inspection:**
   - Magnifying task lights installed
   - Angled fixtures to reduce wrist bending
   - Ergonomic seating provided

4. **Packaging:**
   - Vacuum lift assists installed
   - Conveyor heights adjusted
   - Case erectors automated

**Results After 18 Months:**

```{r case-study-results, echo=FALSE, fig.align="center", fig.cap="Ergonomic Intervention Results", fig.width=9, fig.height=5}
results <- data.frame(
  metric = c("Recordable Injuries", "Lost Workdays", "Workers' Comp Cost ($K)",
             "Productivity", "Quality (defects)"),
  before = c(15, 300, 300, 100, 100),
  after = c(4, 48, 75, 118, 65)
)

results_long <- results %>%
  mutate(
    change = (after - before) / before * 100
  )

ggplot(results_long, aes(x = metric, y = change)) +
  geom_bar(stat = "identity", fill = ifelse(results_long$change < 0, "#27AE60", "#3498DB"),
           color = "black", width = 0.7) +
  geom_text(aes(label = paste0(ifelse(change > 0, "+", ""), round(change), "%")),
            vjust = ifelse(results_long$change < 0, 1.5, -0.5), fontface = "bold", size = 4) +
  geom_hline(yintercept = 0, color = "black", size = 1) +
  scale_y_continuous(limits = c(-90, 30)) +
  labs(title = "Impact of Ergonomic Interventions",
       subtitle = "Percentage change from baseline after 18 months",
       x = "", y = "Change (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 20, hjust = 1)
  )
```

**ROI Analysis:**

```{r roi-analysis, echo=TRUE}
# Investment
equipment_cost <- 150000  # Lift assists, fixtures, cobots
training_cost <- 15000
total_investment <- equipment_cost + training_cost

# Annual Savings
injury_reduction <- (15 - 4) * 20000  # Avg cost per injury
productivity_gain <- 0.18 * 500000    # 18% improvement on labor cost
quality_improvement <- 0.35 * 50000   # 35% defect reduction

annual_savings <- injury_reduction + productivity_gain + quality_improvement

cat("Total Investment: $", format(total_investment, big.mark = ","), "\n")
cat("Annual Savings: $", format(annual_savings, big.mark = ","), "\n")
cat("Payback Period:", round(total_investment / annual_savings, 1), "years\n")
cat("5-Year ROI:", round((annual_savings * 5 - total_investment) / total_investment * 100), "%\n")
```

------------------------------------------------------------------------

## Summary

```{r summary-table-ch7, echo=FALSE}
summary_data <- tibble(
  `Topic` = c("**Ergonomics Definition**", "**Risk Factors**", "**MSDs**",
              "**Prevention**", "**Design Principles**", "**Assessment Tools**",
              "**AI in Ergonomics**", "**Employer Role**"),
  `Key Points` = c("Fitting the job to the worker; physical, cognitive, organizational domains",
                   "Posture, repetition, force, static positions, contact stress, vibration, environment",
                   "Injuries to muscles, nerves, tendons; develop gradually from exposure to disability",
                   "Engineering controls most effective; proper lifting, neutral postures, recovery time",
                   "Neutral posture, anthropometry, work height optimization, environmental control",
                   "REBA for whole body, RULA for upper limb, NIOSH for lifting tasks",
                   "Real-time monitoring, automated REBA/RULA scoring, continuous assessment",
                   "Management commitment, worker involvement, training, hazard control, evaluation")
)

summary_data %>%
  kable(format = "html", caption = "Ergonomics in Manufacturing: Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "12em")
```

------------------------------------------------------------------------

## Review Questions

<details>
<summary>Question 1: What are the seven ergonomic risk factors, and which two are most commonly associated with carpal tunnel syndrome?</summary>

The seven ergonomic risk factors are:
1. Awkward Postures
2. Repetition
3. Force
4. Static Positions
5. Contact Stress
6. Vibration
7. Environmental Factors

**Carpal tunnel syndrome** is most commonly associated with:
- **Repetition** - Repeated wrist movements compress the median nerve
- **Force** - Forceful gripping increases pressure in the carpal tunnel
- Also contributing: awkward wrist postures and vibration

</details>

<details>
<summary>Question 2: A worker performs a task 8 times per minute for a 4-hour shift. The cycle time is 7.5 seconds. Is this considered high repetition? Why?</summary>

**Analysis:**
- Cycle time: 7.5 seconds (< 15 seconds threshold)
- Repetitions per hour: 8 × 60 = 480 (> 240 threshold)

**Yes, this is HIGH repetition** because:
1. Cycle time is less than 15 seconds
2. Repetitions exceed 240 per hour

**Risk Level:** High - Immediate intervention needed

**Recommended actions:**
- Job rotation with different tasks
- Automation of repetitive elements
- Micro-breaks every 20-30 minutes
- Workstation redesign to reduce cycle elements

</details>

<details>
<summary>Question 3: Explain why ergonomic design should accommodate the 5th to 95th percentile of the population rather than designing for the "average" person.</summary>

**Designing for the average excludes most people:**
- The "average" person in ALL dimensions doesn't exist
- A person may be average height but have long arms or short legs
- Designing for only the 50th percentile fits only about 50% of users

**The 5th-95th percentile range:**
- Accommodates 90% of the population
- Addresses both small and large users
- Provides adjustability rather than fixed dimensions

**Application rules:**
- **Clearances** (overhead, legroom): Design for 95th percentile (largest)
- **Reach distances**: Design for 5th percentile (smallest)
- **Work surfaces**: Make adjustable to accommodate range

**Example:** A fixed workstation at 95cm height:
- Too high for 5th percentile female (elbow at ~93cm)
- Too low for 95th percentile male (elbow at ~117cm)
- Adjustable range of 85-115cm accommodates both

</details>

<details>
<summary>Question 4: Calculate the NIOSH Lifting Index for the following task and determine if intervention is needed.</summary>

**Task Parameters:**
- Horizontal distance (H): 35 cm
- Vertical height (V): 80 cm
- Travel distance (D): 50 cm
- Asymmetry (A): 0° (symmetric lift)
- Frequency: 4 lifts/minute for 1 hour
- Coupling: Good (handles)
- Actual load: 18 kg

**Solution:**
```
LC = 23 kg
HM = 25/35 = 0.714
VM = 1 - 0.003|80-75| = 0.985
DM = 0.82 + 4.5/50 = 0.91
AM = 1 - 0.0032(0) = 1.0
FM = 0.75 (4/min, 1 hour, V>75cm, from table)
CM = 1.0 (good coupling)

RWL = 23 × 0.714 × 0.985 × 0.91 × 1.0 × 0.75 × 1.0
RWL = 11.0 kg

LI = 18 / 11.0 = 1.64

Risk Level: MODERATE (1.0 < LI < 2.0)
Action: Some workers may be at risk - consider changes
```

**Recommendations:**
- Reduce horizontal distance (bring load closer)
- Reduce lifting frequency
- Use mechanical assist for loads >12 kg

</details>

<details>
<summary>Question 5: What are three advantages of AI-powered ergonomic assessment over traditional methods?</summary>

**1. Scale and Coverage:**
- Traditional: 5-10 assessments per day by trained ergonomist
- AI: Hundreds or thousands of assessments simultaneously
- Can monitor entire facility continuously

**2. Consistency and Objectivity:**
- Traditional: Inter-rater reliability issues; different assessors may score differently
- AI: Consistent scoring algorithm applied uniformly
- Removes subjective interpretation

**3. Real-time Feedback:**
- Traditional: Assessment completed, report generated days/weeks later
- AI: Immediate scoring and alerts
- Can provide real-time coaching to workers

**Additional advantages:**
- Lower cost per assessment
- Non-disruptive (workers not aware of assessment)
- Longitudinal tracking of posture patterns
- Data for predictive analytics

</details>

------------------------------------------------------------------------

## Additional Resources

### Videos

**Ergonomics Fundamentals:**
- [Introduction to Workplace Ergonomics](https://www.youtube.com/watch?v=pKJi-5wjEoI)
- [Safe Manual Handling Techniques](https://www.youtube.com/watch?v=aNZqB30gPfE)

**Assessment Tools:**
- [REBA Assessment Tutorial](https://www.youtube.com/watch?v=wRxLNzgGSBg)
- [RULA Assessment Guide](https://www.youtube.com/watch?v=5GjfCeBtWvE)
- [NIOSH Lifting Equation Explained](https://www.youtube.com/watch?v=BbNfbGRIkLQ)

**AI Ergonomics:**
- [TuMeke AI Ergonomics Demo](https://www.youtube.com/watch?v=N4p4NsA96Zg)
- [VelocityEHS Industrial Ergonomics](https://www.youtube.com/watch?v=QnR7fXD-jmc)

### Online Tools

- [ErgoPlus REBA Calculator](https://ergo-plus.com/reba-assessment-tool-guide/)
- [NIOSH Lifting Equation Calculator](https://www.cdc.gov/niosh/topics/ergonomics/nlecalc.html)
- [Cornell University Ergonomics Web](https://ergo.human.cornell.edu/)

------------------------------------------------------------------------

## References

- Berlin, C., & Adams, C. (2017). *Production Ergonomics: Designing Work Systems to Support Optimal Human Performance*. Ubiquity Press.
- Hignett, S., & McAtamney, L. (2000). Rapid Entire Body Assessment (REBA). *Applied Ergonomics*, 31(2), 201-205.
- McAtamney, L., & Corlett, E.N. (1993). RULA: A Survey Method for Investigation of Work-Related Upper Limb Disorders. *Applied Ergonomics*, 24(2), 91-99.
- NIOSH. (1994). *Applications Manual for the Revised NIOSH Lifting Equation*. DHHS (NIOSH) Publication No. 94-110.
- OSHA. (2000). *Ergonomics: The Study of Work*. OSHA 3125.
- Waters, T.R., Putz-Anderson, V., & Garg, A. (1993). Revised NIOSH Equation for the Design and Evaluation of Manual Lifting Tasks. *Ergonomics*, 36(7), 749-776.
- ISO 11228-1:2021. Ergonomics — Manual handling — Part 1: Lifting, lowering and carrying.
- ISO 11228-3:2007. Ergonomics — Manual handling — Part 3: Handling of low loads at high frequency.

------------------------------------------------------------------------

<!--chapter:end:07-Ergnomics.Rmd-->

# Process Failure Mode and Effects Analysis (PFMEA)

------------------------------------------------------------------------

```{r setup-ch8, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Explain the purpose and benefits of PFMEA in manufacturing
- Distinguish between DFMEA (Design) and PFMEA (Process)
- Apply the 10-step PFMEA methodology to a manufacturing process
- Correctly rate Severity, Occurrence, and Detection using standardized scales
- Calculate Risk Priority Numbers (RPN) and prioritize actions
- Develop recommended actions to reduce process risks
- Create and maintain PFMEA documentation as a living document

> "An ounce of prevention is worth a pound of cure."
> — Benjamin Franklin

------------------------------------------------------------------------

## Introduction to PFMEA

### What is PFMEA?

**Process Failure Mode and Effects Analysis (PFMEA)** is a systematic, proactive method for evaluating a manufacturing or business process to identify where and how it might fail, and to assess the relative impact of different failures. The goal is to identify and prioritize actions that will prevent defects before they occur.

```{r pfmea-definition, echo=FALSE, fig.align="center", fig.cap="PFMEA: A Proactive Quality Tool", fig.width=10, fig.height=5}
ggplot() +
  # Traditional approach
  annotate("rect", xmin = 0, xmax = 4, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 2, y = 2.5, label = "REACTIVE APPROACH", fontface = "bold",
           size = 4, color = "white") +
  annotate("text", x = 2, y = 1.5, label = "Detect → Fix → Repeat\n\nFind defects after\nthey occur",
           size = 3, color = "white", lineheight = 0.9) +
  # PFMEA approach
  annotate("rect", xmin = 5, xmax = 9, ymin = 0, ymax = 3, fill = "#27AE60", alpha = 0.8) +
  annotate("text", x = 7, y = 2.5, label = "PFMEA APPROACH", fontface = "bold",
           size = 4, color = "white") +
  annotate("text", x = 7, y = 1.5, label = "Predict → Prevent → Verify\n\nAnticipate failures\nbefore they occur",
           size = 3, color = "white", lineheight = 0.9) +
  # Arrow
  annotate("segment", x = 4.2, xend = 4.8, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 2, color = "#2C3E50") +
  annotate("text", x = 4.5, y = 2.2, label = "Shift from", size = 3) +
  theme_void() +
  labs(title = "The PFMEA Mindset: Prevention Over Detection",
       subtitle = "Moving from finding defects to preventing them") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

### Brief History of FMEA

```{r fmea-history, echo=FALSE}
history <- tibble(
  `Year` = c("1949", "1960s", "1970s", "1980s", "1990s", "2000s", "2019"),
  `Development` = c("US Military develops FMEA (MIL-P-1629)",
                    "NASA adopts FMEA for Apollo program",
                    "Automotive industry begins using FMEA",
                    "AIAG publishes first FMEA manual",
                    "QS-9000 requires FMEA for automotive suppliers",
                    "FMEA expands to healthcare, service industries",
                    "AIAG-VDA FMEA Handbook published (current standard)"),
  `Significance` = c("First formal FMEA methodology",
                     "Proven reliability in life-critical systems",
                     "Ford, GM, Chrysler adoption drives standardization",
                     "Industry-wide consistency established",
                     "FMEA becomes mandatory in supply chain",
                     "Methodology proves universal applicability",
                     "Harmonized global standard, introduces AP method")
)

history %>%
  kable(format = "html", caption = "Evolution of FMEA") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#34495E", color = "white") %>%
  column_spec(1, bold = TRUE, width = "6em")
```

### DFMEA vs. PFMEA

Two main types of FMEA are used in product development:

```{r dfmea-pfmea-comparison, echo=FALSE, fig.align="center", fig.cap="DFMEA vs PFMEA: Different Focus, Same Methodology", fig.width=10, fig.height=6}
ggplot() +
  # DFMEA box
  annotate("rect", xmin = 0, xmax = 4.5, ymin = 0, ymax = 5, fill = "#3498DB", alpha = 0.8) +
  annotate("text", x = 2.25, y = 4.5, label = "DFMEA", fontface = "bold", size = 6, color = "white") +
  annotate("text", x = 2.25, y = 4, label = "(Design FMEA)", size = 4, color = "white") +
  annotate("text", x = 2.25, y = 2.5,
           label = "Focus: Product Design\n\nAsks: 'What can go wrong\nwith the design?'\n\nOwner: Design Engineer\n\nTiming: During design phase",
           size = 3, color = "white", lineheight = 0.9) +
  # PFMEA box
  annotate("rect", xmin = 5.5, xmax = 10, ymin = 0, ymax = 5, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 7.75, y = 4.5, label = "PFMEA", fontface = "bold", size = 6, color = "white") +
  annotate("text", x = 7.75, y = 4, label = "(Process FMEA)", size = 4, color = "white") +
  annotate("text", x = 7.75, y = 2.5,
           label = "Focus: Manufacturing Process\n\nAsks: 'What can go wrong\nduring production?'\n\nOwner: Process Engineer\n\nTiming: Before production starts",
           size = 3, color = "white", lineheight = 0.9) +
  # Connecting element
  annotate("segment", x = 4.5, xend = 5.5, y = 2.5, yend = 2.5,
           arrow = arrow(length = unit(0.2, "cm"), ends = "both"), size = 1.5, color = "#2C3E50") +
  annotate("text", x = 5, y = 3, label = "Linked", size = 3, fontface = "italic") +
  theme_void() +
  labs(title = "Two Types of FMEA in Product Development") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
```

```{r dfmea-pfmea-table, echo=FALSE}
comparison <- tibble(
  `Aspect` = c("**Primary Question**", "**Failure Mode Example**", "**Effect Example**",
               "**Cause Example**", "**Control Example**", "**Responsible Team**"),
  `DFMEA (Design)` = c("Will the design meet requirements?",
                       "Shaft diameter too small",
                       "Premature bearing failure",
                       "Inadequate stress analysis",
                       "FEA simulation, prototype testing",
                       "Design engineering, R&D"),
  `PFMEA (Process)` = c("Will the process produce conforming parts?",
                        "Shaft turned undersize",
                        "Part fails incoming inspection",
                        "Tool wear not monitored",
                        "In-process gauging, SPC",
                        "Manufacturing, quality, production")
)

comparison %>%
  kable(format = "html", caption = "DFMEA vs PFMEA Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em") %>%
  column_spec(2, background = "#D6EAF8") %>%
  column_spec(3, background = "#FADBD8")
```

<details>
<summary>Question: When should PFMEA be conducted?</summary>

**Ideal Timing for PFMEA:**

1. **New Process Development:** Before production begins, during process design
2. **New Product Introduction:** When a new product will use existing processes
3. **Process Changes:** Whenever significant changes are made to equipment, methods, or materials
4. **Quality Issues:** When field failures or customer complaints indicate process problems
5. **Regular Review:** Periodically (annually) to ensure continued relevance

**Key Principle:** The earlier PFMEA is conducted, the lower the cost of implementing improvements. Changes during design cost 10x less than changes during production, and 100x less than changes after customer delivery.

</details>

### Why PFMEA Matters

```{r pfmea-benefits, echo=FALSE, fig.align="center", fig.cap="Benefits of PFMEA Implementation", fig.width=10, fig.height=5}
benefits <- data.frame(
  benefit = c("Reduced Defects", "Lower Costs", "Customer Satisfaction",
              "Knowledge Capture", "Regulatory Compliance"),
  impact = c(60, 45, 55, 40, 35),
  category = c("Quality", "Financial", "Customer", "Organizational", "Compliance")
)

ggplot(benefits, aes(x = reorder(benefit, impact), y = impact, fill = category)) +
  geom_bar(stat = "identity", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(impact, "%")), hjust = -0.2, fontface = "bold") +
  coord_flip() +
  scale_fill_manual(values = c("Quality" = "#27AE60", "Financial" = "#3498DB",
                               "Customer" = "#F39C12", "Organizational" = "#9B59B6",
                               "Compliance" = "#E74C3C")) +
  scale_y_continuous(limits = c(0, 75)) +
  labs(title = "Reported Benefits from PFMEA Programs",
       subtitle = "Average improvement percentages from industry surveys",
       x = "", y = "Improvement (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

------------------------------------------------------------------------

## PFMEA Fundamentals

### Core Objectives

The fundamental objective of PFMEA is **prevention over detection** — identifying and eliminating potential failures before they occur, rather than finding defects after production.

```{r pfmea-objectives, echo=FALSE}
objectives <- tibble(
  `Objective` = c("**Identify Failure Modes**", "**Assess Risk**", "**Prioritize Actions**",
                  "**Document Knowledge**", "**Drive Improvement**"),
  `Description` = c("Systematically identify all ways the process can fail",
                    "Evaluate severity, likelihood, and detectability of each failure",
                    "Focus resources on highest-risk failure modes",
                    "Capture institutional knowledge in a structured format",
                    "Implement and verify effectiveness of countermeasures"),
  `Outcome` = c("Comprehensive list of potential problems",
                "Quantified risk scores (RPN or AP)",
                "Action plan focused on critical issues",
                "Living document for continuous improvement",
                "Measurable reduction in process risk")
)

objectives %>%
  kable(format = "html", caption = "Core Objectives of PFMEA") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### The PFMEA Team

PFMEA is most effective when conducted by a **cross-functional team**. No single person has all the knowledge needed to identify every potential failure.

```{r pfmea-team, echo=FALSE, fig.align="center", fig.cap="PFMEA Cross-Functional Team", fig.width=10, fig.height=6}
team <- data.frame(
  role = c("Process\nEngineer", "Quality\nEngineer", "Production\nSupervisor",
           "Maintenance\nTech", "Design\nEngineer", "Supplier\nRep"),
  contribution = c("Process knowledge\nEquipment specs", "Historical data\nControl methods",
                   "Day-to-day issues\nOperator insights", "Equipment failures\nMaintenance history",
                   "Design intent\nTolerances", "Material properties\nSupply issues"),
  x = c(1, 2, 3, 1, 2, 3),
  y = c(2, 2, 2, 1, 1, 1)
)

ggplot(team, aes(x = x, y = y)) +
  geom_tile(width = 0.9, height = 0.8, fill = "#3498DB", color = "white", size = 2) +
  geom_text(aes(label = role), color = "white", fontface = "bold", size = 3.5,
            vjust = -0.3, lineheight = 0.8) +
  geom_text(aes(label = contribution), color = "white", size = 2.5,
            vjust = 1.5, lineheight = 0.8) +
  # Facilitator in center
  annotate("point", x = 2, y = 1.5, size = 25, color = "#E74C3C") +
  annotate("text", x = 2, y = 1.5, label = "PFMEA\nFacilitator",
           color = "white", fontface = "bold", size = 3.5, lineheight = 0.9) +
  theme_void() +
  labs(title = "PFMEA Team Composition",
       subtitle = "Each member brings unique knowledge and perspective") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10)) +
  xlim(0.3, 3.7) + ylim(0.3, 2.7)
```

<details>
<summary>Question: Why is a cross-functional team essential?</summary>

**A cross-functional team is essential because:**

1. **Diverse Knowledge:** No single person understands all aspects of the process
2. **Different Perspectives:** Quality sees defects, production sees constraints, maintenance sees failures
3. **Buy-in:** People support what they help create
4. **Historical Knowledge:** Operators often know about problems never formally documented
5. **System Thinking:** Process interactions are visible when multiple functions participate

**Common Mistake:** Having one engineer complete PFMEA alone as a "paperwork exercise." This misses critical failure modes and produces an ineffective document.

**Best Practice:** Minimum 4-6 team members, including at least one person with hands-on process experience.

</details>

### Key Terminology

Understanding PFMEA terminology is essential for effective analysis:

```{r pfmea-terminology, echo=FALSE}
terminology <- tibble(
  `Term` = c("**Process Function**", "**Failure Mode**", "**Failure Effect**",
             "**Severity (S)**", "**Failure Cause**", "**Occurrence (O)**",
             "**Current Controls**", "**Detection (D)**", "**RPN**", "**Action Priority (AP)**"),
  `Definition` = c("What the process step is supposed to do",
                   "How the process can fail to perform its function",
                   "The consequence of the failure on the customer or next operation",
                   "Rating (1-10) of how serious the failure effect is",
                   "Why the failure mode might occur",
                   "Rating (1-10) of how likely the cause is to happen",
                   "What currently prevents the cause or detects the failure",
                   "Rating (1-10) of how likely current controls will detect the failure",
                   "Risk Priority Number = S × O × D",
                   "Alternative prioritization method (AIAG-VDA)"),
  `Example` = c("'Drill hole to 10mm ± 0.1mm'",
                "Hole diameter undersize, oversize, off-location",
                "Part rejected at assembly, field failure",
                "10 = safety hazard, 1 = no effect",
                "Drill bit wear, incorrect feed rate",
                "10 = very high, 1 = remote",
                "In-process gauge, SPC chart",
                "10 = no detection, 1 = certain detection",
                "Range: 1 to 1000",
                "High, Medium, Low")
)

terminology %>%
  kable(format = "html", caption = "PFMEA Key Terminology") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### The PFMEA Form

The PFMEA is documented in a structured form. Here is a simplified template:

```{r pfmea-form, echo=FALSE}
form_template <- tibble(
  `Process Step` = c("Example:", ""),
  `Function` = c("Drill hole", ""),
  `Failure Mode` = c("Hole undersize", ""),
  `Effect` = c("Assembly interference", ""),
  `S` = c("7", ""),
  `Cause` = c("Drill wear", ""),
  `O` = c("5", ""),
  `Current Controls` = c("Visual inspection", ""),
  `D` = c("6", ""),
  `RPN` = c("210", ""),
  `Action` = c("Add in-process gauge", "")
)

form_template %>%
  kable(format = "html", caption = "PFMEA Form Template (Simplified)") %>%
  kable_styling(bootstrap_options = c("bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 10) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  row_spec(1, background = "#D5F5E3")
```

------------------------------------------------------------------------

## The PFMEA Methodology: 10 Steps

PFMEA follows a systematic 10-step methodology. Each step builds on the previous one.

```{r pfmea-steps-overview, echo=FALSE, fig.align="center", fig.cap="The 10-Step PFMEA Methodology", fig.width=10, fig.height=7}
steps <- data.frame(
  step = 1:10,
  name = c("Define Scope", "Map Process", "Identify Failures",
           "Analyze Effects", "Rate Severity", "Identify Causes",
           "Rate Occurrence", "Assess Controls", "Calculate RPN",
           "Take Action"),
  phase = c("Plan", "Plan", "Analyze", "Analyze", "Analyze",
            "Analyze", "Analyze", "Analyze", "Prioritize", "Improve"),
  y = c(5, 5, 4, 4, 4, 3, 3, 3, 2, 2),
  x = c(1, 2, 1, 2, 3, 1, 2, 3, 1.5, 2.5)
)

ggplot(steps, aes(x = x, y = y)) +
  geom_tile(aes(fill = phase), width = 0.9, height = 0.8, color = "white", size = 2) +
  geom_text(aes(label = paste0(step, ". ", name)), color = "white",
            fontface = "bold", size = 3, lineheight = 0.9) +
  scale_fill_manual(values = c("Plan" = "#3498DB", "Analyze" = "#F39C12",
                               "Prioritize" = "#E74C3C", "Improve" = "#27AE60")) +
  # Arrows showing flow
  annotate("segment", x = 1, xend = 2, y = 4.5, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  annotate("segment", x = 2, xend = 1, y = 4.1, yend = 3.5,
           arrow = arrow(length = unit(0.15, "cm")), color = "#2C3E50") +
  theme_void() +
  labs(title = "The 10-Step PFMEA Process",
       subtitle = "A systematic approach to process risk analysis") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10),
        legend.position = "bottom") +
  xlim(0.3, 3.7) + ylim(1.3, 5.7)
```

### Step 1: Define Scope and Process Boundaries

Before starting the analysis, clearly define what is included and excluded.

```{r step1-scope, echo=FALSE}
scope_elements <- tibble(
  `Element` = c("**Process Name**", "**Start Boundary**", "**End Boundary**",
                "**Included Operations**", "**Excluded Operations**", "**Key Assumptions**"),
  `Description` = c("Clear name identifying the process",
                    "Where does our analysis begin?",
                    "Where does our analysis end?",
                    "All operations within scope",
                    "Operations analyzed separately or by others",
                    "Conditions assumed to be true"),
  `Example: Injection Molding` = c("Plastic Part Injection Molding",
                                    "Raw material loading into hopper",
                                    "Part removed from mold, ready for packaging",
                                    "Material prep, injection, cooling, ejection, inspection",
                                    "Mold design (covered by DFMEA), packaging",
                                    "Material meets incoming spec, mold is validated")
)

scope_elements %>%
  kable(format = "html", caption = "Step 1: Defining PFMEA Scope") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### Step 2: Process Mapping and Identifying Functions

Create a detailed process flow diagram and identify the function of each step.

```{r step2-process-map, echo=FALSE, fig.align="center", fig.cap="Example: Injection Molding Process Flow", fig.width=10, fig.height=4}
ggplot() +
  # Process steps
  annotate("rect", xmin = 0, xmax = 1.5, ymin = 0.5, ymax = 1.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 0.75, y = 1, label = "1. Load\nMaterial", size = 3, color = "white", lineheight = 0.9) +

  annotate("rect", xmin = 2, xmax = 3.5, ymin = 0.5, ymax = 1.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 2.75, y = 1, label = "2. Heat &\nPlasticize", size = 3, color = "white", lineheight = 0.9) +

  annotate("rect", xmin = 4, xmax = 5.5, ymin = 0.5, ymax = 1.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 4.75, y = 1, label = "3. Inject\ninto Mold", size = 3, color = "white", lineheight = 0.9) +

  annotate("rect", xmin = 6, xmax = 7.5, ymin = 0.5, ymax = 1.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 6.75, y = 1, label = "4. Cool &\nSolidify", size = 3, color = "white", lineheight = 0.9) +

  annotate("rect", xmin = 8, xmax = 9.5, ymin = 0.5, ymax = 1.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 8.75, y = 1, label = "5. Eject\nPart", size = 3, color = "white", lineheight = 0.9) +

  # Arrows
  annotate("segment", x = 1.5, xend = 2, y = 1, yend = 1,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 3.5, xend = 4, y = 1, yend = 1,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 5.5, xend = 6, y = 1, yend = 1,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 7.5, xend = 8, y = 1, yend = 1,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +

  # Functions below
  annotate("text", x = 0.75, y = 0.2, label = "Function: Supply\ncorrect material",
           size = 2.5, fontface = "italic", lineheight = 0.9) +
  annotate("text", x = 2.75, y = 0.2, label = "Function: Melt\nto spec temp",
           size = 2.5, fontface = "italic", lineheight = 0.9) +
  annotate("text", x = 4.75, y = 0.2, label = "Function: Fill\nmold completely",
           size = 2.5, fontface = "italic", lineheight = 0.9) +
  annotate("text", x = 6.75, y = 0.2, label = "Function: Solidify\nwithout defects",
           size = 2.5, fontface = "italic", lineheight = 0.9) +
  annotate("text", x = 8.75, y = 0.2, label = "Function: Remove\nwithout damage",
           size = 2.5, fontface = "italic", lineheight = 0.9) +

  theme_void() +
  labs(title = "Process Flow Diagram with Functions") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(-0.3, 2)
```

### Step 3: Identifying Potential Failure Modes

For each process function, ask: **"How can this step fail to perform its intended function?"**

```{r step3-failure-modes, echo=FALSE}
failure_modes <- tibble(
  `Process Function` = c("Load correct material", "Load correct material", "Load correct material",
                         "Melt to specification temperature", "Melt to specification temperature",
                         "Fill mold completely", "Fill mold completely", "Fill mold completely"),
  `Potential Failure Mode` = c("Wrong material loaded", "Material contaminated", "Insufficient material",
                                "Temperature too low", "Temperature too high",
                                "Short shot (incomplete fill)", "Flash (overfill)", "Air entrapment"),
  `Category` = c("Wrong item", "Degraded item", "Missing item",
                 "Below specification", "Above specification",
                 "Incomplete operation", "Excessive operation", "Unintended result")
)

failure_modes %>%
  kable(format = "html", caption = "Step 3: Identifying Failure Modes") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#F39C12", color = "white") %>%
  column_spec(1, width = "15em") %>%
  column_spec(3, width = "10em", background = "#FEF9E7")
```

**Common failure mode categories:**
- **No operation** (step doesn't happen)
- **Partial operation** (incomplete)
- **Degraded operation** (below standard)
- **Excessive operation** (too much)
- **Wrong operation** (incorrect action)
- **Intermittent operation** (inconsistent)

<details>
<summary>Interactive Exercise: Identify Failure Modes</summary>

**Process Step:** Heat treat steel parts at 850°C for 2 hours

**Function:** Achieve required hardness (58-62 HRC)

**Identify at least 5 potential failure modes:**

**Answers:**
1. Temperature too low → Parts soft (below hardness spec)
2. Temperature too high → Parts brittle/cracked
3. Time too short → Incomplete hardening
4. Time too long → Over-hardening, distortion
5. Uneven heating → Inconsistent hardness across part
6. Wrong atmosphere → Surface decarburization
7. Quench delay too long → Soft spots

</details>

### Step 4: Analyzing Failure Effects

For each failure mode, determine: **"What is the consequence if this failure occurs?"**

Consider effects at multiple levels:
1. **Local effect:** Impact on immediate operation
2. **Next operation effect:** Impact on downstream process
3. **End customer effect:** Impact on final user

```{r step4-effects, echo=FALSE}
effects <- tibble(
  `Failure Mode` = c("Short shot", "Short shot", "Short shot",
                     "Flash", "Flash", "Flash"),
  `Effect Level` = c("Local", "Next Operation", "End Customer",
                     "Local", "Next Operation", "End Customer"),
  `Effect Description` = c("Part is incomplete/missing features",
                           "Part rejected at inspection, line stoppage",
                           "If shipped: product malfunction, safety hazard",
                           "Excess material on part edges",
                           "Secondary trimming required, increased cycle time",
                           "If shipped: poor fit, appearance defect")
)

effects %>%
  kable(format = "html", caption = "Step 4: Analyzing Effects at Multiple Levels") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(c(3, 6), background = "#FADBD8")
```

### Step 5: Determining Severity Ratings

**Severity (S)** rates the seriousness of the effect on a scale of 1-10.

```{r severity-scale, echo=FALSE}
severity <- tibble(
  `Rating` = 10:1,
  `Effect` = c("Hazardous - without warning",
               "Hazardous - with warning",
               "Very High",
               "High",
               "Moderate",
               "Low",
               "Very Low",
               "Minor",
               "Very Minor",
               "None"),
  `Criteria` = c("Safety hazard; noncompliance with regulations; no warning",
                 "Safety hazard; noncompliance with regulations; with warning",
                 "Product inoperable; loss of primary function",
                 "Product operable but at reduced performance",
                 "Product operable; comfort/convenience affected; noticeable",
                 "Product operable; reduced comfort; noticed by average customer",
                 "Product operable; slightly reduced comfort; noticed by discriminating customer",
                 "Fit/finish nonconforming; noticed by discriminating customer",
                 "Fit/finish nonconforming; noticed only by trained observer",
                 "No discernible effect"),
  `Example` = c("Brake failure without warning",
                "Airbag warning light before failure",
                "Engine won't start",
                "Engine runs rough, reduced power",
                "Wind noise, A/C takes longer to cool",
                "Door handle feels loose",
                "Slight paint imperfection",
                "Panel gap slightly uneven",
                "Under-hood label crooked",
                "No effect observable")
)

severity %>%
  kable(format = "html", caption = "Severity Rating Scale (S)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(1:2, background = "#FADBD8", bold = TRUE) %>%
  row_spec(3:4, background = "#FEF9E7") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

> **Important:** Severity is determined by the **effect**, not the failure mode. Severity can only be reduced by changing the design — process changes typically cannot reduce severity.

### Step 6: Identifying Potential Causes

For each failure mode, identify all possible causes: **"Why might this failure occur?"**

```{r step6-causes, echo=FALSE, fig.align="center", fig.cap="Fishbone Diagram: Causes of Short Shot", fig.width=10, fig.height=6}
ggplot() +
  # Main arrow (spine)
  annotate("segment", x = 0, xend = 9, y = 3, yend = 3, size = 2, color = "#2C3E50") +
  # Effect
  annotate("rect", xmin = 9, xmax = 10.5, ymin = 2.5, ymax = 3.5, fill = "#E74C3C") +
  annotate("text", x = 9.75, y = 3, label = "SHORT\nSHOT", fontface = "bold",
           color = "white", size = 4, lineheight = 0.9) +

  # Machine branch
  annotate("segment", x = 2, xend = 2, y = 3, yend = 5, color = "#3498DB", size = 1.5) +
  annotate("text", x = 2, y = 5.2, label = "MACHINE", fontface = "bold", color = "#3498DB") +
  annotate("text", x = 1.2, y = 4.5, label = "• Worn screw\n• Clogged nozzle\n• Low pressure",
           size = 2.5, hjust = 0, lineheight = 0.9) +

  # Material branch
  annotate("segment", x = 4, xend = 4, y = 3, yend = 5, color = "#27AE60", size = 1.5) +
  annotate("text", x = 4, y = 5.2, label = "MATERIAL", fontface = "bold", color = "#27AE60") +
  annotate("text", x = 3.2, y = 4.5, label = "• High viscosity\n• Contamination\n• Moisture",
           size = 2.5, hjust = 0, lineheight = 0.9) +

  # Method branch
  annotate("segment", x = 6, xend = 6, y = 3, yend = 5, color = "#F39C12", size = 1.5) +
  annotate("text", x = 6, y = 5.2, label = "METHOD", fontface = "bold", color = "#F39C12") +
  annotate("text", x = 5.2, y = 4.5, label = "• Wrong parameters\n• Short shot size\n• Low speed",
           size = 2.5, hjust = 0, lineheight = 0.9) +

  # Mold branch
  annotate("segment", x = 3, xend = 3, y = 3, yend = 1, color = "#9B59B6", size = 1.5) +
  annotate("text", x = 3, y = 0.8, label = "MOLD", fontface = "bold", color = "#9B59B6") +
  annotate("text", x = 2.2, y = 1.5, label = "• Blocked vents\n• Cold spots\n• Gate too small",
           size = 2.5, hjust = 0, lineheight = 0.9) +

  # Man branch
  annotate("segment", x = 6, xend = 6, y = 3, yend = 1, color = "#E74C3C", size = 1.5) +
  annotate("text", x = 6, y = 0.8, label = "MAN", fontface = "bold", color = "#E74C3C") +
  annotate("text", x = 5.2, y = 1.5, label = "• Setup error\n• Wrong program\n• Inadequate training",
           size = 2.5, hjust = 0, lineheight = 0.9) +

  theme_void() +
  labs(title = "Fishbone (Ishikawa) Diagram: Identifying Causes") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(0.3, 5.7)
```

### Step 7: Rating Occurrence

**Occurrence (O)** rates the likelihood that the cause will occur on a scale of 1-10.

```{r occurrence-scale, echo=FALSE}
occurrence <- tibble(
  `Rating` = 10:1,
  `Likelihood` = c("Very High", "Very High", "High", "High",
                   "Moderate", "Moderate", "Low", "Low", "Remote", "Remote"),
  `Criteria` = c("Failure is almost inevitable",
                 "Failures occur very frequently",
                 "Failures occur frequently",
                 "Failures occur on regular basis",
                 "Occasional failures",
                 "Occasional failures expected",
                 "Relatively few failures",
                 "Few failures",
                 "Failure unlikely",
                 "Failure nearly impossible"),
  `Approximate Rate` = c("≥100 per 1000 (≥10%)",
                         "50 per 1000 (5%)",
                         "20 per 1000 (2%)",
                         "10 per 1000 (1%)",
                         "5 per 1000 (0.5%)",
                         "2 per 1000 (0.2%)",
                         "1 per 1000 (0.1%)",
                         "0.5 per 1000 (500 ppm)",
                         "0.1 per 1000 (100 ppm)",
                         "≤0.01 per 1000 (≤10 ppm)"),
  `Cpk Equivalent` = c("< 0.33", "≥ 0.33", "≥ 0.51", "≥ 0.67",
                       "≥ 0.83", "≥ 1.00", "≥ 1.17", "≥ 1.33", "≥ 1.50", "≥ 1.67")
)

occurrence %>%
  kable(format = "html", caption = "Occurrence Rating Scale (O)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#F39C12", color = "white") %>%
  row_spec(1:2, background = "#FADBD8") %>%
  row_spec(3:4, background = "#FEF9E7") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

### Step 8: Current Controls and Detection Ratings

Identify current controls and rate their ability to detect the failure or cause.

**Types of Process Controls:**

```{r control-types, echo=FALSE}
controls <- tibble(
  `Control Type` = c("**Prevention Controls**", "**Detection Controls**"),
  `Purpose` = c("Prevent the cause from occurring",
                "Detect the failure mode or cause after it occurs"),
  `Examples` = c("Error-proofing (poka-yoke), interlocks, maintenance programs",
                 "Inspection, testing, gauging, SPC monitoring"),
  `Impact on PFMEA` = c("Reduces Occurrence rating",
                        "Reduces Detection rating")
)

controls %>%
  kable(format = "html", caption = "Types of Process Controls") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

**Detection Rating Scale:**

```{r detection-scale, echo=FALSE}
detection <- tibble(
  `Rating` = 10:1,
  `Detection` = c("Absolute Uncertainty", "Very Remote", "Remote", "Very Low",
                  "Low", "Moderate", "Moderately High", "High", "Very High", "Almost Certain"),
  `Criteria` = c("No current control; cannot detect or is not analyzed",
                 "Control will probably not detect",
                 "Control has poor chance of detection",
                 "Control has low chance of detection",
                 "Control may detect",
                 "Control has moderate chance of detection",
                 "Control has moderately high chance of detection",
                 "Control has high chance of detection",
                 "Control almost certain to detect",
                 "Control will detect; error-proofed"),
  `Example Control` = c("No inspection planned",
                        "Indirect measurement only",
                        "Visual inspection of hidden feature",
                        "Manual 100% visual inspection",
                        "Variable gauging after operation",
                        "SPC charting",
                        "In-station gauging with feedback",
                        "Automated 100% gauging",
                        "Multiple independent automated checks",
                        "Error-proofing prevents defect creation")
)

detection %>%
  kable(format = "html", caption = "Detection Rating Scale (D)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  row_spec(1:3, background = "#FADBD8") %>%
  row_spec(9:10, background = "#D5F5E3") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

> **Important:** Detection ratings are often **harder to reduce** than occurrence ratings. Adding inspection doesn't prevent defects — it only catches them. Prevention is always better than detection.

<details>
<summary>Question: Why are detection ratings often harder to improve?</summary>

**Detection ratings are harder to reduce because:**

1. **Detection doesn't prevent:** The defect has already been made; you're just trying to find it
2. **Human inspection is unreliable:** Typical effectiveness is only 80-85% for visual inspection
3. **100% inspection is expensive:** Automated inspection requires significant investment
4. **Some defects are hard to detect:** Internal defects, intermittent problems, latent failures
5. **Sampling has limitations:** Even good sampling plans miss some defects

**Better approach:** Focus on reducing occurrence through:
- Error-proofing (poka-yoke)
- Process capability improvement
- Preventive maintenance
- Better training

</details>

### Step 9: Calculating RPN and Prioritization

The **Risk Priority Number (RPN)** combines all three ratings:

$$\text{RPN} = \text{Severity (S)} \times \text{Occurrence (O)} \times \text{Detection (D)}$$

```{r rpn-calculation, echo=TRUE}
# Example RPN Calculations

# Failure Mode 1: Short shot
S1 <- 7    # Severity: Product inoperable (assembly)
O1 <- 5    # Occurrence: Occasional
D1 <- 6    # Detection: Moderate (visual inspection)

RPN1 <- S1 * O1 * D1
cat("Short shot RPN:", RPN1, "\n")

# Failure Mode 2: Flash
S2 <- 4    # Severity: Appearance issue
O2 <- 6    # Occurrence: Regular
D2 <- 3    # Detection: High (easy to see)

RPN2 <- S2 * O2 * D2
cat("Flash RPN:", RPN2, "\n")

# Failure Mode 3: Contamination
S3 <- 9    # Severity: Safety concern (medical device)
O3 <- 3    # Occurrence: Low
D3 <- 7    # Detection: Low (internal contamination)

RPN3 <- S3 * O3 * D3
cat("Contamination RPN:", RPN3, "\n")

# Comparison
cat("\n--- Priority Order by RPN ---\n")
cat("1. Short shot (RPN =", RPN1, ")\n")
cat("2. Contamination (RPN =", RPN3, ")\n")
cat("3. Flash (RPN =", RPN2, ")\n")
```

**RPN Action Thresholds (Traditional):**

```{r rpn-thresholds, echo=FALSE}
thresholds <- tibble(
  `RPN Range` = c("1-50", "51-100", "101-200", "201-500", "501-1000"),
  `Risk Level` = c("Low", "Moderate", "Significant", "High", "Critical"),
  `Action Required` = c("Monitor; no immediate action",
                        "Consider action if resources available",
                        "Action required within planning cycle",
                        "Immediate action required",
                        "Stop production; immediate corrective action")
)

thresholds %>%
  kable(format = "html", caption = "RPN Action Thresholds") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(1, background = "#D5F5E3") %>%
  row_spec(2, background = "#D5F5E3") %>%
  row_spec(3, background = "#FEF9E7") %>%
  row_spec(4, background = "#FADBD8") %>%
  row_spec(5, background = "#E74C3C", color = "white")
```

<details>
<summary>Interactive Exercise: Calculate RPN</summary>

**Calculate the RPN for each failure mode and rank them:**

| Failure Mode | Severity | Occurrence | Detection | RPN |
|--------------|----------|------------|-----------|-----|
| A: Dimension out of spec | 6 | 4 | 5 | ? |
| B: Surface scratch | 3 | 7 | 2 | ? |
| C: Missing component | 8 | 2 | 8 | ? |
| D: Wrong material | 9 | 3 | 6 | ? |

**Answers:**
- A: 6 × 4 × 5 = **120**
- B: 3 × 7 × 2 = **42**
- C: 8 × 2 × 8 = **128**
- D: 9 × 3 × 6 = **162**

**Priority Order:** D (162) > C (128) > A (120) > B (42)

**Question:** Should we always address the highest RPN first? See limitations discussion below.

</details>

### Limitations of RPN

RPN has known limitations that must be understood:

```{r rpn-limitations, echo=FALSE, fig.align="center", fig.cap="RPN Limitation Example", fig.width=9, fig.height=5}
# Show how different S-O-D combinations give same RPN
examples <- data.frame(
  case = c("Case A", "Case B", "Case C"),
  S = c(10, 5, 2),
  O = c(1, 4, 10),
  D = c(4, 2, 2),
  RPN = c(40, 40, 40),
  issue = c("Safety hazard\n(S=10)", "Moderate\n(S=5)", "Minor\n(S=2)")
)

ggplot(examples, aes(x = case)) +
  geom_bar(aes(y = S, fill = "Severity"), stat = "identity", position = position_dodge(width = 0.8), width = 0.25) +
  geom_bar(aes(y = O, fill = "Occurrence"), stat = "identity", position = position_dodge(width = 0.8), width = 0.25) +
  geom_bar(aes(y = D, fill = "Detection"), stat = "identity", position = position_dodge(width = 0.8), width = 0.25) +
  geom_text(aes(y = 11, label = paste0("RPN = ", RPN)), fontface = "bold", size = 4) +
  geom_text(aes(y = -1, label = issue), size = 3, lineheight = 0.9) +
  scale_fill_manual(values = c("Severity" = "#E74C3C", "Occurrence" = "#F39C12", "Detection" = "#3498DB")) +
  labs(title = "Same RPN (40) — Very Different Risk Profiles!",
       subtitle = "Case A is a safety hazard but has the same RPN as minor Case C",
       x = "", y = "Rating Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10, color = "#E74C3C"),
    legend.position = "bottom"
  ) +
  ylim(-2, 12)
```

**Key RPN Limitations:**

1. **Same RPN, different risk:** 10×1×4 = 40, but 2×10×2 = 40
2. **Severity often overlooked:** High severity should always trigger action
3. **Arbitrary thresholds:** Why is 100 the magic number?
4. **Non-linear scale:** Difference between 2 and 3 is not same as 8 and 9

### Action Priority (AP) Method — AIAG-VDA Alternative

The 2019 AIAG-VDA FMEA Handbook introduced the **Action Priority (AP)** method as an alternative to RPN.

```{r ap-method, echo=FALSE}
ap_table <- tibble(
  `Priority` = c("**HIGH**", "**HIGH**", "**MEDIUM**", "**MEDIUM**", "**LOW**"),
  `Criteria` = c("Severity = 9 or 10 (any O, any D)",
                 "Severity = 8 AND Occurrence ≥ 4",
                 "Severity = 7 AND Occurrence ≥ 5",
                 "Severity = 5-6 AND Occurrence ≥ 6 AND Detection ≥ 5",
                 "All other combinations"),
  `Action Required` = c("Must take action to improve prevention/detection",
                        "Must take action",
                        "Should take action",
                        "Should take action",
                        "May take action; document rationale if no action")
)

ap_table %>%
  kable(format = "html", caption = "Action Priority (AP) Method") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  row_spec(1:2, background = "#FADBD8") %>%
  row_spec(3:4, background = "#FEF9E7") %>%
  row_spec(5, background = "#D5F5E3") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

### Step 10: Recommended Actions and Follow-Up

For high-priority items, develop specific recommended actions.

```{r recommended-actions, echo=FALSE}
actions_table <- tibble(
  `Failure Mode` = c("Short shot", "Short shot", "Short shot"),
  `Current RPN` = c(210, 210, 210),
  `Recommended Action` = c("Install shot size monitoring with automatic reject",
                            "Implement preventive maintenance for nozzle cleaning",
                            "Add mold temperature monitoring with alarm"),
  `Responsible` = c("Process Engineer", "Maintenance", "Quality Engineer"),
  `Target Date` = c("2024-03-15", "2024-02-28", "2024-03-01"),
  `Target S` = c(7, 7, 7),
  `Target O` = c(3, 2, 5),
  `Target D` = c(2, 6, 4),
  `Target RPN` = c(42, 84, 140)
)

actions_table %>%
  kable(format = "html", caption = "Step 10: Recommended Actions with Targets") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 10) %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(c(2, 9), bold = TRUE)
```

------------------------------------------------------------------------

## Complete PFMEA Example: Injection Molding

Let's work through a complete PFMEA for an injection molding process step by step.

```{r complete-example, echo=FALSE}
pfmea_example <- tibble(
  `Step` = c("3. Inject", "3. Inject", "3. Inject", "4. Cool", "4. Cool", "5. Eject"),
  `Function` = c("Fill mold completely", "Fill mold completely", "Fill mold completely",
                 "Solidify uniformly", "Solidify uniformly", "Remove without damage"),
  `Failure Mode` = c("Short shot", "Flash", "Air entrapment",
                     "Warpage", "Sink marks", "Stuck in mold"),
  `Effect` = c("Part scrapped, line stoppage", "Secondary trim required", "Weak area, visual defect",
               "Dimensional rejection", "Visual defect", "Part damage, mold damage"),
  `S` = c(7, 4, 6, 7, 5, 8),
  `Cause` = c("Insufficient shot size", "Excessive pressure", "Blocked vent",
              "Uneven cooling", "Thick section, short pack", "Insufficient draft angle"),
  `O` = c(5, 6, 4, 4, 5, 3),
  `Control` = c("Visual inspection", "Visual inspection", "First article inspection",
                "CMM sample check", "Visual inspection", "Ejector pressure monitor"),
  `D` = c(6, 3, 5, 4, 4, 5),
  `RPN` = c(210, 72, 120, 112, 100, 120)
)

pfmea_example %>%
  kable(format = "html", caption = "Complete PFMEA Example: Injection Molding Process") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 10) %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  row_spec(1, background = "#FADBD8") %>%
  column_spec(10, bold = TRUE)
```

```{r rpn-improvement, echo=TRUE}
# Improvement Analysis for Short Shot (Highest RPN = 210)

cat("=== CURRENT STATE ===\n")
S_current <- 7  # Severity (cannot change - inherent to failure)
O_current <- 5  # Occurrence
D_current <- 6  # Detection
RPN_current <- S_current * O_current * D_current
cat("Current RPN:", RPN_current, "(S=7, O=5, D=6)\n\n")

cat("=== IMPROVEMENT OPTIONS ===\n\n")

# Option 1: Improve Detection
cat("Option 1: Add automatic shot weight monitoring\n")
D_option1 <- 2  # Automated detection
RPN_option1 <- S_current * O_current * D_option1
cat("New RPN:", RPN_option1, "(S=7, O=5, D=2)\n")
cat("Reduction:", round((1 - RPN_option1/RPN_current)*100), "%\n\n")

# Option 2: Improve Occurrence (Prevention)
cat("Option 2: Add screw position monitoring with feedback control\n")
O_option2 <- 2  # Much lower occurrence
RPN_option2 <- S_current * O_option2 * D_current
cat("New RPN:", RPN_option2, "(S=7, O=2, D=6)\n")
cat("Reduction:", round((1 - RPN_option2/RPN_current)*100), "%\n\n")

# Option 3: Both improvements
cat("Option 3: Both improvements combined\n")
RPN_option3 <- S_current * O_option2 * D_option1
cat("New RPN:", RPN_option3, "(S=7, O=2, D=2)\n")
cat("Reduction:", round((1 - RPN_option3/RPN_current)*100), "%\n")
```

```{r rpn-comparison-viz, echo=FALSE, fig.align="center", fig.cap="RPN Improvement Comparison", fig.width=9, fig.height=5}
improvement_data <- data.frame(
  option = c("Current", "Option 1:\nDetection", "Option 2:\nOccurrence", "Option 3:\nBoth"),
  RPN = c(210, 70, 84, 28),
  fill = c("#E74C3C", "#F39C12", "#3498DB", "#27AE60")
)

ggplot(improvement_data, aes(x = option, y = RPN, fill = option)) +
  geom_bar(stat = "identity", color = "black", width = 0.6) +
  geom_text(aes(label = RPN), vjust = -0.5, fontface = "bold", size = 5) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "#E74C3C", size = 1) +
  annotate("text", x = 4.5, y = 110, label = "Action threshold", hjust = 0, color = "#E74C3C") +
  scale_fill_manual(values = c("Current" = "#E74C3C", "Option 1:\nDetection" = "#F39C12",
                               "Option 2:\nOccurrence" = "#3498DB", "Option 3:\nBoth" = "#27AE60")) +
  labs(title = "RPN Reduction Through Improvement Actions",
       x = "", y = "Risk Priority Number (RPN)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "none",
    axis.text.x = element_text(size = 10)
  ) +
  ylim(0, 250)
```

------------------------------------------------------------------------

## Industry-Specific PFMEA Examples

### Example: Welding Process

```{r welding-pfmea, echo=FALSE}
welding_pfmea <- tibble(
  `Failure Mode` = c("Incomplete fusion", "Porosity", "Undercut", "Spatter", "Distortion"),
  `Effect` = c("Weak joint, potential crack", "Leak path, strength reduction",
               "Stress concentration, fatigue failure", "Appearance, cleanup required",
               "Dimensional non-conformance"),
  `S` = c(9, 8, 7, 3, 6),
  `Cause` = c("Low heat input, contamination", "Shielding gas issue, moisture",
              "Excessive current, wrong angle", "Wrong parameters, contaminated wire",
              "Excessive heat, improper sequence"),
  `O` = c(4, 5, 4, 6, 4),
  `Current Control` = c("Visual + X-ray sample", "Visual inspection", "Visual inspection",
                        "Visual inspection", "CMM check"),
  `D` = c(4, 5, 4, 2, 5),
  `RPN` = c(144, 200, 112, 36, 120)
)

welding_pfmea %>%
  kable(format = "html", caption = "PFMEA Example: Welding Process") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#E67E22", color = "white") %>%
  row_spec(2, background = "#FADBD8")
```

### Example: Heat Treatment Process

```{r heat-treat-pfmea, echo=FALSE}
heat_treat <- tibble(
  `Failure Mode` = c("Under-hardened", "Over-hardened/Brittle", "Surface decarburization",
                     "Distortion/Warpage", "Quench cracking"),
  `Effect` = c("Premature wear, field failure", "Part cracks under load",
               "Soft surface, wear", "Dimensional rejection", "Scrap, safety hazard"),
  `S` = c(8, 9, 7, 6, 10),
  `Cause` = c("Low temp, short time", "High temp, long time",
              "Wrong atmosphere", "Uneven heating, rapid quench", "Thermal shock, design"),
  `O` = c(4, 3, 4, 5, 2),
  `Current Control` = c("Hardness test sample", "Hardness test sample",
                        "Surface hardness check", "CMM sample", "Visual inspection"),
  `D` = c(4, 4, 5, 4, 6),
  `RPN` = c(128, 108, 140, 120, 120)
)

heat_treat %>%
  kable(format = "html", caption = "PFMEA Example: Heat Treatment Process") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  row_spec(3, background = "#FADBD8")
```

### Example: Food Processing (Pasteurization)

```{r food-pfmea, echo=FALSE}
food_pfmea <- tibble(
  `Failure Mode` = c("Under-processing", "Over-processing", "Temperature deviation",
                     "Time deviation", "Cross-contamination"),
  `Effect` = c("Pathogen survival, food safety", "Nutrient loss, off-flavor",
               "Inconsistent kill, shelf life", "Process variation", "Product recall, illness"),
  `S` = c(10, 5, 8, 6, 10),
  `Cause` = c("Equipment malfunction, calibration", "Control system error",
              "Sensor drift, flow variation", "Timer malfunction", "Gasket leak, CIP failure"),
  `O` = c(2, 3, 3, 3, 2),
  `Current Control` = c("Continuous temp monitoring + chart recorder",
                        "Temperature alarm", "Calibration schedule",
                        "Time verification", "CIP verification + testing"),
  `D` = c(2, 3, 3, 3, 4),
  `RPN` = c(40, 45, 72, 54, 80)
)

food_pfmea %>%
  kable(format = "html", caption = "PFMEA Example: Pasteurization Process") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  row_spec(c(1, 5), background = "#FEF9E7")
```

<details>
<summary>Interactive Exercise: Create a PFMEA</summary>

**Create a simple PFMEA for a coffee brewing process in a commercial setting.**

**Process Steps:**
1. Fill water reservoir
2. Load coffee grounds
3. Brew coffee
4. Dispense into cup

**Identify at least 4 failure modes with S, O, D ratings and RPN.**

**Example Answer:**

| Step | Failure Mode | Effect | S | Cause | O | Control | D | RPN |
|------|--------------|--------|---|-------|---|---------|---|-----|
| 1. Fill water | Wrong water level | Weak/strong coffee | 4 | No level indicator | 5 | Visual check | 5 | 100 |
| 2. Load grounds | Wrong amount | Weak/strong coffee | 4 | No measuring | 6 | Visual check | 6 | 144 |
| 3. Brew | Temperature too low | Under-extracted | 6 | Heating element worn | 3 | Temp display | 4 | 72 |
| 4. Dispense | Overflow | Burn hazard, mess | 8 | Cup sensor failure | 2 | Cup sensor | 4 | 64 |

**Priority:** Wrong amount (144) > Water level (100) > Temperature (72) > Overflow (64)

</details>

------------------------------------------------------------------------

## Integration with Other Quality Tools

PFMEA doesn't exist in isolation — it connects to other quality tools and systems.

```{r integration-diagram, echo=FALSE, fig.align="center", fig.cap="PFMEA Integration with Quality Tools", fig.width=10, fig.height=6}
ggplot() +
  # Central PFMEA
  annotate("point", x = 5, y = 3, size = 30, color = "#E74C3C") +
  annotate("text", x = 5, y = 3, label = "PFMEA", fontface = "bold", size = 5, color = "white") +

  # Connected tools
  # Process Flow
  annotate("point", x = 2, y = 5, size = 18, color = "#3498DB") +
  annotate("text", x = 2, y = 5, label = "Process\nFlow", size = 3, color = "white", lineheight = 0.9) +
  annotate("segment", x = 2.8, xend = 4.2, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 3.2, y = 4.3, label = "Input", size = 2.5, color = "#3498DB") +

  # Control Plan
  annotate("point", x = 8, y = 5, size = 18, color = "#27AE60") +
  annotate("text", x = 8, y = 5, label = "Control\nPlan", size = 3, color = "white", lineheight = 0.9) +
  annotate("segment", x = 5.8, xend = 7.2, y = 3.5, yend = 4.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 6.8, y = 4.3, label = "Output", size = 2.5, color = "#27AE60") +

  # SPC
  annotate("point", x = 8, y = 1, size = 18, color = "#F39C12") +
  annotate("text", x = 8, y = 1, label = "SPC", size = 3, color = "white") +
  annotate("segment", x = 5.8, xend = 7.2, y = 2.5, yend = 1.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 6.8, y = 1.7, label = "Monitoring", size = 2.5, color = "#F39C12") +

  # DFMEA
  annotate("point", x = 2, y = 1, size = 18, color = "#9B59B6") +
  annotate("text", x = 2, y = 1, label = "DFMEA", size = 3, color = "white") +
  annotate("segment", x = 2.8, xend = 4.2, y = 1.5, yend = 2.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 3.2, y = 1.7, label = "Link", size = 2.5, color = "#9B59B6") +

  theme_void() +
  labs(title = "PFMEA Integration with Quality System") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(0.5, 9.5) + ylim(0, 6)
```

### From PFMEA to Control Plan

The PFMEA directly feeds the **Control Plan** — a document that specifies what controls are needed at each process step.

```{r control-plan-link, echo=FALSE}
control_plan <- tibble(
  `From PFMEA` = c("Process Step", "Failure Mode", "Severity", "Cause", "Current Control", "Detection"),
  `To Control Plan` = c("Operation/Step", "Characteristic to Control", "Classification (Critical/Significant)",
                        "Process Parameter", "Control Method", "Reaction Plan")
)

control_plan %>%
  kable(format = "html", caption = "PFMEA to Control Plan Linkage") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white")
```

------------------------------------------------------------------------

## Common Pitfalls and Best Practices

### Common Pitfalls to Avoid

```{r pitfalls, echo=FALSE}
pitfalls <- tibble(
  `Pitfall` = c("**Paperwork Exercise**", "**One-Person Show**", "**Optimistic Detection**",
                "**Static Document**", "**RPN Obsession**", "**Vague Failure Modes**"),
  `Problem` = c("PFMEA done only to satisfy customer requirement",
                "Engineer completes alone without team input",
                "Overestimating effectiveness of current controls",
                "Never updated after process changes",
                "Focusing only on RPN numbers, missing high-severity items",
                "Failure modes too general to be actionable"),
  `Solution` = c("Conduct meaningful analysis with intent to improve",
                 "Require cross-functional team participation",
                 "Validate detection effectiveness with data",
                 "Review and update after any process change",
                 "Also consider severity alone; use AP method",
                 "Be specific: 'hole undersize' not 'bad hole'")
)

pitfalls %>%
  kable(format = "html", caption = "Common PFMEA Pitfalls and Solutions") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em") %>%
  column_spec(2, background = "#FADBD8")
```

### Best Practices

```{r best-practices, echo=FALSE}
practices <- tibble(
  `Practice` = c("**Start Early**", "**Include Operators**", "**Use Historical Data**",
                 "**Be Specific**", "**Follow Up**", "**Living Document**"),
  `Description` = c("Begin PFMEA during process design, not after problems occur",
                    "Operators know failures that never get documented",
                    "Use warranty data, scrap reports, customer complaints",
                    "Specific failure modes lead to specific actions",
                    "Verify that actions were implemented and effective",
                    "Review and update regularly (minimum annually)")
)

practices %>%
  kable(format = "html", caption = "PFMEA Best Practices") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

------------------------------------------------------------------------

## Case Study: Preventing a Major Quality Issue

### Background

**Company:** Automotive brake component manufacturer

**Product:** Brake caliper mounting bracket

**Situation:** New manufacturing process being implemented for a high-volume contract

### PFMEA Analysis

During the PFMEA session, the team identified a critical failure mode:

```{r case-study-finding, echo=FALSE}
case_finding <- tibble(
  `Element` = c("Process Step", "Function", "Failure Mode", "Effect", "Severity",
                "Cause", "Occurrence", "Current Control", "Detection", "RPN"),
  `Analysis` = c("Drill mounting holes", "Create holes at 45.0 ±0.1mm spacing",
                 "Hole spacing out of tolerance", "Caliper misalignment, brake performance affected",
                 "9 (safety-related)", "Fixture wear, thermal expansion", "4 (occasional)",
                 "CMM check 5 per shift", "5 (moderate sampling)", "180")
)

case_finding %>%
  kable(format = "html", caption = "Case Study: Critical Failure Mode Identified") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  row_spec(5, background = "#FADBD8", bold = TRUE) %>%
  row_spec(10, background = "#FADBD8", bold = TRUE)
```

### Actions Taken

Based on the PFMEA, the team implemented:

1. **In-process gauging:** Automated measurement after every part (D: 5 → 2)
2. **Fixture monitoring:** Temperature compensation and wear tracking (O: 4 → 2)
3. **Enhanced fixture design:** Carbide wear surfaces (O: 4 → 2)

```{r case-study-improvement, echo=TRUE}
# Before improvements
S_before <- 9
O_before <- 4
D_before <- 5
RPN_before <- S_before * O_before * D_before
cat("Before RPN:", RPN_before, "\n")

# After improvements
S_after <- 9    # Severity unchanged (inherent)
O_after <- 2    # Reduced through fixture improvements
D_after <- 2    # Reduced through 100% gauging
RPN_after <- S_after * O_after * D_after
cat("After RPN:", RPN_after, "\n")
cat("Reduction:", round((1 - RPN_after/RPN_before)*100), "%\n")
```

### Results

- **Zero field failures** related to hole spacing after 18 months of production
- **Estimated avoided cost:** $2.4 million in potential recall and warranty
- **Investment:** $85,000 for gauging and fixture upgrades
- **ROI:** 28:1

> **Key Lesson:** The PFMEA investment of $85,000 prevented a potential $2.4 million problem. This is the power of proactive risk management.

------------------------------------------------------------------------

## Summary

```{r summary-table-ch8, echo=FALSE}
summary_data <- tibble(
  `Topic` = c("**PFMEA Purpose**", "**Key Ratings**", "**RPN Calculation**",
              "**Prioritization**", "**Action Priority**", "**Best Practice**"),
  `Key Points` = c("Prevent defects before they occur; proactive vs. reactive quality",
                   "Severity (effect), Occurrence (likelihood), Detection (control effectiveness)",
                   "RPN = S × O × D; Range 1-1000; Higher = More risk",
                   "Address high RPN first, but always act on high severity (9-10)",
                   "AIAG-VDA method: High/Medium/Low based on S-O-D combination",
                   "Cross-functional team, living document, follow-up on actions")
)

summary_data %>%
  kable(format = "html", caption = "PFMEA Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "12em")
```

------------------------------------------------------------------------

## Review Questions

### Conceptual Questions

<details>
<summary>Question 1: What is the difference between a failure mode and a failure effect?</summary>

**Failure Mode:** How the process fails to perform its intended function
- Example: "Hole drilled undersize"
- Example: "Temperature too low"
- Example: "Missing component"

**Failure Effect:** The consequence of the failure mode
- Example: "Part rejected at assembly" (effect of undersize hole)
- Example: "Product not properly cured" (effect of low temperature)
- Example: "Product doesn't function" (effect of missing component)

**Key Relationship:** One failure mode can have multiple effects at different levels (local, downstream, customer).

</details>

<details>
<summary>Question 2: Why should PFMEA be conducted by a cross-functional team?</summary>

**Reasons for Cross-Functional Team:**

1. **Diverse expertise:** No single person understands all aspects
2. **Multiple perspectives:** Quality sees defects differently than production
3. **Historical knowledge:** Operators know undocumented problems
4. **Buy-in:** People support what they help create
5. **System thinking:** Process interactions become visible
6. **Better solutions:** Different functions propose different improvements

**Typical team composition:**
- Process Engineer (owner)
- Quality Engineer
- Production Supervisor/Operator
- Maintenance Technician
- Design Engineer
- Supplier Representative (when applicable)

</details>

<details>
<summary>Question 3: Explain why detection ratings are often harder to reduce than occurrence ratings.</summary>

**Detection is harder to reduce because:**

1. **Detection doesn't prevent:** Defect already exists; just trying to find it
2. **Human inspection is unreliable:** 80-85% effectiveness typical
3. **100% inspection is expensive:** Requires automation investment
4. **Some defects are hidden:** Internal defects, intermittent failures
5. **Sampling limitations:** Cannot catch all defects with sampling

**Better approach:** Focus on occurrence reduction:
- Error-proofing (poka-yoke)
- Process capability improvement
- Preventive maintenance
- Better training

**Example:** Reducing drill wear (occurrence) is more effective than adding more inspection (detection).

</details>

<details>
<summary>Question 4: At what point in process development should PFMEA ideally be conducted?</summary>

**Ideal Timing:** During process design, before production begins

**Why early is better:**
- Changes cost 1x during design
- Changes cost 10x during production
- Changes cost 100x after customer delivery

**PFMEA Timing Points:**
1. **New process development:** Before equipment is ordered
2. **New product introduction:** During process planning
3. **Process changes:** Before implementing changes
4. **Quality issues:** When problems indicate process risk
5. **Regular review:** Annually at minimum

**Key Principle:** The earlier PFMEA is conducted, the more opportunity exists to design out failures rather than inspect them out.

</details>

### Calculation Questions

<details>
<summary>Question 5: Given S=8, O=6, D=4, calculate RPN. If improved controls reduce detection to 2, what is the new RPN?</summary>

**Initial Calculation:**
```
RPN = S × O × D
RPN = 8 × 6 × 4 = 192
```

**After Detection Improvement:**
```
New RPN = 8 × 6 × 2 = 96
```

**Analysis:**
- Original RPN: 192 (Significant risk, action required)
- New RPN: 96 (Moderate risk)
- Reduction: 50%

**Note:** Severity (8) remains unchanged because it's determined by the effect, not by process controls. Only occurrence and detection can be reduced through process improvements.

</details>

<details>
<summary>Question 6: Two failure modes have RPNs of 120 and 150. Should the higher RPN always be addressed first?</summary>

**Answer:** Not necessarily!

**Consider the following scenarios:**

**Scenario A:**
- Failure Mode 1: RPN = 150 (S=3, O=10, D=5) — Minor cosmetic issue
- Failure Mode 2: RPN = 120 (S=10, O=3, D=4) — Safety hazard

**Priority:** Address Failure Mode 2 first despite lower RPN because:
- Severity 10 indicates safety hazard
- High-severity items should always be addressed regardless of RPN
- The AP (Action Priority) method would classify this as HIGH priority

**When to prioritize lower RPN:**
- Higher severity (especially 9-10)
- Regulatory or safety implications
- Customer-critical characteristic
- Easier/faster to implement

**Key Lesson:** RPN is a prioritization tool, not the only decision criterion. Use engineering judgment.

</details>

### Application Questions

<details>
<summary>Question 7: For a metal stamping operation, identify at least five potential failure modes and their likely effects.</summary>

**Metal Stamping PFMEA:**

| # | Failure Mode | Effect |
|---|--------------|--------|
| 1 | Part not fully formed | Dimensional rejection, functional failure |
| 2 | Burrs on edges | Injury hazard, assembly interference |
| 3 | Cracks/splits | Structural failure, scrap |
| 4 | Wrong material thickness | Dimensional/strength issues |
| 5 | Mislocated features | Assembly issues, rejection |
| 6 | Surface scratches | Appearance rejection, corrosion initiation |
| 7 | Springback out of tolerance | Dimensional rejection |
| 8 | Die mark/impression | Appearance defect |

**Potential Causes for "Part not fully formed":**
- Insufficient press tonnage
- Die wear
- Material too hard
- Lubrication insufficient
- Press speed too fast

</details>

<details>
<summary>Question 8: A process has RPN of 240 (S=8, O=6, D=5). Propose three improvement strategies and calculate resulting RPN.</summary>

**Current State:** S=8, O=6, D=5, RPN=240

**Strategy 1: Improve Detection**
- Add automated inspection (100% gauging)
- New D = 2
- New RPN = 8 × 6 × 2 = **96** (60% reduction)

**Strategy 2: Improve Occurrence**
- Add error-proofing (poka-yoke) to prevent cause
- New O = 2
- New RPN = 8 × 2 × 5 = **80** (67% reduction)

**Strategy 3: Combined Approach**
- Error-proofing (O → 3) + Better detection (D → 3)
- New RPN = 8 × 3 × 3 = **72** (70% reduction)

**Recommendation:** Strategy 2 (error-proofing) is typically preferred because:
- Prevents defects from occurring
- More sustainable long-term
- Reduces inspection costs
- Better for customer confidence

</details>

### Critical Thinking Questions

<details>
<summary>Question 9: Discuss the limitations of using RPN as the sole prioritization method.</summary>

**RPN Limitations:**

1. **Equal weighting problem:**
   - 10×1×4 = 40 (safety hazard, rare)
   - 2×10×2 = 40 (minor, frequent)
   - Same RPN, very different risk!

2. **Severity often overlooked:**
   - High-severity items (9-10) should always be addressed
   - RPN can hide safety-critical issues

3. **Non-linear scales:**
   - Difference between S=2 and S=3 is not same as S=8 and S=9
   - Multiplication assumes linear relationship

4. **Arbitrary thresholds:**
   - Why is RPN=100 the "action" threshold?
   - No scientific basis for specific cutoffs

5. **Gaming the system:**
   - Teams may manipulate ratings to avoid action
   - Subjectivity in ratings

**Better Approaches:**
- Action Priority (AP) method
- Always act on S ≥ 9 regardless of RPN
- Consider multiple criteria (cost, feasibility, timing)
- Use risk matrix visualization

</details>

<details>
<summary>Question 10: How would you handle a situation where team members disagree on severity ratings?</summary>

**Approach to Rating Disagreements:**

**1. Clarify the failure effect:**
- Ensure everyone understands the same effect
- Be specific about which customer sees which impact

**2. Reference the rating criteria:**
- Use the standardized scale consistently
- Point to specific criteria, not opinions

**3. Consider worst-case scenario:**
- PFMEA should consider worst reasonable case
- "Could this effect happen?" vs "Will it happen?"

**4. Gather data:**
- Review historical data if available
- What have similar failures caused in the past?

**5. When in doubt, go higher:**
- Conservative approach is appropriate for safety
- Can always reduce later with evidence

**6. Document the discussion:**
- Record the rationale for the rating
- Note if there was disagreement and why decision was made

**7. Get external input:**
- Bring in customer perspective if needed
- Consult subject matter experts

**Final Rule:** If a safety or regulatory issue is possible, severity should be 9 or 10 regardless of probability.

</details>

------------------------------------------------------------------------

## References

- AIAG & VDA. (2019). *FMEA Handbook*. Automotive Industry Action Group.
- Stamatis, D.H. (2003). *Failure Mode and Effect Analysis: FMEA from Theory to Execution*. ASQ Quality Press.
- McDermott, R.E., Mikulak, R.J., & Beauregard, M.R. (2009). *The Basics of FMEA*. Productivity Press.
- Carlson, C.S. (2012). *Effective FMEAs: Achieving Safe, Reliable, and Economical Products and Processes*. Wiley.
- SAE J1739. (2009). *Potential Failure Mode and Effects Analysis in Design and Manufacturing*.
- ISO 31000:2018. *Risk management — Guidelines*.
- IATF 16949:2016. *Quality management system requirements for automotive production*.

------------------------------------------------------------------------

<!--chapter:end:08-PFMEA.Rmd-->

# Statistical Process Control (SPC)

------------------------------------------------------------------------

```{r setup-ch9, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
set.seed(42)  # For reproducibility of random examples
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Explain the purpose and benefits of Statistical Process Control
- Distinguish between common cause and special cause variation
- Select the appropriate control chart for different data types
- Construct and interpret X-bar/R, X-bar/S, and Individual-MR charts
- Construct and interpret attribute control charts (p, np, c, u)
- Apply control chart interpretation rules (Western Electric rules)
- Calculate and interpret process capability indices (Cp, Cpk, Pp, Ppk)
- Respond appropriately to out-of-control signals

> "In God we trust; all others must bring data."
> — W. Edwards Deming

------------------------------------------------------------------------

## Introduction to SPC

### What is Statistical Process Control?

**Statistical Process Control (SPC)** is a method of quality control that uses statistical methods to monitor and control a process. It helps ensure that the process operates at its full potential to produce conforming product.

```{r spc-concept, echo=FALSE, fig.align="center", fig.cap="The SPC Philosophy: Prevention Through Monitoring", fig.width=10, fig.height=5}
ggplot() +
  # Without SPC
  annotate("rect", xmin = 0, xmax = 4, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 2, y = 2.5, label = "WITHOUT SPC", fontface = "bold", size = 4, color = "white") +
  annotate("text", x = 2, y = 1.5,
           label = "• Inspect after production\n• Find defects too late\n• React to problems\n• High scrap/rework costs",
           size = 3, color = "white", lineheight = 0.9) +
  # With SPC
  annotate("rect", xmin = 5, xmax = 9, ymin = 0, ymax = 3, fill = "#27AE60", alpha = 0.8) +
  annotate("text", x = 7, y = 2.5, label = "WITH SPC", fontface = "bold", size = 4, color = "white") +
  annotate("text", x = 7, y = 1.5,
           label = "• Monitor during production\n• Detect shifts early\n• Prevent defects\n• Lower costs, higher quality",
           size = 3, color = "white", lineheight = 0.9) +
  # Arrow
  annotate("segment", x = 4.2, xend = 4.8, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 2, color = "#2C3E50") +
  theme_void() +
  labs(title = "The Shift from Inspection to Prevention",
       subtitle = "SPC enables real-time process monitoring and early intervention") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

### Brief History of SPC

```{r spc-history, echo=FALSE}
history <- tibble(
  `Year` = c("1920s", "1930s-40s", "1950s", "1980s", "1990s", "2000s+"),
  `Development` = c("Walter Shewhart develops control charts at Bell Labs",
                    "SPC used in WWII military production",
                    "Deming teaches SPC to Japanese industry",
                    "US automotive industry adopts SPC",
                    "SPC becomes requirement in ISO/QS-9000",
                    "Real-time SPC, automated data collection"),
  `Significance` = c("Birth of modern quality control",
                     "Proved effectiveness in mass production",
                     "Foundation of Japanese quality revolution",
                     "Response to Japanese competition",
                     "Industry-wide standardization",
                     "Integration with Industry 4.0")
)

history %>%
  kable(format = "html", caption = "Evolution of Statistical Process Control") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#34495E", color = "white") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

### Why SPC Matters

```{r spc-benefits, echo=FALSE, fig.align="center", fig.cap="Benefits of SPC Implementation", fig.width=10, fig.height=5}
benefits <- data.frame(
  benefit = c("Reduced Variation", "Lower Scrap", "Fewer Customer Complaints",
              "Reduced Inspection", "Better Decisions"),
  improvement = c(50, 45, 60, 35, 70)
)

ggplot(benefits, aes(x = reorder(benefit, improvement), y = improvement)) +
  geom_bar(stat = "identity", fill = "#3498DB", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(improvement, "%")), hjust = -0.2, fontface = "bold", size = 4) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 85)) +
  labs(title = "Typical Improvements from SPC Implementation",
       subtitle = "Based on industry case studies",
       x = "", y = "Improvement (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    panel.grid.minor = element_blank()
  )
```

------------------------------------------------------------------------

## Understanding Variation

**All processes exhibit variation.** No two products are ever exactly identical. The key insight of SPC is that variation comes from two fundamentally different sources, and we must respond to them differently.

### Common Cause vs. Special Cause Variation

```{r variation-types, echo=FALSE, fig.align="center", fig.cap="Two Types of Variation", fig.width=10, fig.height=6}
# Generate example data
set.seed(123)
n <- 50
common_cause <- rnorm(n, mean = 50, sd = 2)
special_cause <- c(rnorm(35, mean = 50, sd = 2), rnorm(15, mean = 54, sd = 2))

df <- data.frame(
  sample = rep(1:n, 2),
  value = c(common_cause, special_cause),
  type = rep(c("Common Cause Only", "Common + Special Cause"), each = n)
)

ggplot(df, aes(x = sample, y = value)) +
  geom_line(color = "#3498DB") +
  geom_point(color = "#3498DB", size = 2) +
  geom_hline(yintercept = 50, linetype = "dashed", color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(44, 56), linetype = "dotted", color = "#E74C3C", size = 1) +
  facet_wrap(~type, ncol = 1) +
  annotate("text", x = 52, y = 56.5, label = "UCL", color = "#E74C3C", size = 3) +
  annotate("text", x = 52, y = 43.5, label = "LCL", color = "#E74C3C", size = 3) +
  labs(title = "Common Cause vs. Special Cause Variation",
       subtitle = "Notice the shift starting at sample 36 in the bottom chart",
       x = "Sample Number", y = "Measured Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    strip.text = element_text(face = "bold", size = 11)
  )
```

```{r variation-comparison, echo=FALSE}
variation_types <- tibble(
  `Characteristic` = c("**Other Names**", "**Source**", "**Pattern**", "**Predictability**",
                       "**Examples**", "**Action Required**", "**Who Acts**"),
  `Common Cause Variation` = c("Random, chance, noise, inherent",
                                "Built into the process; many small factors",
                                "Random, stable, predictable pattern",
                                "Statistically predictable within limits",
                                "Machine vibration, material variation, ambient temperature",
                                "Improve the system (management decision)",
                                "Management — requires system change"),
  `Special Cause Variation` = c("Assignable, non-random, signal",
                                 "Specific, identifiable event",
                                 "Non-random; shifts, trends, patterns",
                                 "Unpredictable; something changed",
                                 "Tool breakage, new operator, bad material lot, power surge",
                                 "Find and eliminate the cause",
                                 "Operators/technicians — local action")
)

variation_types %>%
  kable(format = "html", caption = "Common Cause vs. Special Cause Variation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em") %>%
  column_spec(2, background = "#D6EAF8") %>%
  column_spec(3, background = "#FADBD8")
```

### The Two Mistakes in Process Control

Understanding variation prevents two costly mistakes:

```{r two-mistakes, echo=FALSE, fig.align="center", fig.cap="The Two Fundamental Mistakes", fig.width=10, fig.height=5}
ggplot() +
  # Mistake 1
  annotate("rect", xmin = 0, xmax = 4.5, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 2.25, y = 2.6, label = "MISTAKE #1", fontface = "bold", size = 4, color = "white") +
  annotate("text", x = 2.25, y = 2.2, label = "Over-adjustment", size = 3.5, color = "white", fontface = "italic") +
  annotate("text", x = 2.25, y = 1.3,
           label = "Treating COMMON cause\nas if it were SPECIAL\n\nResult: Tampering\nIncreased variation!",
           size = 3, color = "white", lineheight = 0.9) +
  # Mistake 2
  annotate("rect", xmin = 5.5, xmax = 10, ymin = 0, ymax = 3, fill = "#F39C12", alpha = 0.8) +
  annotate("text", x = 7.75, y = 2.6, label = "MISTAKE #2", fontface = "bold", size = 4, color = "white") +
  annotate("text", x = 7.75, y = 2.2, label = "Under-reaction", size = 3.5, color = "white", fontface = "italic") +
  annotate("text", x = 7.75, y = 1.3,
           label = "Treating SPECIAL cause\nas if it were COMMON\n\nResult: Missing signals\nDefects produced!",
           size = 3, color = "white", lineheight = 0.9) +
  theme_void() +
  labs(title = "Two Mistakes That Waste Resources and Reduce Quality",
       subtitle = "Control charts help us avoid both mistakes") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

<details>
<summary>The Funnel Experiment: Why Tampering Makes Things Worse</summary>

**Deming's Funnel Experiment** demonstrates why adjusting a stable process increases variation:

**Setup:** Drop a ball through a funnel onto a target. The ball lands near (but not exactly on) the target due to common cause variation.

**Rule 1 (Correct):** Leave the funnel alone. Variation remains constant.

**Rule 2 (Tampering):** After each drop, move the funnel to compensate for the last error.
- Result: Variation DOUBLES!

**Rule 3 (More Tampering):** Move funnel to compensate relative to the target.
- Result: Variation increases without bound!

**Lesson:** Adjusting a stable process based on individual deviations (common cause) actually makes the process worse. Only adjust when special causes are identified.

**Real-World Example:** An operator notices a part is 0.02mm below target and adjusts the machine. The next part is 0.03mm above target (the adjustment plus normal variation). They adjust again... and the process oscillates with increasing variation.

</details>

### When is a Process "In Control"?

A process is **in statistical control** when:

1. Only common cause variation is present
2. All points fall within control limits
3. No non-random patterns exist
4. The process is stable and predictable

```{r in-control-definition, echo=FALSE, fig.align="center", fig.cap="In-Control vs. Out-of-Control Process", fig.width=10, fig.height=5}
set.seed(456)
in_control <- data.frame(
  x = 1:25,
  y = rnorm(25, 50, 2),
  status = "In Control"
)

out_control <- data.frame(
  x = 1:25,
  y = c(rnorm(15, 50, 2), rnorm(10, 54, 2)),
  status = "Out of Control"
)

combined <- rbind(in_control, out_control)

ggplot(combined, aes(x = x, y = y)) +
  geom_line(color = "#3498DB") +
  geom_point(aes(color = y > 56 | y < 44), size = 3) +
  geom_hline(yintercept = 50, linetype = "solid", color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(44, 56), linetype = "dashed", color = "#E74C3C", size = 1) +
  scale_color_manual(values = c("FALSE" = "#3498DB", "TRUE" = "#E74C3C"), guide = "none") +
  facet_wrap(~status) +
  labs(title = "Recognizing In-Control vs. Out-of-Control Conditions",
       x = "Sample Number", y = "Measured Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    strip.text = element_text(face = "bold", size = 11)
  )
```

------------------------------------------------------------------------

## Control Charts: The Foundation of SPC

### What is a Control Chart?

A **control chart** is a graph that shows process data over time with statistically determined control limits. It provides a visual method for distinguishing between common and special cause variation.

```{r control-chart-anatomy, echo=FALSE, fig.align="center", fig.cap="Anatomy of a Control Chart", fig.width=10, fig.height=6}
set.seed(789)
data <- data.frame(
  subgroup = 1:25,
  value = rnorm(25, mean = 100, sd = 3)
)

# Add one out-of-control point
data$value[18] <- 112

mean_val <- mean(data$value[-18])
ucl <- mean_val + 3 * sd(data$value[-18])
lcl <- mean_val - 3 * sd(data$value[-18])

ggplot(data, aes(x = subgroup, y = value)) +
  geom_line(color = "#3498DB", size = 0.8) +
  geom_point(aes(color = value > ucl | value < lcl), size = 3) +
  # Center line
  geom_hline(yintercept = mean_val, color = "#27AE60", size = 1.2) +
  # Control limits
  geom_hline(yintercept = ucl, color = "#E74C3C", linetype = "dashed", size = 1) +
  geom_hline(yintercept = lcl, color = "#E74C3C", linetype = "dashed", size = 1) +
  # Zone lines
  geom_hline(yintercept = mean_val + 2*sd(data$value[-18]), color = "#F39C12", linetype = "dotted") +
  geom_hline(yintercept = mean_val - 2*sd(data$value[-18]), color = "#F39C12", linetype = "dotted") +
  geom_hline(yintercept = mean_val + 1*sd(data$value[-18]), color = "#9B59B6", linetype = "dotted") +
  geom_hline(yintercept = mean_val - 1*sd(data$value[-18]), color = "#9B59B6", linetype = "dotted") +
  # Labels
  annotate("text", x = 26, y = ucl, label = "UCL (+3σ)", hjust = 0, color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 26, y = lcl, label = "LCL (-3σ)", hjust = 0, color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 26, y = mean_val, label = "CL (Mean)", hjust = 0, color = "#27AE60", fontface = "bold") +
  annotate("text", x = 26, y = mean_val + 2*sd(data$value[-18]), label = "+2σ", hjust = 0, color = "#F39C12") +
  annotate("text", x = 26, y = mean_val - 2*sd(data$value[-18]), label = "-2σ", hjust = 0, color = "#F39C12") +
  # Zone labels
  annotate("text", x = 0, y = mean_val + 2.5*sd(data$value[-18]), label = "Zone A", hjust = 1, size = 3) +
  annotate("text", x = 0, y = mean_val + 1.5*sd(data$value[-18]), label = "Zone B", hjust = 1, size = 3) +
  annotate("text", x = 0, y = mean_val + 0.5*sd(data$value[-18]), label = "Zone C", hjust = 1, size = 3) +
  scale_color_manual(values = c("FALSE" = "#3498DB", "TRUE" = "#E74C3C"), guide = "none") +
  labs(title = "Control Chart Structure",
       subtitle = "Control limits set at ±3σ from the center line",
       x = "Subgroup Number", y = "Measured Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  ) +
  xlim(-1, 29)
```

### Control Chart Components

```{r chart-components, echo=FALSE}
components <- tibble(
  `Component` = c("**Center Line (CL)**", "**Upper Control Limit (UCL)**",
                  "**Lower Control Limit (LCL)**", "**Data Points**", "**Zones A, B, C**"),
  `Description` = c("The process average; target for the process",
                    "Upper boundary of expected variation (+3σ)",
                    "Lower boundary of expected variation (-3σ)",
                    "Individual or subgroup statistics plotted over time",
                    "Regions between ±1σ, ±2σ, and ±3σ for pattern analysis"),
  `Purpose` = c("Shows where process is centered",
                "Signals if process shifted too high",
                "Signals if process shifted too low",
                "Visual representation of process behavior",
                "Used for detecting trends and patterns")
)

components %>%
  kable(format = "html", caption = "Control Chart Components") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  column_spec(1, bold = TRUE, width = "14em")
```

### Why ±3 Sigma?

Control limits are set at **±3 standard deviations** from the center line. This is not arbitrary:

- For a normal distribution, 99.73% of data falls within ±3σ
- Only 0.27% (about 3 in 1000) will fall outside by chance
- This balances the risk of both mistakes (false alarms vs. missed signals)

```{r normal-distribution, echo=FALSE, fig.align="center", fig.cap="Normal Distribution and Control Limits", fig.width=10, fig.height=5}
x <- seq(-4, 4, 0.01)
y <- dnorm(x)

df <- data.frame(x = x, y = y)

ggplot(df, aes(x = x, y = y)) +
  geom_line(size = 1.2, color = "#2C3E50") +
  geom_area(data = subset(df, x >= -3 & x <= 3), fill = "#3498DB", alpha = 0.5) +
  geom_area(data = subset(df, x >= -2 & x <= 2), fill = "#27AE60", alpha = 0.5) +
  geom_area(data = subset(df, x >= -1 & x <= 1), fill = "#F39C12", alpha = 0.5) +
  geom_vline(xintercept = c(-3, 3), linetype = "dashed", color = "#E74C3C", size = 1) +
  geom_vline(xintercept = 0, color = "#27AE60", size = 1) +
  annotate("text", x = 0, y = 0.2, label = "68.27%\n(±1σ)", size = 3, fontface = "bold") +
  annotate("text", x = 1.5, y = 0.1, label = "95.45%\n(±2σ)", size = 3) +
  annotate("text", x = 2.5, y = 0.03, label = "99.73%\n(±3σ)", size = 3) +
  annotate("text", x = 3.5, y = 0.01, label = "0.135%", size = 2.5, color = "#E74C3C") +
  annotate("text", x = -3.5, y = 0.01, label = "0.135%", size = 2.5, color = "#E74C3C") +
  scale_x_continuous(breaks = -4:4, labels = c("-4σ", "-3σ", "-2σ", "-1σ", "μ", "+1σ", "+2σ", "+3σ", "+4σ")) +
  labs(title = "The Normal Distribution and Control Limits",
       subtitle = "99.73% of data falls within ±3σ when process is in control",
       x = "Standard Deviations from Mean", y = "Probability Density") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
```

### Choosing the Right Control Chart

The type of control chart depends on the **type of data** being collected:

```{r chart-selection, echo=FALSE, fig.align="center", fig.cap="Control Chart Selection Flowchart", fig.width=10, fig.height=7}
ggplot() +
  # Start
  annotate("rect", xmin = 4, xmax = 6, ymin = 6.5, ymax = 7.5, fill = "#2C3E50", color = "black") +
  annotate("text", x = 5, y = 7, label = "What type\nof data?", color = "white", fontface = "bold", size = 3.5, lineheight = 0.9) +

  # Variable branch
  annotate("segment", x = 4, xend = 2, y = 6.5, yend = 5.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 2.8, y = 6.2, label = "Variable\n(measured)", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 1, xmax = 3, ymin = 4.5, ymax = 5.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 2, y = 5, label = "Sample\nsize?", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Variable - n=1
  annotate("segment", x = 1, xend = 0.5, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 0.5, y = 4.2, label = "n=1", size = 2.5) +
  annotate("rect", xmin = -0.5, xmax = 1.5, ymin = 2.5, ymax = 3.5, fill = "#27AE60", color = "black") +
  annotate("text", x = 0.5, y = 3, label = "I-MR\nChart", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Variable - n=2-9
  annotate("segment", x = 2, xend = 2, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 2.4, y = 4, label = "n=2-9", size = 2.5) +
  annotate("rect", xmin = 1, xmax = 3, ymin = 2.5, ymax = 3.5, fill = "#27AE60", color = "black") +
  annotate("text", x = 2, y = 3, label = "X-bar/R\nChart", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Variable - n≥10
  annotate("segment", x = 3, xend = 3.5, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 3.5, y = 4.2, label = "n≥10", size = 2.5) +
  annotate("rect", xmin = 2.5, xmax = 4.5, ymin = 2.5, ymax = 3.5, fill = "#27AE60", color = "black") +
  annotate("text", x = 3.5, y = 3, label = "X-bar/S\nChart", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Attribute branch
  annotate("segment", x = 6, xend = 8, y = 6.5, yend = 5.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 7.2, y = 6.2, label = "Attribute\n(counted)", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 7, xmax = 9, ymin = 4.5, ymax = 5.5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 8, y = 5, label = "Defectives or\nDefects?", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Defectives
  annotate("segment", x = 7, xend = 6, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 6.3, y = 4.2, label = "Defectives\n(bad units)", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 5, xmax = 7, ymin = 2.5, ymax = 3.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 6, y = 3, label = "p or np\nChart", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Defects
  annotate("segment", x = 9, xend = 10, y = 4.5, yend = 3.5, arrow = arrow(length = unit(0.15, "cm"))) +
  annotate("text", x = 9.7, y = 4.2, label = "Defects\n(count per unit)", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 9, xmax = 11, ymin = 2.5, ymax = 3.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 10, y = 3, label = "c or u\nChart", color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  theme_void() +
  labs(title = "Selecting the Right Control Chart") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(-1, 12) + ylim(2, 8)
```

```{r chart-summary, echo=FALSE}
chart_types <- tibble(
  `Chart Type` = c("**X-bar / R**", "**X-bar / S**", "**I-MR**",
                   "**p chart**", "**np chart**", "**c chart**", "**u chart**"),
  `Data Type` = c("Variable", "Variable", "Variable",
                  "Attribute", "Attribute", "Attribute", "Attribute"),
  `Sample Size` = c("2-9 per subgroup", "≥10 per subgroup", "1 (individuals)",
                    "Variable or constant", "Constant", "Constant", "Variable"),
  `What It Charts` = c("Subgroup mean and range", "Subgroup mean and std dev",
                       "Individual values and moving range",
                       "Proportion defective", "Number defective",
                       "Number of defects", "Defects per unit"),
  `Typical Application` = c("Production sampling, multiple measurements",
                            "Large subgroups, automated measurement",
                            "Continuous processes, expensive testing",
                            "Pass/fail inspection, variable sample size",
                            "Pass/fail inspection, fixed sample size",
                            "Defects per item (scratches, errors)",
                            "Defects per unit area or time")
)

chart_types %>%
  kable(format = "html", caption = "Control Chart Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  row_spec(1:3, background = "#D6EAF8") %>%
  row_spec(4:7, background = "#FCE4D6") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

<details>
<summary>Question: Variable vs. Attribute Data - What's the Difference?</summary>

**Variable Data (Measured):**
- Can take any value within a range
- Measured on a continuous scale
- Examples: length, weight, temperature, voltage, pressure
- More information per measurement
- Smaller sample sizes needed

**Attribute Data (Counted):**
- Discrete categories (good/bad, pass/fail)
- Counted, not measured
- Examples: number of defects, number of rejects, yes/no
- Less information per observation
- Larger sample sizes needed

**When to Use Each:**
- Use variable data when you CAN measure (more powerful)
- Use attribute data when you can only classify or count
- Sometimes you convert variable to attribute (e.g., pass/fail based on tolerance)

</details>

------------------------------------------------------------------------

## Variable Control Charts

### X-bar and R Chart

The **X-bar and R chart** is the most common control chart for variable data. It tracks both the process average (X-bar) and the process spread (Range).

#### Constructing an X-bar/R Chart

**Step 1:** Collect data in subgroups (typically 4-5 samples)

```{r xbar-r-data, echo=TRUE}
# Example: Measuring shaft diameter (mm)
# 25 subgroups of 5 measurements each

set.seed(100)
n_subgroups <- 25
n_samples <- 5

# Generate data
data <- matrix(rnorm(n_subgroups * n_samples, mean = 25.00, sd = 0.05),
               nrow = n_subgroups, ncol = n_samples)

# Add a special cause (shift) at subgroup 18
data[18, ] <- data[18, ] + 0.12

# Calculate statistics for each subgroup
xbar <- apply(data, 1, mean)
R <- apply(data, 1, function(x) max(x) - min(x))

cat("First 5 subgroups:\n")
print(round(data[1:5, ], 4))
cat("\nX-bar values:", round(xbar[1:5], 4))
cat("\nRange values:", round(R[1:5], 4))
```

**Step 2:** Calculate control limits

```{r xbar-r-limits, echo=TRUE}
# Control chart constants for n=5
A2 <- 0.577
D3 <- 0      # D3 = 0 for n < 7
D4 <- 2.114

# Calculate grand mean and average range
X_double_bar <- mean(xbar)
R_bar <- mean(R)

cat("Grand Mean (X-double-bar):", round(X_double_bar, 4), "mm\n")
cat("Average Range (R-bar):", round(R_bar, 4), "mm\n\n")

# X-bar chart limits
UCL_xbar <- X_double_bar + A2 * R_bar
LCL_xbar <- X_double_bar - A2 * R_bar

cat("X-bar Chart:\n")
cat("  UCL =", round(UCL_xbar, 4), "mm\n")
cat("  CL  =", round(X_double_bar, 4), "mm\n")
cat("  LCL =", round(LCL_xbar, 4), "mm\n\n")

# R chart limits
UCL_R <- D4 * R_bar
LCL_R <- D3 * R_bar

cat("R Chart:\n")
cat("  UCL =", round(UCL_R, 4), "mm\n")
cat("  CL  =", round(R_bar, 4), "mm\n")
cat("  LCL =", round(LCL_R, 4), "mm\n")
```

**Step 3:** Plot the charts

```{r xbar-r-plot, echo=FALSE, fig.align="center", fig.cap="X-bar and R Control Charts", fig.width=10, fig.height=8}
# Create data frame for plotting
plot_data <- data.frame(
  subgroup = 1:n_subgroups,
  xbar = xbar,
  R = R
)

# X-bar chart
p1 <- ggplot(plot_data, aes(x = subgroup, y = xbar)) +
  geom_line(color = "#3498DB") +
  geom_point(aes(color = xbar > UCL_xbar | xbar < LCL_xbar), size = 3) +
  geom_hline(yintercept = X_double_bar, color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(UCL_xbar, LCL_xbar), color = "#E74C3C", linetype = "dashed", size = 1) +
  scale_color_manual(values = c("FALSE" = "#3498DB", "TRUE" = "#E74C3C"), guide = "none") +
  annotate("text", x = 26, y = UCL_xbar, label = paste("UCL =", round(UCL_xbar, 3)), hjust = 0, size = 3) +
  annotate("text", x = 26, y = X_double_bar, label = paste("CL =", round(X_double_bar, 3)), hjust = 0, size = 3) +
  annotate("text", x = 26, y = LCL_xbar, label = paste("LCL =", round(LCL_xbar, 3)), hjust = 0, size = 3) +
  labs(title = "X-bar Chart (Process Average)", x = "", y = "X-bar (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  xlim(0, 29)

# R chart
p2 <- ggplot(plot_data, aes(x = subgroup, y = R)) +
  geom_line(color = "#F39C12") +
  geom_point(aes(color = R > UCL_R | R < LCL_R), size = 3) +
  geom_hline(yintercept = R_bar, color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(UCL_R, LCL_R), color = "#E74C3C", linetype = "dashed", size = 1) +
  scale_color_manual(values = c("FALSE" = "#F39C12", "TRUE" = "#E74C3C"), guide = "none") +
  annotate("text", x = 26, y = UCL_R, label = paste("UCL =", round(UCL_R, 3)), hjust = 0, size = 3) +
  annotate("text", x = 26, y = R_bar, label = paste("CL =", round(R_bar, 3)), hjust = 0, size = 3) +
  annotate("text", x = 26, y = LCL_R, label = "LCL = 0", hjust = 0, size = 3) +
  labs(title = "R Chart (Process Spread)", x = "Subgroup Number", y = "Range (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  xlim(0, 29)

gridExtra::grid.arrange(p1, p2, ncol = 1)
```

**Interpretation:** Subgroup 18 shows a point above the UCL on the X-bar chart, indicating a special cause. Investigation reveals the cause and corrective action is taken.

### Control Chart Constants

```{r constants-table, echo=FALSE}
constants <- tibble(
  `n` = 2:10,
  `A2` = c(1.880, 1.023, 0.729, 0.577, 0.483, 0.419, 0.373, 0.337, 0.308),
  `D3` = c(0, 0, 0, 0, 0, 0.076, 0.136, 0.184, 0.223),
  `D4` = c(3.267, 2.574, 2.282, 2.114, 2.004, 1.924, 1.864, 1.816, 1.777),
  `d2` = c(1.128, 1.693, 2.059, 2.326, 2.534, 2.704, 2.847, 2.970, 3.078)
)

constants %>%
  kable(format = "html", caption = "Control Chart Constants for X-bar/R Charts") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  row_spec(4, background = "#D5F5E3")  # Highlight n=5 row
```

### Individual and Moving Range (I-MR) Chart

When sample size is **n = 1** (one measurement per time period), use the **I-MR chart**.

```{r imr-example, echo=FALSE, fig.align="center", fig.cap="Individual and Moving Range Chart", fig.width=10, fig.height=8}
set.seed(200)
n_points <- 30

# Generate individual measurements
individuals <- c(rnorm(20, mean = 100, sd = 3),
                 rnorm(10, mean = 103, sd = 3))  # Shift at point 21

# Calculate moving range
MR <- c(NA, abs(diff(individuals)))

# Calculate limits
X_bar <- mean(individuals[1:20])  # Use only stable period
MR_bar <- mean(MR[2:20], na.rm = TRUE)

UCL_I <- X_bar + 2.66 * MR_bar
LCL_I <- X_bar - 2.66 * MR_bar
UCL_MR <- 3.267 * MR_bar

# Create data frame
imr_data <- data.frame(
  obs = 1:n_points,
  individual = individuals,
  MR = MR
)

# I Chart
p1 <- ggplot(imr_data, aes(x = obs, y = individual)) +
  geom_line(color = "#3498DB") +
  geom_point(aes(color = individual > UCL_I | individual < LCL_I), size = 3) +
  geom_hline(yintercept = X_bar, color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(UCL_I, LCL_I), color = "#E74C3C", linetype = "dashed", size = 1) +
  scale_color_manual(values = c("FALSE" = "#3498DB", "TRUE" = "#E74C3C"), guide = "none") +
  labs(title = "Individual (I) Chart", x = "", y = "Individual Value") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# MR Chart
p2 <- ggplot(imr_data[-1, ], aes(x = obs, y = MR)) +
  geom_line(color = "#F39C12") +
  geom_point(aes(color = MR > UCL_MR), size = 3) +
  geom_hline(yintercept = MR_bar, color = "#27AE60", size = 1) +
  geom_hline(yintercept = UCL_MR, color = "#E74C3C", linetype = "dashed", size = 1) +
  geom_hline(yintercept = 0, color = "#E74C3C", linetype = "dashed", size = 1) +
  scale_color_manual(values = c("FALSE" = "#F39C12", "TRUE" = "#E74C3C"), guide = "none") +
  labs(title = "Moving Range (MR) Chart", x = "Observation Number", y = "Moving Range") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

gridExtra::grid.arrange(p1, p2, ncol = 1)
```

**I-MR Chart Formulas:**

| Chart | Center Line | UCL | LCL |
|-------|-------------|-----|-----|
| I Chart | $\bar{X}$ | $\bar{X} + 2.66\bar{MR}$ | $\bar{X} - 2.66\bar{MR}$ |
| MR Chart | $\bar{MR}$ | $3.267 \times \bar{MR}$ | 0 |

------------------------------------------------------------------------

## Attribute Control Charts

### p Chart (Proportion Defective)

The **p chart** tracks the proportion of defective units when sample sizes may vary.

```{r p-chart-example, echo=TRUE}
# Example: Daily inspection data
# Varying sample sizes (different production volumes)

set.seed(300)
days <- 20
sample_sizes <- sample(80:120, days, replace = TRUE)
defectives <- rbinom(days, sample_sizes, prob = 0.05)

# Add a special cause on day 15
defectives[15] <- rbinom(1, sample_sizes[15], prob = 0.12)

# Calculate proportion
p <- defectives / sample_sizes

# Calculate p-bar (weighted average)
p_bar <- sum(defectives) / sum(sample_sizes)

cat("p-bar (average proportion defective):", round(p_bar, 4), "\n\n")

# Calculate control limits (vary with sample size)
UCL_p <- p_bar + 3 * sqrt(p_bar * (1 - p_bar) / sample_sizes)
LCL_p <- pmax(0, p_bar - 3 * sqrt(p_bar * (1 - p_bar) / sample_sizes))

cat("Sample of control limits (varying with n):\n")
cat("Day 1: UCL =", round(UCL_p[1], 4), ", LCL =", round(LCL_p[1], 4), "(n =", sample_sizes[1], ")\n")
cat("Day 5: UCL =", round(UCL_p[5], 4), ", LCL =", round(LCL_p[5], 4), "(n =", sample_sizes[5], ")\n")
```

```{r p-chart-plot, echo=FALSE, fig.align="center", fig.cap="p Chart for Proportion Defective", fig.width=10, fig.height=5}
p_data <- data.frame(
  day = 1:days,
  p = p,
  UCL = UCL_p,
  LCL = LCL_p,
  n = sample_sizes
)

ggplot(p_data, aes(x = day)) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL), fill = "#3498DB", alpha = 0.2) +
  geom_line(aes(y = p), color = "#3498DB") +
  geom_point(aes(y = p, color = p > UCL | p < LCL), size = 3) +
  geom_line(aes(y = UCL), color = "#E74C3C", linetype = "dashed") +
  geom_line(aes(y = LCL), color = "#E74C3C", linetype = "dashed") +
  geom_hline(yintercept = p_bar, color = "#27AE60", size = 1) +
  scale_color_manual(values = c("FALSE" = "#3498DB", "TRUE" = "#E74C3C"), guide = "none") +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "p Chart: Proportion Defective",
       subtitle = "Control limits vary with sample size (shaded area)",
       x = "Day", y = "Proportion Defective") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
```

### c Chart (Count of Defects)

The **c chart** tracks the number of defects when the sample size (area of opportunity) is constant.

```{r c-chart-example, echo=FALSE, fig.align="center", fig.cap="c Chart for Defects per Unit", fig.width=10, fig.height=5}
set.seed(400)
n_samples <- 25

# Defects per car body (constant opportunity)
defects <- rpois(n_samples, lambda = 8)

# Add special cause at sample 20
defects[20] <- 18

c_bar <- mean(defects)
UCL_c <- c_bar + 3 * sqrt(c_bar)
LCL_c <- max(0, c_bar - 3 * sqrt(c_bar))

c_data <- data.frame(
  sample = 1:n_samples,
  defects = defects
)

ggplot(c_data, aes(x = sample, y = defects)) +
  geom_line(color = "#9B59B6") +
  geom_point(aes(color = defects > UCL_c | defects < LCL_c), size = 3) +
  geom_hline(yintercept = c_bar, color = "#27AE60", size = 1) +
  geom_hline(yintercept = c(UCL_c, LCL_c), color = "#E74C3C", linetype = "dashed", size = 1) +
  scale_color_manual(values = c("FALSE" = "#9B59B6", "TRUE" = "#E74C3C"), guide = "none") +
  annotate("text", x = 26, y = UCL_c, label = paste("UCL =", round(UCL_c, 1)), hjust = 0) +
  annotate("text", x = 26, y = c_bar, label = paste("c-bar =", round(c_bar, 1)), hjust = 0) +
  annotate("text", x = 26, y = LCL_c, label = paste("LCL =", round(LCL_c, 1)), hjust = 0) +
  labs(title = "c Chart: Defects per Car Body",
       x = "Sample Number", y = "Number of Defects") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(0, 29)
```

```{r attribute-formulas, echo=FALSE}
attr_formulas <- tibble(
  `Chart` = c("**p chart**", "**np chart**", "**c chart**", "**u chart**"),
  `Center Line` = c("$\\bar{p} = \\frac{\\sum d}{\\sum n}$",
                    "$\\bar{np} = \\frac{\\sum d}{k}$",
                    "$\\bar{c} = \\frac{\\sum c}{k}$",
                    "$\\bar{u} = \\frac{\\sum c}{\\sum n}$"),
  `UCL` = c("$\\bar{p} + 3\\sqrt{\\frac{\\bar{p}(1-\\bar{p})}{n}}$",
            "$\\bar{np} + 3\\sqrt{\\bar{np}(1-\\bar{p})}$",
            "$\\bar{c} + 3\\sqrt{\\bar{c}}$",
            "$\\bar{u} + 3\\sqrt{\\frac{\\bar{u}}{n}}$"),
  `LCL` = c("$\\bar{p} - 3\\sqrt{\\frac{\\bar{p}(1-\\bar{p})}{n}}$",
            "$\\bar{np} - 3\\sqrt{\\bar{np}(1-\\bar{p})}$",
            "$\\bar{c} - 3\\sqrt{\\bar{c}}$",
            "$\\bar{u} - 3\\sqrt{\\frac{\\bar{u}}{n}}$"),
  `Use When` = c("Variable sample size, proportion needed",
                 "Constant sample size, count preferred",
                 "Constant opportunity, counting defects",
                 "Variable opportunity, defects per unit")
)

attr_formulas %>%
  kable(format = "html", escape = FALSE, caption = "Attribute Control Chart Formulas") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E67E22", color = "white") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

------------------------------------------------------------------------

## Interpreting Control Charts

### Out-of-Control Signals (Western Electric Rules)

A point doesn't have to be outside the control limits to indicate a problem. The **Western Electric Rules** identify non-random patterns:

```{r we-rules, echo=FALSE}
we_rules <- tibble(
  `Rule` = c("Rule 1", "Rule 2", "Rule 3", "Rule 4"),
  `Pattern` = c("**Point beyond control limit**",
                "**Zone A: 2 of 3 consecutive points**",
                "**Zone B: 4 of 5 consecutive points**",
                "**8 consecutive points on one side**"),
  `Description` = c("One point above UCL or below LCL",
                    "2 out of 3 consecutive points in Zone A (>2σ) or beyond, same side",
                    "4 out of 5 consecutive points in Zone B (>1σ) or beyond, same side",
                    "8 consecutive points above or below the center line"),
  `What It Indicates` = c("Sudden shift, extreme event",
                          "Process shift",
                          "Process shift",
                          "Process shift (mean has moved)")
)

we_rules %>%
  kable(format = "html", caption = "Western Electric Rules for Control Chart Interpretation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "6em")
```

```{r we-rules-visual, echo=FALSE, fig.align="center", fig.cap="Visual Examples of Western Electric Rules", fig.width=10, fig.height=8}
# Create example patterns for each rule
set.seed(500)

# Rule 1: Point beyond limit
rule1 <- c(rnorm(10, 0, 1), 3.5, rnorm(9, 0, 1))

# Rule 2: 2 of 3 in Zone A
rule2 <- c(rnorm(8, 0, 1), 2.2, 0.5, 2.4, rnorm(9, 0, 1))

# Rule 3: 4 of 5 in Zone B
rule3 <- c(rnorm(5, 0, 1), 1.2, 1.5, 0.8, 1.4, 1.1, rnorm(10, 0, 1))

# Rule 4: 8 consecutive on one side
rule4 <- c(rnorm(5, 0, 1), rnorm(8, 0.8, 0.5), rnorm(7, 0, 1))

rules_data <- data.frame(
  x = rep(1:20, 4),
  y = c(rule1, rule2, rule3, rule4),
  rule = rep(c("Rule 1: Beyond Limit", "Rule 2: 2 of 3 in Zone A",
               "Rule 3: 4 of 5 in Zone B", "Rule 4: 8 Consecutive"), each = 20)
)

ggplot(rules_data, aes(x = x, y = y)) +
  geom_hline(yintercept = 0, color = "#27AE60", size = 0.8) +
  geom_hline(yintercept = c(-3, 3), color = "#E74C3C", linetype = "dashed") +
  geom_hline(yintercept = c(-2, 2), color = "#F39C12", linetype = "dotted") +
  geom_hline(yintercept = c(-1, 1), color = "#9B59B6", linetype = "dotted") +
  geom_line(color = "#3498DB") +
  geom_point(color = "#3498DB", size = 2) +
  facet_wrap(~rule, ncol = 2, scales = "free_y") +
  labs(title = "Western Electric Rules: Pattern Recognition",
       x = "Sample Number", y = "Standardized Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  )
```

### Additional Patterns to Watch For

```{r additional-patterns, echo=FALSE}
patterns <- tibble(
  `Pattern` = c("**Trend**", "**Cycle**", "**Stratification**", "**Mixture**"),
  `Description` = c("6 or more consecutive points steadily increasing or decreasing",
                    "Repeating high-low pattern",
                    "Points consistently near center line (too little variation)",
                    "Points avoiding center line (bimodal distribution)"),
  `Possible Causes` = c("Tool wear, temperature drift, operator fatigue",
                        "Shift changes, batch effects, temperature cycles",
                        "Incorrect limits, data manipulation, mixed streams",
                        "Two machines, two operators, two material lots")
)

patterns %>%
  kable(format = "html", caption = "Additional Control Chart Patterns") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

<details>
<summary>Interactive Exercise: Identify the Out-of-Control Condition</summary>

**Look at this sequence of points (standardized values):**

0.5, 0.8, 1.2, 0.9, 1.4, 1.6, 1.3, 1.8, -0.2, 0.3

**Questions:**

1. Are any points beyond ±3σ?
2. Is there a Rule 4 violation (8 consecutive on one side)?
3. What pattern do you see?

**Answers:**

1. No — all points are within ±3σ
2. **YES** — Points 1-8 are all positive (above center line)
3. This is a **Rule 4 violation**: 8 consecutive points above the center line indicates a likely process shift upward

**Action:** Investigate what changed — new material lot? Different operator? Equipment adjustment?

</details>

------------------------------------------------------------------------

## Process Capability

### What is Process Capability?

**Process capability** compares the process performance to the specification limits. It answers: "Can this process consistently produce parts within tolerance?"

```{r capability-concept, echo=FALSE, fig.align="center", fig.cap="Process Capability: Comparing Process to Specifications", fig.width=10, fig.height=5}
x <- seq(-5, 5, 0.01)
y <- dnorm(x)

ggplot(data.frame(x, y), aes(x, y)) +
  geom_line(size = 1.2, color = "#3498DB") +
  geom_area(fill = "#3498DB", alpha = 0.3) +
  geom_vline(xintercept = c(-3, 3), color = "#E74C3C", linetype = "dashed", size = 1.2) +
  annotate("segment", x = -4, xend = 4, y = -0.02, yend = -0.02,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), size = 1) +
  annotate("text", x = 0, y = -0.04, label = "Specification Width", fontface = "bold") +
  annotate("segment", x = -3, xend = 3, y = -0.07, yend = -0.07,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), size = 1, color = "#3498DB") +
  annotate("text", x = 0, y = -0.09, label = "Process Width (6σ)", color = "#3498DB", fontface = "bold") +
  annotate("text", x = -4, y = 0.35, label = "LSL", color = "#E74C3C", fontface = "bold") +
  annotate("text", x = 4, y = 0.35, label = "USL", color = "#E74C3C", fontface = "bold") +
  labs(title = "Process Capability: Does the Process Fit Within Specifications?",
       x = "", y = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

### Capability Indices

```{r capability-indices, echo=FALSE}
indices <- tibble(
  `Index` = c("**Cp**", "**Cpk**", "**Pp**", "**Ppk**"),
  `Formula` = c("$\\frac{USL - LSL}{6\\sigma}$",
                "$\\min\\left(\\frac{USL - \\bar{X}}{3\\sigma}, \\frac{\\bar{X} - LSL}{3\\sigma}\\right)$",
                "$\\frac{USL - LSL}{6s}$",
                "$\\min\\left(\\frac{USL - \\bar{X}}{3s}, \\frac{\\bar{X} - LSL}{3s}\\right)$"),
  `What It Measures` = c("Potential capability (spread only)",
                         "Actual capability (spread + centering)",
                         "Overall performance (spread only)",
                         "Overall performance (spread + centering)"),
  `σ Estimation` = c("Within-subgroup (R-bar/d2)",
                     "Within-subgroup (R-bar/d2)",
                     "Overall standard deviation (s)",
                     "Overall standard deviation (s)")
)

indices %>%
  kable(format = "html", escape = FALSE, caption = "Process Capability Indices") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  column_spec(1, bold = TRUE, width = "6em")
```

### Cp vs. Cpk: Why Both Matter

```{r cp-cpk-comparison, echo=FALSE, fig.align="center", fig.cap="Cp vs. Cpk: The Importance of Centering", fig.width=10, fig.height=6}
x <- seq(-6, 6, 0.01)

# Three scenarios
centered <- dnorm(x, mean = 0, sd = 1)
shifted <- dnorm(x, mean = 1.5, sd = 1)
wide <- dnorm(x, mean = 0, sd = 1.5)

df <- data.frame(
  x = rep(x, 3),
  y = c(centered, shifted, wide),
  scenario = rep(c("Centered (Cp=2, Cpk=2)", "Shifted (Cp=2, Cpk=1)", "Wide (Cp=1.33, Cpk=1.33)"), each = length(x))
)

ggplot(df, aes(x = x, y = y)) +
  geom_line(color = "#3498DB", size = 1) +
  geom_area(fill = "#3498DB", alpha = 0.3) +
  geom_vline(xintercept = c(-3, 3), color = "#E74C3C", linetype = "dashed", size = 1) +
  facet_wrap(~scenario, ncol = 3) +
  labs(title = "Same Cp, Different Cpk — Centering Matters!",
       subtitle = "Specification limits at ±3 shown in red",
       x = "", y = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    strip.text = element_text(face = "bold"),
    axis.text = element_blank()
  )
```

### Capability Example Calculation

```{r capability-example, echo=TRUE}
# Example: Shaft diameter specification 25.00 ± 0.15 mm
# Process data from 25 subgroups of 5

USL <- 25.15
LSL <- 24.85
Target <- 25.00

# Using earlier X-bar/R data
X_bar_cap <- mean(xbar)
R_bar_cap <- mean(R)

# Estimate sigma using R-bar/d2 (d2 = 2.326 for n=5)
d2 <- 2.326
sigma_within <- R_bar_cap / d2

cat("Process Statistics:\n")
cat("  Mean (X-bar):", round(X_bar_cap, 4), "mm\n")
cat("  Sigma (estimated):", round(sigma_within, 4), "mm\n\n")

# Calculate Cp
Cp <- (USL - LSL) / (6 * sigma_within)
cat("Cp =", round(Cp, 2), "\n")

# Calculate Cpk
Cpu <- (USL - X_bar_cap) / (3 * sigma_within)
Cpl <- (X_bar_cap - LSL) / (3 * sigma_within)
Cpk <- min(Cpu, Cpl)

cat("Cpu =", round(Cpu, 2), "\n")
cat("Cpl =", round(Cpl, 2), "\n")
cat("Cpk =", round(Cpk, 2), "\n\n")

# Interpretation
cat("Interpretation:\n")
if (Cpk >= 1.33) {
  cat("Process is CAPABLE (Cpk >= 1.33)\n")
} else if (Cpk >= 1.00) {
  cat("Process is MARGINALLY CAPABLE (1.00 <= Cpk < 1.33)\n")
} else {
  cat("Process is NOT CAPABLE (Cpk < 1.00)\n")
}
```

### Capability Index Interpretation

```{r capability-interpretation, echo=FALSE}
cap_interp <- tibble(
  `Cpk Value` = c("< 1.00", "1.00 - 1.33", "1.33 - 1.67", "1.67 - 2.00", "> 2.00"),
  `Sigma Level` = c("< 3σ", "3σ - 4σ", "4σ - 5σ", "5σ - 6σ", "> 6σ"),
  `PPM Defective` = c("> 2,700", "2,700 - 64", "64 - 0.6", "0.6 - 0.002", "< 0.002"),
  `Interpretation` = c("Not capable — improvement required",
                       "Marginally capable — monitor closely",
                       "Capable — meets typical requirements",
                       "Good capability — automotive/aerospace",
                       "Excellent — Six Sigma level"),
  `Typical Industry` = c("Requires immediate action", "Consumer products",
                         "General manufacturing", "Automotive Tier 1",
                         "Aerospace, medical devices")
)

cap_interp %>%
  kable(format = "html", caption = "Capability Index Interpretation Guide") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  row_spec(1, background = "#FADBD8") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3:5, background = "#D5F5E3") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

<details>
<summary>Question: When to use Cp/Cpk vs. Pp/Ppk?</summary>

**Cp/Cpk (Process Capability):**
- Uses within-subgroup variation (σ estimated from R-bar/d2)
- Represents the POTENTIAL capability if process is in control
- Use for ongoing process monitoring
- Requires process to be in statistical control

**Pp/Ppk (Process Performance):**
- Uses overall standard deviation (s) of all data
- Represents ACTUAL performance including all variation
- Use for initial capability studies or when process stability is unknown
- Includes both common and special cause variation

**Rule of Thumb:**
- If Pp ≈ Cp and Ppk ≈ Cpk → Process is stable
- If Pp < Cp or Ppk < Cpk → Process has special cause variation (not in control)

</details>

------------------------------------------------------------------------

## Responding to Out-of-Control Signals

### The Response Process

```{r response-process, echo=FALSE, fig.align="center", fig.cap="Responding to Out-of-Control Conditions", fig.width=10, fig.height=6}
ggplot() +
  # Step boxes
  annotate("rect", xmin = 0, xmax = 2, ymin = 4, ymax = 5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 1, y = 4.5, label = "1. STOP\nMark the point", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 2.5, xmax = 4.5, ymin = 4, ymax = 5, fill = "#F39C12", color = "black") +
  annotate("text", x = 3.5, y = 4.5, label = "2. INVESTIGATE\nFind the cause", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 5, xmax = 7, ymin = 4, ymax = 5, fill = "#3498DB", color = "black") +
  annotate("text", x = 6, y = 4.5, label = "3. CORRECT\nEliminate cause", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 4, ymax = 5, fill = "#27AE60", color = "black") +
  annotate("text", x = 8.5, y = 4.5, label = "4. DOCUMENT\nRecord actions", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Arrows
  annotate("segment", x = 2, xend = 2.5, y = 4.5, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 4.5, xend = 5, y = 4.5, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 7, xend = 7.5, y = 4.5, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +

  # Details below
  annotate("text", x = 1, y = 3.5, label = "• Circle the point\n• Note the time\n• Quarantine product",
           size = 2.5, lineheight = 0.9) +
  annotate("text", x = 3.5, y = 3.5, label = "• Check 5 Ms\n• Review recent changes\n• Ask operators",
           size = 2.5, lineheight = 0.9) +
  annotate("text", x = 6, y = 3.5, label = "• Fix the problem\n• Verify correction\n• Restart process",
           size = 2.5, lineheight = 0.9) +
  annotate("text", x = 8.5, y = 3.5, label = "• Update log\n• File in PFMEA\n• Share lessons",
           size = 2.5, lineheight = 0.9) +

  theme_void() +
  labs(title = "Out-of-Control Response Procedure") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(2.5, 5.5)
```

### Investigation Checklist (5 Ms + E)

```{r investigation-checklist, echo=FALSE}
checklist <- tibble(
  `Category` = c("**Man**", "**Machine**", "**Material**",
                 "**Method**", "**Measurement**", "**Environment**"),
  `Questions to Ask` = c("Different operator? New employee? Fatigue? Training issue?",
                         "Equipment malfunction? Tool wear? Maintenance due? Setup change?",
                         "New lot? Different supplier? Out-of-spec material?",
                         "Procedure changed? Parameter drift? Wrong program?",
                         "Gauge drift? Calibration due? Different inspector?",
                         "Temperature change? Humidity? Vibration? Contamination?")
)

checklist %>%
  kable(format = "html", caption = "Investigation Checklist: 5 Ms + E") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

------------------------------------------------------------------------

## SPC Implementation

### Steps to Implement SPC

```{r implementation-steps, echo=FALSE}
impl_steps <- tibble(
  `Step` = 1:8,
  `Action` = c("Select the process and characteristic",
               "Determine measurement system adequacy (MSA)",
               "Collect initial data (25+ subgroups)",
               "Calculate trial control limits",
               "Identify and remove special causes",
               "Recalculate limits with stable data",
               "Implement ongoing monitoring",
               "Review and improve continuously"),
  `Key Considerations` = c("Start with critical/problem processes",
                           "Gauge R&R must be acceptable (< 30%)",
                           "Process must be running normally",
                           "Limits based on actual process, not specs",
                           "Investigate each out-of-control point",
                           "These become the standard limits",
                           "Train operators, establish reaction plans",
                           "Update limits when process improves")
)

impl_steps %>%
  kable(format = "html", caption = "SPC Implementation Steps") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  column_spec(1, bold = TRUE, width = "5em")
```

### Common SPC Mistakes

```{r spc-mistakes, echo=FALSE}
mistakes <- tibble(
  `Mistake` = c("**Using specification limits as control limits**",
                "**Changing limits too frequently**",
                "**Ignoring the R chart**",
                "**Over-adjusting (tampering)**",
                "**Not acting on signals**"),
  `Why It's Wrong` = c("Control limits are based on process performance, not specs",
                       "Limits should only change when process fundamentally changes",
                       "R chart often signals problems before X-bar chart",
                       "Adjusting for common cause variation increases variation",
                       "Defeats the purpose of SPC"),
  `Correct Approach` = c("Calculate limits from process data (mean ± 3σ)",
                         "Use stable baseline; recalculate only after sustained improvement",
                         "Always analyze R chart first — variation stability",
                         "Only adjust when special cause is identified",
                         "Investigate and act on every out-of-control signal")
)

mistakes %>%
  kable(format = "html", caption = "Common SPC Mistakes and Corrections") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "18em") %>%
  column_spec(2, background = "#FADBD8")
```

------------------------------------------------------------------------

## Summary

```{r summary-table-ch9, echo=FALSE}
summary_data <- tibble(
  `Topic` = c("**Variation**", "**Control Charts**", "**Variable Charts**",
              "**Attribute Charts**", "**Interpretation**", "**Capability**"),
  `Key Points` = c("Common cause (inherent) vs. special cause (assignable); respond differently",
                   "Graph with UCL/LCL at ±3σ; distinguishes between variation types",
                   "X-bar/R (n=2-9), X-bar/S (n≥10), I-MR (n=1)",
                   "p (proportion), np (count defectives), c (defects), u (defects/unit)",
                   "Western Electric rules: beyond limits, 2 of 3 in Zone A, 4 of 5 in Zone B, 8 consecutive",
                   "Cp (potential), Cpk (actual); ≥1.33 is capable; ≥1.67 for automotive")
)

summary_data %>%
  kable(format = "html", caption = "SPC Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "10em")
```

------------------------------------------------------------------------

## Review Questions

### Conceptual Questions

<details>
<summary>Question 1: What is the difference between common cause and special cause variation?</summary>

**Common Cause Variation:**
- Inherent to the process
- Always present
- Random and predictable
- Many small factors
- System-level improvement required
- Examples: machine vibration, material variation, ambient temperature

**Special Cause Variation:**
- External to normal process
- Intermittent or new
- Non-random patterns
- Specific assignable cause
- Local action to eliminate
- Examples: tool breakage, new operator, bad material lot

**Key Point:** Only act on special causes. Attempting to adjust for common cause variation (tampering) makes the process worse.

</details>

<details>
<summary>Question 2: Why are control limits set at ±3 sigma rather than ±2 sigma?</summary>

**At ±3σ:**
- 99.73% of data falls within limits (when in control)
- Only 0.27% false alarm rate (about 3 per 1000 points)
- Good balance between detecting real problems and avoiding false alarms

**If we used ±2σ:**
- 95.45% of data within limits
- 4.55% false alarm rate (about 45 per 1000 points!)
- Too many false alarms → operators ignore the chart

**If we used ±4σ:**
- 99.99% within limits
- Almost no false alarms
- But we'd miss real problems (low sensitivity)

**The ±3σ choice balances:**
- Risk of false alarm (treating common cause as special)
- Risk of missed signal (treating special cause as common)

</details>

<details>
<summary>Question 3: When would you use an I-MR chart instead of an X-bar/R chart?</summary>

**Use I-MR Chart When:**

1. **Sample size is n = 1** — only one measurement per time period
2. **Destructive testing** — can't afford multiple samples
3. **Expensive measurement** — time or cost prohibitive
4. **Continuous process** — each reading is independent (batch process)
5. **Long intervals** — measurements far apart in time
6. **Homogeneous batches** — within-batch variation is negligible

**Examples:**
- Daily chemical batch analysis
- Weekly calibration check
- Each lot incoming inspection (one sample per lot)
- Continuous process temperature readings

**Caution:** I-MR charts are less sensitive than X-bar charts because averaging in subgroups reduces noise.

</details>

### Calculation Questions

<details>
<summary>Question 4: Calculate control limits for an X-bar/R chart given the following data.</summary>

**Given:**
- 20 subgroups of n = 4 measurements
- Grand mean (X-double-bar) = 50.25
- Average range (R-bar) = 2.40
- Constants for n = 4: A2 = 0.729, D3 = 0, D4 = 2.282

**Calculate UCL and LCL for both charts.**

**Solution:**

**X-bar Chart:**
```
UCL = X-double-bar + A2 × R-bar
UCL = 50.25 + 0.729 × 2.40 = 50.25 + 1.75 = 52.00

LCL = X-double-bar - A2 × R-bar
LCL = 50.25 - 0.729 × 2.40 = 50.25 - 1.75 = 48.50

CL = 50.25
```

**R Chart:**
```
UCL = D4 × R-bar = 2.282 × 2.40 = 5.48

LCL = D3 × R-bar = 0 × 2.40 = 0

CL = 2.40
```

</details>

<details>
<summary>Question 5: Calculate Cp and Cpk for a process with the following data.</summary>

**Given:**
- Specification: 100 ± 5 (USL = 105, LSL = 95)
- Process mean = 102
- Process standard deviation (σ) = 1.5

**Solution:**

**Cp (Potential Capability):**
```
Cp = (USL - LSL) / (6σ)
Cp = (105 - 95) / (6 × 1.5)
Cp = 10 / 9 = 1.11
```

**Cpk (Actual Capability):**
```
Cpu = (USL - X-bar) / (3σ) = (105 - 102) / (3 × 1.5) = 3 / 4.5 = 0.67
Cpl = (X-bar - LSL) / (3σ) = (102 - 95) / (3 × 1.5) = 7 / 4.5 = 1.56

Cpk = min(Cpu, Cpl) = min(0.67, 1.56) = 0.67
```

**Interpretation:**
- Cp = 1.11 suggests process spread could fit within specs IF centered
- Cpk = 0.67 shows process is NOT capable because it's shifted toward USL
- Action: Center the process closer to 100 (target)

</details>

<details>
<summary>Question 6: A p chart has p-bar = 0.04 and sample size n = 200. Calculate control limits.</summary>

**Solution:**

**Center Line:**
```
CL = p-bar = 0.04 (4% defective)
```

**Upper Control Limit:**
```
UCL = p-bar + 3 × √(p-bar × (1 - p-bar) / n)
UCL = 0.04 + 3 × √(0.04 × 0.96 / 200)
UCL = 0.04 + 3 × √(0.000192)
UCL = 0.04 + 3 × 0.01386
UCL = 0.04 + 0.0416 = 0.0816 (8.16%)
```

**Lower Control Limit:**
```
LCL = p-bar - 3 × √(p-bar × (1 - p-bar) / n)
LCL = 0.04 - 0.0416 = -0.0016

Since LCL cannot be negative: LCL = 0
```

**Final Limits:**
- UCL = 8.16%
- CL = 4.00%
- LCL = 0%

</details>

### Application Questions

<details>
<summary>Question 7: You observe 8 consecutive points above the center line but all within control limits. What does this indicate?</summary>

**This is a Rule 4 violation (Western Electric Rules).**

**What it indicates:**
- The process mean has shifted upward
- This is a SPECIAL CAUSE signal
- Even though no points are beyond limits, the pattern is not random

**Probability analysis:**
- Probability of a point above CL (random) = 0.5
- Probability of 8 consecutive above CL = 0.5^8 = 0.0039 (0.39%)
- This is very unlikely by chance alone

**Action required:**
1. Stop and mark the chart
2. Investigate what changed around the time of the first high point
3. Check: new material lot? Tool change? Operator change? Temperature?
4. Correct the cause
5. Monitor to verify process returns to normal

</details>

<details>
<summary>Question 8: A process has Cp = 2.0 but Cpk = 1.0. What does this tell you?</summary>

**Analysis:**

**Cp = 2.0 means:**
- Process spread (6σ) is half the specification width
- The process COULD produce no defects if centered
- Potential capability is excellent

**Cpk = 1.0 means:**
- Process is off-center
- Actual capability is only marginal
- Some defects are being produced

**The difference (Cp - Cpk = 1.0) indicates:**
- The process mean is shifted 3σ from the target
- One side has much less margin than the other

**Visual:**
```
LSL        Target        USL
|           |           |
      [====PROCESS====]
      ↑ shifted to one side
```

**Action:**
- Center the process on target
- After centering, Cpk should approach Cp (both ≈ 2.0)
- This is an adjustment action, not a variation reduction

</details>

<details>
<summary>Question 9: Why should you always analyze the R chart before the X-bar chart?</summary>

**The R chart should be analyzed first because:**

1. **Control limits depend on variation:**
   - X-bar limits are calculated using R-bar
   - If R is out of control, X-bar limits are unreliable

2. **R chart is more sensitive to variation changes:**
   - Tool wear shows on R chart before X-bar
   - Inconsistent setup appears as increased R

3. **Process must be stable in variation first:**
   - A process can't be "in control" if variation is changing
   - Stable variation is a prerequisite for evaluating the mean

4. **Different actions for each:**
   - R chart problem → variation issue (consistency)
   - X-bar problem → centering issue (average)

**Rule:** If R chart is out of control, fix that FIRST before interpreting the X-bar chart.

</details>

------------------------------------------------------------------------

## References

- Montgomery, D.C. (2019). *Introduction to Statistical Quality Control* (8th ed.). Wiley.
- Wheeler, D.J., & Chambers, D.S. (1992). *Understanding Statistical Process Control* (2nd ed.). SPC Press.
- AIAG. (2005). *Statistical Process Control (SPC) Reference Manual* (2nd ed.).
- Western Electric. (1956). *Statistical Quality Control Handbook*. AT&T.
- Deming, W.E. (1986). *Out of the Crisis*. MIT Press.
- Shewhart, W.A. (1931). *Economic Control of Quality of Manufactured Product*. Van Nostrand.
- ASTM E2587. Standard Practice for Use of Control Charts in Statistical Process Control.

------------------------------------------------------------------------

<!--chapter:end:09-SPC.Rmd-->

# Total Productive Maintenance (TPM)

------------------------------------------------------------------------

```{r setup-ch10, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

By the end of this chapter, you will be able to:

- Define Total Productive Maintenance and explain its objectives
- Describe the 8 pillars of TPM and their interconnections
- Calculate Overall Equipment Effectiveness (OEE) and its components
- Identify and categorize the Six Big Losses
- Implement autonomous maintenance activities
- Develop preventive and predictive maintenance strategies
- Apply TPM principles to improve equipment reliability and productivity

> "Take care of your equipment, and it will take care of your production."
> — Seiichi Nakajima, Father of TPM

------------------------------------------------------------------------

## Introduction to TPM

### What is Total Productive Maintenance?

**Total Productive Maintenance (TPM)** is a holistic approach to equipment maintenance that strives to achieve perfect production with no breakdowns, no defects, and no accidents. It involves everyone in the organization, from operators to top management.

```{r tpm-definition, echo=FALSE, fig.align="center", fig.cap="The TPM Philosophy", fig.width=10, fig.height=5}
ggplot() +
  # Total
  annotate("rect", xmin = 0, xmax = 3, ymin = 0, ymax = 3, fill = "#3498DB", alpha = 0.8) +
  annotate("text", x = 1.5, y = 2.5, label = "TOTAL", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 1.5, y = 1.5, label = "Everyone\nparticipates\n\nAll departments\nAll levels",
           size = 3, color = "white", lineheight = 0.9) +
  # Productive
  annotate("rect", xmin = 3.5, xmax = 6.5, ymin = 0, ymax = 3, fill = "#27AE60", alpha = 0.8) +
  annotate("text", x = 5, y = 2.5, label = "PRODUCTIVE", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 5, y = 1.5, label = "Maximize\neffectiveness\n\nZero losses\nZero defects",
           size = 3, color = "white", lineheight = 0.9) +
  # Maintenance
  annotate("rect", xmin = 7, xmax = 10, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 8.5, y = 2.5, label = "MAINTENANCE", fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 8.5, y = 1.5, label = "Equipment\ncare\n\nPrevent failures\nExtend life",
           size = 3, color = "white", lineheight = 0.9) +
  theme_void() +
  labs(title = "Total Productive Maintenance: Breaking Down the Name",
       subtitle = "A company-wide approach to equipment effectiveness") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 10))
```

### History of TPM

```{r tpm-history, echo=FALSE}
history <- tibble(
  `Era` = c("Pre-1950s", "1950s", "1960s", "1970s", "1980s", "1990s-Present"),
  `Maintenance Approach` = c("Breakdown Maintenance",
                              "Preventive Maintenance",
                              "Productive Maintenance",
                              "TPM Developed",
                              "TPM Spreads Globally",
                              "TPM + Industry 4.0"),
  `Description` = c("Fix it when it breaks; reactive only",
                    "Scheduled maintenance to prevent failures",
                    "Maintenance focused on reliability and maintainability",
                    "Nakajima develops TPM at Nippondenso (Toyota supplier)",
                    "Adopted by automotive, electronics, process industries worldwide",
                    "Integration with predictive analytics, IoT sensors, AI"),
  `Key Change` = c("No prevention", "Time-based prevention",
                   "Design for maintenance", "Operator involvement",
                   "World-class standard", "Data-driven maintenance")
)

history %>%
  kable(format = "html", caption = "Evolution of Maintenance Philosophy") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#34495E", color = "white") %>%
  row_spec(4, background = "#D5F5E3") %>%
  column_spec(1, bold = TRUE, width = "8em")
```

### The Goals of TPM

TPM aims to achieve **zero** targets:

```{r tpm-goals, echo=FALSE, fig.align="center", fig.cap="TPM Zero Targets", fig.width=9, fig.height=5}
goals <- data.frame(
  goal = c("Zero\nBreakdowns", "Zero\nDefects", "Zero\nAccidents"),
  impact = c("Maximum\nAvailability", "Maximum\nQuality", "Maximum\nSafety"),
  x = c(1, 2, 3)
)

ggplot(goals, aes(x = x, y = 1)) +
  geom_point(size = 30, color = "#E74C3C") +
  geom_text(aes(label = goal), y = 1, color = "white", fontface = "bold", size = 4, lineheight = 0.9) +
  geom_text(aes(label = impact), y = 0.3, color = "#2C3E50", size = 3.5, lineheight = 0.9) +
  annotate("segment", x = 0.3, xend = 3.7, y = 0.6, yend = 0.6,
           arrow = arrow(length = unit(0.2, "cm"), ends = "both"), color = "#27AE60", size = 1.5) +
  annotate("text", x = 2, y = 0.5, label = "= Maximum OEE", color = "#27AE60", fontface = "bold", size = 4) +
  theme_void() +
  labs(title = "TPM Zero Targets") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(0, 1.5)
```

### Traditional vs. TPM Approach

```{r traditional-vs-tpm, echo=FALSE}
comparison <- tibble(
  `Aspect` = c("**Equipment ownership**", "**Maintenance responsibility**",
               "**Operator role**", "**Maintenance focus**",
               "**Problem solving**", "**Goal**"),
  `Traditional Maintenance` = c("'Maintenance owns the machines'",
                                 "Maintenance department only",
                                 "Operate; call maintenance when broken",
                                 "Fix breakdowns quickly",
                                 "Reactive; fire-fighting",
                                 "Minimize maintenance cost"),
  `TPM Approach` = c("'We all own the machines'",
                     "Everyone (operators + maintenance)",
                     "Operate, clean, inspect, maintain",
                     "Prevent breakdowns; extend life",
                     "Proactive; root cause elimination",
                     "Maximize equipment effectiveness")
)

comparison %>%
  kable(format = "html", caption = "Traditional Maintenance vs. TPM") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "14em") %>%
  column_spec(2, background = "#FADBD8") %>%
  column_spec(3, background = "#D5F5E3")
```

<details>
<summary>Question: Why involve operators in maintenance?</summary>

**Operators are the first line of defense because:**

1. **They know the equipment:** Operators work with machines every day and notice subtle changes
2. **Early detection:** Small problems are detected before becoming major failures
3. **Ownership mindset:** People take better care of things they "own"
4. **Reduced response time:** Operators can address minor issues immediately
5. **Freed maintenance resources:** Technicians can focus on complex tasks

**Example:** An operator notices a slight vibration change in a motor. Under traditional maintenance, they might ignore it. Under TPM, they report it, potentially preventing a $50,000 breakdown.

> "No one knows a machine better than the person who operates it every day."

</details>

------------------------------------------------------------------------

## The Eight Pillars of TPM

TPM is built on **eight pillars**, each addressing a specific aspect of equipment management and organizational culture.

```{r eight-pillars, echo=FALSE, fig.align="center", fig.cap="The Eight Pillars of TPM", fig.width=10, fig.height=7}
ggplot() +
  # Foundation
  annotate("rect", xmin = 0, xmax = 10, ymin = 0, ymax = 1, fill = "#2C3E50", color = "black") +
  annotate("text", x = 5, y = 0.5, label = "FOUNDATION: 5S (Sort, Set in Order, Shine, Standardize, Sustain)",
           color = "white", fontface = "bold", size = 3.5) +
  # Roof
  annotate("polygon", x = c(-0.5, 5, 10.5), y = c(5.2, 6.5, 5.2), fill = "#C0392B", color = "black") +
  annotate("text", x = 5, y = 5.7, label = "ZERO LOSSES: Zero Breakdowns • Zero Defects • Zero Accidents",
           color = "white", fontface = "bold", size = 3.5) +

  # Pillar 1
  annotate("rect", xmin = 0.2, xmax = 1.1, ymin = 1.2, ymax = 5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 0.65, y = 3.1, label = "Autonomous\nMaintenance", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 2
  annotate("rect", xmin = 1.4, xmax = 2.3, ymin = 1.2, ymax = 5, fill = "#E67E22", color = "black") +
  annotate("text", x = 1.85, y = 3.1, label = "Planned\nMaintenance", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 3
  annotate("rect", xmin = 2.6, xmax = 3.5, ymin = 1.2, ymax = 5, fill = "#F1C40F", color = "black") +
  annotate("text", x = 3.05, y = 3.1, label = "Quality\nMaintenance", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 4
  annotate("rect", xmin = 3.8, xmax = 4.7, ymin = 1.2, ymax = 5, fill = "#27AE60", color = "black") +
  annotate("text", x = 4.25, y = 3.1, label = "Focused\nImprovement", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 5
  annotate("rect", xmin = 5, xmax = 5.9, ymin = 1.2, ymax = 5, fill = "#3498DB", color = "black") +
  annotate("text", x = 5.45, y = 3.1, label = "Early Equip.\nManagement", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 6
  annotate("rect", xmin = 6.2, xmax = 7.1, ymin = 1.2, ymax = 5, fill = "#9B59B6", color = "black") +
  annotate("text", x = 6.65, y = 3.1, label = "Training &\nEducation", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 7
  annotate("rect", xmin = 7.4, xmax = 8.3, ymin = 1.2, ymax = 5, fill = "#1ABC9C", color = "black") +
  annotate("text", x = 7.85, y = 3.1, label = "Safety, Health\nEnvironment", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +
  # Pillar 8
  annotate("rect", xmin = 8.6, xmax = 9.5, ymin = 1.2, ymax = 5, fill = "#34495E", color = "black") +
  annotate("text", x = 9.05, y = 3.1, label = "TPM in\nOffice", color = "white",
           fontface = "bold", size = 2.5, lineheight = 0.9, angle = 90) +

  theme_void() +
  labs(title = "The House of TPM: Eight Pillars Built on 5S Foundation") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(-0.5, 7)
```

```{r pillars-table, echo=FALSE}
pillars <- tibble(
  `#` = 1:8,
  `Pillar` = c("**Autonomous Maintenance**", "**Planned Maintenance**", "**Quality Maintenance**",
               "**Focused Improvement**", "**Early Equipment Management**", "**Training & Education**",
               "**Safety, Health, Environment**", "**TPM in Office**"),
  `Purpose` = c("Operators maintain their own equipment",
                "Scheduled maintenance by specialists",
                "Zero defects through equipment conditions",
                "Eliminate losses through kaizen activities",
                "Design equipment for maintainability",
                "Develop skilled operators and technicians",
                "Zero accidents, safe workplace",
                "Apply TPM principles to administrative processes"),
  `Key Activities` = c("Cleaning, inspection, lubrication, minor repairs",
                       "PM schedules, predictive maintenance, spare parts",
                       "Identify equipment conditions causing defects",
                       "Loss analysis, root cause, countermeasures",
                       "Design reviews, vertical startup, LCC analysis",
                       "Skills matrix, training programs, OJT",
                       "Hazard identification, safety audits, ergonomics",
                       "Streamline workflows, reduce waste in offices")
)

pillars %>%
  kable(format = "html", caption = "The Eight Pillars of TPM") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#8E44AD", color = "white") %>%
  column_spec(1, bold = TRUE, width = "3em")
```

------------------------------------------------------------------------

## Overall Equipment Effectiveness (OEE)

### What is OEE?

**Overall Equipment Effectiveness (OEE)** is the primary metric of TPM. It measures how effectively equipment is being used by combining three factors: Availability, Performance, and Quality.

```{r oee-formula, echo=FALSE, fig.align="center", fig.cap="OEE Formula and Components", fig.width=10, fig.height=6}
ggplot() +
  # Main formula box
  annotate("rect", xmin = 2, xmax = 8, ymin = 4.5, ymax = 5.5, fill = "#2C3E50", color = "black") +
  annotate("text", x = 5, y = 5, label = "OEE = Availability × Performance × Quality",
           color = "white", fontface = "bold", size = 5) +

  # Three components
  # Availability
  annotate("rect", xmin = 0.5, xmax = 3, ymin = 2, ymax = 4, fill = "#3498DB", color = "black") +
  annotate("text", x = 1.75, y = 3.6, label = "AVAILABILITY", color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 1.75, y = 3, label = "Run Time\n÷\nPlanned Production Time",
           color = "white", size = 3, lineheight = 0.9) +
  annotate("text", x = 1.75, y = 1.5, label = "Downtime\nLosses", color = "#3498DB",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Performance
  annotate("rect", xmin = 3.5, xmax = 6.5, ymin = 2, ymax = 4, fill = "#27AE60", color = "black") +
  annotate("text", x = 5, y = 3.6, label = "PERFORMANCE", color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 5, y = 3, label = "Ideal Cycle Time × Total Count\n÷\nRun Time",
           color = "white", size = 3, lineheight = 0.9) +
  annotate("text", x = 5, y = 1.5, label = "Speed\nLosses", color = "#27AE60",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Quality
  annotate("rect", xmin = 7, xmax = 9.5, ymin = 2, ymax = 4, fill = "#E74C3C", color = "black") +
  annotate("text", x = 8.25, y = 3.6, label = "QUALITY", color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 8.25, y = 3, label = "Good Count\n÷\nTotal Count",
           color = "white", size = 3, lineheight = 0.9) +
  annotate("text", x = 8.25, y = 1.5, label = "Quality\nLosses", color = "#E74C3C",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Arrows
  annotate("segment", x = 1.75, xend = 1.75, y = 4, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 5, xend = 5, y = 4, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 8.25, xend = 8.25, y = 4, yend = 4.5,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +

  theme_void() +
  labs(title = "OEE: The TPM Scorecard") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(1, 6)
```

### OEE Component Formulas

```{r oee-formulas, echo=FALSE}
oee_formulas <- tibble(
  `Component` = c("**Availability**", "**Performance**", "**Quality**", "**OEE**"),
  `Formula` = c("$\\frac{\\text{Run Time}}{\\text{Planned Production Time}} \\times 100\\%$",
                "$\\frac{\\text{Ideal Cycle Time} \\times \\text{Total Count}}{\\text{Run Time}} \\times 100\\%$",
                "$\\frac{\\text{Good Count}}{\\text{Total Count}} \\times 100\\%$",
                "$\\text{Availability} \\times \\text{Performance} \\times \\text{Quality}$"),
  `What It Measures` = c("Time the equipment is running vs. planned time",
                         "How fast equipment runs vs. design speed",
                         "Good parts vs. total parts produced",
                         "Overall effectiveness combining all three"),
  `Losses Captured` = c("Breakdowns, changeovers, adjustments",
                        "Minor stops, reduced speed, idling",
                        "Defects, rework, startup rejects",
                        "All six big losses combined")
)

oee_formulas %>%
  kable(format = "html", escape = FALSE, caption = "OEE Component Formulas") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  row_spec(4, background = "#D5F5E3") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

### OEE Calculation Example

```{r oee-calculation, echo=TRUE}
# OEE Calculation Example: Injection Molding Machine

cat("=== SHIFT DATA ===\n")
# Time data
shift_length <- 480  # minutes (8 hours)
planned_downtime <- 30  # breaks, planned maintenance
planned_production_time <- shift_length - planned_downtime
cat("Planned Production Time:", planned_production_time, "minutes\n")

# Downtime losses
breakdown_time <- 25  # equipment failure
changeover_time <- 35  # mold changes
adjustment_time <- 10  # setup adjustments
total_downtime <- breakdown_time + changeover_time + adjustment_time
cat("Unplanned Downtime:", total_downtime, "minutes\n")

run_time <- planned_production_time - total_downtime
cat("Run Time:", run_time, "minutes\n\n")

# Production data
ideal_cycle_time <- 0.5  # minutes per part (design spec)
total_parts <- 700  # parts produced
good_parts <- 665   # parts passing inspection
defects <- total_parts - good_parts

cat("=== PRODUCTION DATA ===\n")
cat("Total Parts Produced:", total_parts, "\n")
cat("Good Parts:", good_parts, "\n")
cat("Defects:", defects, "\n\n")

# Calculate OEE Components
cat("=== OEE CALCULATION ===\n\n")

# Availability
availability <- (run_time / planned_production_time) * 100
cat("AVAILABILITY:\n")
cat("  = Run Time / Planned Production Time\n")
cat("  =", run_time, "/", planned_production_time, "\n")
cat("  =", round(availability, 1), "%\n\n")

# Performance
# Actual output vs. theoretical output during run time
theoretical_output <- run_time / ideal_cycle_time
performance <- (total_parts / theoretical_output) * 100
cat("PERFORMANCE:\n")
cat("  Theoretical Output =", theoretical_output, "parts\n")
cat("  Actual Output =", total_parts, "parts\n")
cat("  = Actual / Theoretical\n")
cat("  =", round(performance, 1), "%\n\n")

# Quality
quality <- (good_parts / total_parts) * 100
cat("QUALITY:\n")
cat("  = Good Parts / Total Parts\n")
cat("  =", good_parts, "/", total_parts, "\n")
cat("  =", round(quality, 1), "%\n\n")

# Overall OEE
oee <- (availability/100) * (performance/100) * (quality/100) * 100
cat("=== OVERALL OEE ===\n")
cat("OEE =", round(availability, 1), "% ×", round(performance, 1), "% ×", round(quality, 1), "%\n")
cat("OEE =", round(oee, 1), "%\n")
```

```{r oee-waterfall, echo=FALSE, fig.align="center", fig.cap="OEE Waterfall Chart: Where Time Goes", fig.width=10, fig.height=6}
# Create waterfall data
waterfall <- data.frame(
  category = c("Shift Time", "Planned DT", "Breakdowns", "Changeover",
               "Speed Loss", "Defects", "Value-Added"),
  value = c(480, -30, -25, -45, -30, -17.5, 332.5),
  type = c("start", "loss", "loss", "loss", "loss", "loss", "end")
)

waterfall$end <- cumsum(c(480, -30, -25, -45, -30, -17.5, 0))
waterfall$start <- c(0, waterfall$end[1:6])
waterfall$start[7] <- 0

ggplot(waterfall, aes(x = reorder(category, -abs(value)))) +
  geom_rect(aes(xmin = as.numeric(factor(category)) - 0.4,
                xmax = as.numeric(factor(category)) + 0.4,
                ymin = pmin(start, end), ymax = pmax(start, end),
                fill = type), color = "black") +
  geom_text(aes(y = (start + end)/2, label = abs(value)), fontface = "bold") +
  scale_fill_manual(values = c("start" = "#3498DB", "loss" = "#E74C3C", "end" = "#27AE60")) +
  scale_x_discrete(limits = c("Shift Time", "Planned DT", "Breakdowns", "Changeover",
                               "Speed Loss", "Defects", "Value-Added")) +
  labs(title = "OEE Waterfall: From Total Time to Value-Added Time",
       subtitle = "Every loss category reduces available productive time",
       x = "", y = "Minutes") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "none",
    axis.text.x = element_text(angle = 30, hjust = 1)
  )
```

### OEE Benchmarks

```{r oee-benchmarks, echo=FALSE}
benchmarks <- tibble(
  `OEE Level` = c("< 65%", "65% - 75%", "75% - 85%", "> 85%"),
  `Classification` = c("Unacceptable", "Typical", "Good", "World Class"),
  `Interpretation` = c("Significant improvement opportunities exist",
                       "Average for discrete manufacturing",
                       "Well-managed operations",
                       "Best-in-class performance"),
  `Component Targets` = c("—", "A: 90%, P: 85%, Q: 95%",
                          "A: 92%, P: 90%, Q: 97%", "A: 95%, P: 95%, Q: 99%")
)

benchmarks %>%
  kable(format = "html", caption = "OEE Benchmarks") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  row_spec(1, background = "#FADBD8") %>%
  row_spec(2, background = "#FEF9E7") %>%
  row_spec(3, background = "#D5F5E3") %>%
  row_spec(4, background = "#D5F5E3", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "8em")
```

<details>
<summary>Interactive Exercise: Calculate OEE</summary>

**Given the following shift data, calculate OEE:**

- Shift length: 480 minutes
- Planned breaks: 40 minutes
- Equipment breakdown: 30 minutes
- Setup/changeover: 20 minutes
- Ideal cycle time: 1 minute/part
- Total parts produced: 350
- Rejected parts: 14

**Work through the calculation:**

**Solution:**

```
Planned Production Time = 480 - 40 = 440 minutes
Run Time = 440 - 30 - 20 = 390 minutes

Availability = 390 / 440 = 88.6%

Theoretical Output = 390 / 1 = 390 parts
Performance = 350 / 390 = 89.7%

Quality = (350 - 14) / 350 = 336 / 350 = 96.0%

OEE = 88.6% × 89.7% × 96.0% = 76.3%
```

**Interpretation:** This is "Good" performance, above the typical range. The biggest opportunity is in Performance (speed losses).

</details>

------------------------------------------------------------------------

## The Six Big Losses

TPM categorizes all equipment losses into **six categories**, which map directly to the OEE components.

```{r six-big-losses, echo=FALSE, fig.align="center", fig.cap="The Six Big Losses", fig.width=10, fig.height=7}
ggplot() +
  # Availability losses (red)
  annotate("rect", xmin = 0, xmax = 3.2, ymin = 4, ymax = 6.5, fill = "#3498DB", alpha = 0.2) +
  annotate("text", x = 1.6, y = 6.2, label = "AVAILABILITY LOSSES", fontface = "bold",
           color = "#3498DB", size = 4) +
  annotate("rect", xmin = 0.2, xmax = 1.4, ymin = 4.2, ymax = 5.8, fill = "#3498DB", color = "black") +
  annotate("text", x = 0.8, y = 5.4, label = "1", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 0.8, y = 5, label = "Equipment\nFailure", color = "white", size = 3, lineheight = 0.9) +
  annotate("rect", xmin = 1.6, xmax = 3, ymin = 4.2, ymax = 5.8, fill = "#3498DB", color = "black") +
  annotate("text", x = 2.3, y = 5.4, label = "2", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 2.3, y = 5, label = "Setup &\nAdjustment", color = "white", size = 3, lineheight = 0.9) +

  # Performance losses (green)
  annotate("rect", xmin = 3.4, xmax = 6.6, ymin = 4, ymax = 6.5, fill = "#27AE60", alpha = 0.2) +
  annotate("text", x = 5, y = 6.2, label = "PERFORMANCE LOSSES", fontface = "bold",
           color = "#27AE60", size = 4) +
  annotate("rect", xmin = 3.6, xmax = 4.8, ymin = 4.2, ymax = 5.8, fill = "#27AE60", color = "black") +
  annotate("text", x = 4.2, y = 5.4, label = "3", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 4.2, y = 5, label = "Idling &\nMinor Stops", color = "white", size = 3, lineheight = 0.9) +
  annotate("rect", xmin = 5, xmax = 6.4, ymin = 4.2, ymax = 5.8, fill = "#27AE60", color = "black") +
  annotate("text", x = 5.7, y = 5.4, label = "4", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 5.7, y = 5, label = "Reduced\nSpeed", color = "white", size = 3, lineheight = 0.9) +

  # Quality losses (orange)
  annotate("rect", xmin = 6.8, xmax = 10, ymin = 4, ymax = 6.5, fill = "#E74C3C", alpha = 0.2) +
  annotate("text", x = 8.4, y = 6.2, label = "QUALITY LOSSES", fontface = "bold",
           color = "#E74C3C", size = 4) +
  annotate("rect", xmin = 7, xmax = 8.2, ymin = 4.2, ymax = 5.8, fill = "#E74C3C", color = "black") +
  annotate("text", x = 7.6, y = 5.4, label = "5", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 7.6, y = 5, label = "Process\nDefects", color = "white", size = 3, lineheight = 0.9) +
  annotate("rect", xmin = 8.4, xmax = 9.8, ymin = 4.2, ymax = 5.8, fill = "#E74C3C", color = "black") +
  annotate("text", x = 9.1, y = 5.4, label = "6", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 9.1, y = 5, label = "Startup\nRejects", color = "white", size = 3, lineheight = 0.9) +

  theme_void() +
  labs(title = "The Six Big Losses: Targets for TPM Improvement") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(3.5, 7)
```

```{r six-losses-detail, echo=FALSE}
losses_detail <- tibble(
  `#` = 1:6,
  `Loss Category` = c("**Equipment Failure**", "**Setup & Adjustment**", "**Idling & Minor Stops**",
                      "**Reduced Speed**", "**Process Defects**", "**Startup Rejects**"),
  `OEE Component` = c("Availability", "Availability", "Performance",
                      "Performance", "Quality", "Quality"),
  `Description` = c("Unplanned equipment breakdown",
                    "Time for changeover, tool changes, adjustments",
                    "Brief stoppages (jams, blockages, cleaning)",
                    "Running slower than design speed",
                    "Defects produced during normal operation",
                    "Defects during warmup, startup, changeover"),
  `Examples` = c("Motor failure, sensor malfunction, mechanical breakdown",
                 "Die change, product changeover, calibration",
                 "Sensor trips, material jams, overloads (<5 min)",
                 "Worn tooling, operator caution, material variability",
                 "Scrap, rework, out-of-spec product",
                 "First-off rejects, warming up, stabilization")
)

losses_detail %>%
  kable(format = "html", caption = "The Six Big Losses Explained") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered", "responsive"),
                full_width = TRUE, position = "center", font_size = 11) %>%
  row_spec(0, bold = TRUE, background = "#E67E22", color = "white") %>%
  row_spec(1:2, background = "#D6EAF8") %>%
  row_spec(3:4, background = "#D5F5E3") %>%
  row_spec(5:6, background = "#FADBD8") %>%
  column_spec(1, bold = TRUE, width = "3em")
```

### Typical Loss Distribution

```{r loss-distribution, echo=FALSE, fig.align="center", fig.cap="Typical Distribution of the Six Big Losses", fig.width=10, fig.height=5}
losses_data <- data.frame(
  loss = c("Equipment Failure", "Setup/Adjustment", "Minor Stops",
           "Reduced Speed", "Process Defects", "Startup Rejects"),
  percentage = c(10, 12, 8, 5, 3, 2),
  category = c("Availability", "Availability", "Performance",
               "Performance", "Quality", "Quality")
)

ggplot(losses_data, aes(x = reorder(loss, -percentage), y = percentage, fill = category)) +
  geom_bar(stat = "identity", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(percentage, "%")), vjust = -0.5, fontface = "bold") +
  scale_fill_manual(values = c("Availability" = "#3498DB", "Performance" = "#27AE60", "Quality" = "#E74C3C")) +
  labs(title = "Typical Loss Distribution (40% Total Losses)",
       subtitle = "Manufacturing example - varies by industry and equipment",
       x = "", y = "Time Loss (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "bottom",
    axis.text.x = element_text(angle = 30, hjust = 1)
  )
```

------------------------------------------------------------------------

## Autonomous Maintenance

**Autonomous Maintenance (AM)** is the first and most visible pillar of TPM. It transfers basic maintenance tasks from maintenance specialists to operators.

### The Seven Steps of Autonomous Maintenance

```{r am-seven-steps, echo=FALSE, fig.align="center", fig.cap="Seven Steps of Autonomous Maintenance", fig.width=10, fig.height=7}
steps <- data.frame(
  step = 1:7,
  name = c("Initial Cleaning", "Eliminate Sources", "Standards", "General Inspection",
           "Autonomous Inspection", "Organization", "Full AM"),
  description = c("Clean to inspect", "Prevent contamination", "Maintain conditions",
                  "Train & inspect", "Self-directed", "Standardize workplace", "Continuous improvement"),
  y = c(7, 6, 5, 4, 3, 2, 1)
)

ggplot(steps, aes(x = 1, y = y)) +
  geom_tile(width = 2, height = 0.8, fill = "#E74C3C", color = "white", size = 2) +
  geom_text(aes(x = 0.2, label = step), fontface = "bold", color = "white", size = 5) +
  geom_text(aes(x = 1.2, label = name), fontface = "bold", color = "white", size = 3.5) +
  geom_text(aes(x = 2.8, label = description), hjust = 0, color = "#2C3E50", size = 3.5) +
  # Arrows
  annotate("segment", x = 1, xend = 1, y = 0.5, yend = 7.5,
           arrow = arrow(length = unit(0.3, "cm"), ends = "first"), color = "#27AE60", size = 2) +
  annotate("text", x = -0.3, y = 4, label = "Progress", angle = 90, fontface = "bold",
           color = "#27AE60", size = 4) +
  theme_void() +
  labs(title = "Seven Steps of Autonomous Maintenance") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  xlim(-0.8, 5)
```

```{r am-steps-detail, echo=FALSE}
am_steps <- tibble(
  `Step` = 1:7,
  `Name` = c("**Initial Cleaning**", "**Eliminate Contamination Sources**",
             "**Cleaning & Lubrication Standards**", "**General Inspection**",
             "**Autonomous Inspection**", "**Organization & Tidiness**",
             "**Full Autonomous Maintenance**"),
  `Activities` = c("Deep clean equipment; identify abnormalities",
                   "Find and fix sources of dirt, leaks, contamination",
                   "Create standards for cleaning, lubricating, inspection",
                   "Train operators on equipment function; expand skills",
                   "Operators perform scheduled inspections independently",
                   "Standardize workplace; visual management",
                   "Continuous improvement; operators propose improvements"),
  `Outcome` = c("Equipment baseline; 100+ abnormalities found typical",
                "Reduced cleaning time; contamination controlled",
                "Consistent equipment condition; clear expectations",
                "Skilled operators; detect abnormalities early",
                "Reliable self-directed maintenance program",
                "Efficient, safe, visual workplace",
                "Empowered operators; sustained improvement")
)

am_steps %>%
  kable(format = "html", caption = "Autonomous Maintenance Steps in Detail") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "4em")
```

### The AM Tag System

During autonomous maintenance activities, operators identify abnormalities using **tags**:

```{r tag-system, echo=FALSE, fig.align="center", fig.cap="AM Tag System", fig.width=9, fig.height=4}
ggplot() +
  # Red tag
  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 0, ymax = 3, fill = "#E74C3C", color = "black") +
  annotate("text", x = 1.5, y = 2.5, label = "RED TAG", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 1.5, y = 1.5, label = "Maintenance\nRequired\n\nOperator cannot fix",
           color = "white", size = 3, lineheight = 0.9) +
  # White/Blue tag
  annotate("rect", xmin = 3.5, xmax = 5.5, ymin = 0, ymax = 3, fill = "#3498DB", color = "black") +
  annotate("text", x = 4.5, y = 2.5, label = "BLUE TAG", fontface = "bold", color = "white", size = 5) +
  annotate("text", x = 4.5, y = 1.5, label = "Operator\nAction\n\nOperator can fix",
           color = "white", size = 3, lineheight = 0.9) +
  # Yellow tag
  annotate("rect", xmin = 6.5, xmax = 8.5, ymin = 0, ymax = 3, fill = "#F1C40F", color = "black") +
  annotate("text", x = 7.5, y = 2.5, label = "YELLOW TAG", fontface = "bold", color = "black", size = 5) +
  annotate("text", x = 7.5, y = 1.5, label = "Safety\nHazard\n\nImmediate attention",
           color = "black", size = 3, lineheight = 0.9) +
  theme_void() +
  labs(title = "AM Tag System: Identifying and Tracking Abnormalities") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
```

### Example: AM Cleaning and Inspection Checklist

```{r am-checklist, echo=FALSE}
checklist <- tibble(
  `#` = 1:8,
  `Check Item` = c("General cleanliness", "Oil/lubricant levels", "Loose bolts/fasteners",
                   "Unusual sounds", "Vibration", "Temperature", "Leaks (oil, air, coolant)",
                   "Safety guards in place"),
  `Method` = c("Visual", "Visual/gauge", "Touch/wrench", "Listen", "Touch", "Touch/thermometer",
               "Visual", "Visual"),
  `Standard` = c("No dust, debris, contamination", "Between min-max marks", "Hand tight + 1/4 turn",
                 "Normal operating sound", "Minimal, no unusual patterns", "< 60°C (or per spec)",
                 "No visible leaks", "All guards secure"),
  `Frequency` = c("Daily", "Daily", "Weekly", "Each startup", "Each startup",
                  "Hourly", "Daily", "Each shift")
)

checklist %>%
  kable(format = "html", caption = "Sample AM Inspection Checklist") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#E74C3C", color = "white") %>%
  column_spec(1, bold = TRUE, width = "3em")
```

------------------------------------------------------------------------

## Planned Maintenance

**Planned Maintenance** is the second pillar, focusing on scheduled maintenance activities performed by maintenance specialists.

### Types of Maintenance

```{r maintenance-types, echo=FALSE, fig.align="center", fig.cap="Types of Maintenance Activities", fig.width=10, fig.height=6}
ggplot() +
  # Reactive
  annotate("rect", xmin = 0, xmax = 2.3, ymin = 0, ymax = 3, fill = "#E74C3C", alpha = 0.8) +
  annotate("text", x = 1.15, y = 2.5, label = "REACTIVE", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 1.15, y = 1.5, label = "Breakdown\nMaintenance\n\nFix when broken",
           color = "white", size = 3, lineheight = 0.9) +
  # Preventive
  annotate("rect", xmin = 2.6, xmax = 4.9, ymin = 0, ymax = 3, fill = "#F39C12", alpha = 0.8) +
  annotate("text", x = 3.75, y = 2.5, label = "PREVENTIVE", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 3.75, y = 1.5, label = "Time-Based\nMaintenance\n\nScheduled intervals",
           color = "white", size = 3, lineheight = 0.9) +
  # Predictive
  annotate("rect", xmin = 5.2, xmax = 7.5, ymin = 0, ymax = 3, fill = "#3498DB", alpha = 0.8) +
  annotate("text", x = 6.35, y = 2.5, label = "PREDICTIVE", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 6.35, y = 1.5, label = "Condition-Based\nMaintenance\n\nMonitor & predict",
           color = "white", size = 3, lineheight = 0.9) +
  # Proactive
  annotate("rect", xmin = 7.8, xmax = 10.1, ymin = 0, ymax = 3, fill = "#27AE60", alpha = 0.8) +
  annotate("text", x = 8.95, y = 2.5, label = "PROACTIVE", fontface = "bold", color = "white", size = 4) +
  annotate("text", x = 8.95, y = 1.5, label = "Root Cause\nElimination\n\nPrevent recurrence",
           color = "white", size = 3, lineheight = 0.9) +
  # Arrow
  annotate("segment", x = 0.5, xend = 9.5, y = -0.5, yend = -0.5,
           arrow = arrow(length = unit(0.3, "cm")), color = "#2C3E50", size = 1.5) +
  annotate("text", x = 5, y = -0.8, label = "Increasing Maturity →", fontface = "bold") +
  theme_void() +
  labs(title = "Evolution of Maintenance Strategy") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(-1.2, 3.5)
```

```{r maintenance-comparison, echo=FALSE}
maint_compare <- tibble(
  `Type` = c("**Breakdown**", "**Preventive**", "**Predictive**", "**Proactive**"),
  `Approach` = c("Run to failure", "Time/cycle-based replacement",
                 "Condition monitoring", "Root cause elimination"),
  `Advantages` = c("No upfront cost", "Planned downtime, parts availability",
                   "Optimal component life, targeted actions", "Prevents future failures"),
  `Disadvantages` = c("Unplanned downtime, secondary damage", "May replace good parts",
                      "Monitoring investment required", "Requires analysis capability"),
  `Best For` = c("Non-critical, cheap to replace", "Wear items with known life",
                 "Critical equipment, expensive failures", "Recurring problems")
)

maint_compare %>%
  kable(format = "html", caption = "Maintenance Strategy Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#9B59B6", color = "white") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

### Predictive Maintenance Technologies

```{r pdm-technologies, echo=FALSE}
pdm_tech <- tibble(
  `Technology` = c("**Vibration Analysis**", "**Thermography**", "**Oil Analysis**",
                   "**Ultrasound**", "**Motor Current Analysis**"),
  `What It Detects` = c("Imbalance, misalignment, bearing wear, looseness",
                        "Hot spots, electrical issues, friction, insulation problems",
                        "Contamination, wear particles, lubricant degradation",
                        "Leaks, bearing defects, electrical discharge",
                        "Motor winding issues, rotor bar problems, power quality"),
  `Equipment Applications` = c("Rotating equipment (motors, pumps, fans, gearboxes)",
                               "Electrical panels, motors, bearings, refractory",
                               "Gearboxes, hydraulics, engines, compressors",
                               "Steam traps, valves, bearings, electrical equipment",
                               "Electric motors, drives, generators"),
  `Typical Warning Time` = c("Weeks to months", "Hours to days", "Weeks to months",
                             "Days to weeks", "Days to weeks")
)

pdm_tech %>%
  kable(format = "html", caption = "Predictive Maintenance Technologies") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#3498DB", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

### The P-F Curve

The **P-F Curve** illustrates the concept of detecting potential failure (P) before functional failure (F).

```{r pf-curve, echo=FALSE, fig.align="center", fig.cap="The P-F Curve: Detecting Failure Early", fig.width=10, fig.height=6}
# Create P-F curve data
x <- seq(0, 10, 0.1)
y <- 100 - 10*exp(0.3*x - 1.5)
y <- pmax(y, 0)

pf_data <- data.frame(x = x, y = y)

ggplot(pf_data, aes(x = x, y = y)) +
  geom_line(size = 2, color = "#E74C3C") +
  # P point
  geom_point(aes(x = 4, y = 75), size = 5, color = "#F39C12") +
  annotate("text", x = 4, y = 82, label = "P\n(Potential Failure)", fontface = "bold",
           color = "#F39C12", lineheight = 0.9) +
  # F point
  geom_point(aes(x = 9, y = 10), size = 5, color = "#E74C3C") +
  annotate("text", x = 9, y = 18, label = "F\n(Functional Failure)", fontface = "bold",
           color = "#E74C3C", lineheight = 0.9) +
  # P-F interval
  annotate("segment", x = 4, xend = 9, y = 50, yend = 50,
           arrow = arrow(length = unit(0.15, "cm"), ends = "both"), color = "#27AE60", size = 1.5) +
  annotate("text", x = 6.5, y = 55, label = "P-F Interval\n(Time to plan repair)",
           fontface = "bold", color = "#27AE60", lineheight = 0.9) +
  # Detection methods
  annotate("rect", xmin = 1, xmax = 3, ymin = 85, ymax = 95, fill = "#3498DB", alpha = 0.7) +
  annotate("text", x = 2, y = 90, label = "Vibration\nAnalysis", color = "white", size = 3, lineheight = 0.9) +
  annotate("rect", xmin = 3.5, xmax = 5.5, ymin = 65, ymax = 75, fill = "#9B59B6", alpha = 0.7) +
  annotate("text", x = 4.5, y = 70, label = "Thermography", color = "white", size = 3) +
  annotate("rect", xmin = 6, xmax = 8, ymin = 35, ymax = 45, fill = "#E67E22", alpha = 0.7) +
  annotate("text", x = 7, y = 40, label = "Audible\nNoise", color = "white", size = 3, lineheight = 0.9) +
  labs(title = "The P-F Curve: Detecting Potential Failure",
       subtitle = "Earlier detection = More time to plan = Lower cost repair",
       x = "Time", y = "Equipment Condition") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_blank()
  )
```

<details>
<summary>Question: Why is predictive maintenance better than preventive maintenance?</summary>

**Preventive Maintenance (Time-Based):**
- Replaces parts at fixed intervals regardless of condition
- May replace parts still in good condition (waste)
- May miss failures that occur before scheduled replacement
- Based on average life, not individual component condition

**Predictive Maintenance (Condition-Based):**
- Monitors actual equipment condition
- Replaces parts when condition indicates need
- Maximizes component life
- Provides warning time to plan repairs

**Example:**
- Preventive: Replace bearing every 6 months (may last 9 months or fail at 4 months)
- Predictive: Monitor vibration; replace when trending indicates 2-3 weeks to failure
- Result: Optimal component life, planned downtime, no unexpected failures

**Cost Comparison:**
- Reactive repair: $10,000 (including secondary damage, lost production)
- Preventive replacement: $3,000 (may waste $1,000 in parts life)
- Predictive replacement: $2,500 (optimal timing, minimal waste)

</details>

------------------------------------------------------------------------

## Focused Improvement (Kobetsu Kaizen)

**Focused Improvement** uses cross-functional teams to eliminate specific losses identified through OEE analysis.

### The Kaizen Process

```{r kaizen-process, echo=FALSE, fig.align="center", fig.cap="Focused Improvement Process", fig.width=10, fig.height=5}
ggplot() +
  # Steps
  annotate("rect", xmin = 0, xmax = 1.8, ymin = 1, ymax = 2.5, fill = "#3498DB", color = "black") +
  annotate("text", x = 0.9, y = 2.1, label = "1. SELECT", fontface = "bold", color = "white", size = 3.5) +
  annotate("text", x = 0.9, y = 1.5, label = "Identify\nbiggest loss", color = "white", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 2, xmax = 3.8, ymin = 1, ymax = 2.5, fill = "#27AE60", color = "black") +
  annotate("text", x = 2.9, y = 2.1, label = "2. ANALYZE", fontface = "bold", color = "white", size = 3.5) +
  annotate("text", x = 2.9, y = 1.5, label = "Root cause\nanalysis", color = "white", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 4, xmax = 5.8, ymin = 1, ymax = 2.5, fill = "#F39C12", color = "black") +
  annotate("text", x = 4.9, y = 2.1, label = "3. DEVELOP", fontface = "bold", color = "white", size = 3.5) +
  annotate("text", x = 4.9, y = 1.5, label = "Counter-\nmeasures", color = "white", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 6, xmax = 7.8, ymin = 1, ymax = 2.5, fill = "#E74C3C", color = "black") +
  annotate("text", x = 6.9, y = 2.1, label = "4. IMPLEMENT", fontface = "bold", color = "white", size = 3.5) +
  annotate("text", x = 6.9, y = 1.5, label = "Execute\nplan", color = "white", size = 2.5, lineheight = 0.9) +

  annotate("rect", xmin = 8, xmax = 9.8, ymin = 1, ymax = 2.5, fill = "#9B59B6", color = "black") +
  annotate("text", x = 8.9, y = 2.1, label = "5. SUSTAIN", fontface = "bold", color = "white", size = 3.5) +
  annotate("text", x = 8.9, y = 1.5, label = "Standardize\n& share", color = "white", size = 2.5, lineheight = 0.9) +

  # Arrows
  annotate("segment", x = 1.8, xend = 2, y = 1.75, yend = 1.75,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 3.8, xend = 4, y = 1.75, yend = 1.75,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 5.8, xend = 6, y = 1.75, yend = 1.75,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +
  annotate("segment", x = 7.8, xend = 8, y = 1.75, yend = 1.75,
           arrow = arrow(length = unit(0.15, "cm")), size = 1) +

  theme_void() +
  labs(title = "Focused Improvement (Kobetsu Kaizen) Process") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
  ylim(0.5, 3)
```

### Loss Elimination Tools

```{r loss-tools, echo=FALSE}
tools <- tibble(
  `Tool` = c("**Pareto Analysis**", "**Why-Why Analysis**", "**PM Analysis**",
             "**SMED**", "**Poka-Yoke**"),
  `Purpose` = c("Identify biggest losses to target",
                "Find root cause of failures",
                "Analyze chronic losses systematically",
                "Reduce setup/changeover time",
                "Error-proof the process"),
  `Application` = c("Prioritize improvement efforts",
                    "Breakdown analysis, defect investigation",
                    "Complex, recurring problems",
                    "Availability improvement (Loss #2)",
                    "Quality improvement (Losses #5, #6)")
)

tools %>%
  kable(format = "html", caption = "Tools for Loss Elimination") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "12em")
```

------------------------------------------------------------------------

## TPM Implementation

### The 12 Steps of TPM Implementation

```{r implementation-steps-TPM, echo=FALSE}
impl_steps <- tibble(
  `Phase` = c(rep("**Preparation**", 5), rep("**Implementation**", 5), rep("**Stabilization**", 2)),
  `Step` = 1:12,
  `Activity` = c("Announce TPM introduction by top management",
                 "Education and campaign to introduce TPM",
                 "Create TPM promotion organization",
                 "Establish basic TPM policies and goals",
                 "Formulate master plan for TPM development",
                 "Hold TPM kick-off",
                 "Improve effectiveness of each piece of equipment",
                 "Develop autonomous maintenance program",
                 "Develop planned maintenance program",
                 "Conduct training to improve skills",
                 "Develop early equipment management program",
                 "Perfect TPM implementation and raise levels"),
  `Duration` = c("1 month", "3-6 months", "1-2 months", "1-2 months", "1-2 months",
                 "1 day", "6-12 months", "12-24 months", "12-24 months", "Ongoing",
                 "12-24 months", "Ongoing")
)

impl_steps %>%
  kable(format = "html", caption = "12 Steps of TPM Implementation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#16A085", color = "white") %>%
  row_spec(1:5, background = "#D6EAF8") %>%
  row_spec(6:10, background = "#D5F5E3") %>%
  row_spec(11:12, background = "#FCE4D6") %>%
  column_spec(1, bold = TRUE, width = "10em")
```

### Success Factors

```{r success-factors, echo=FALSE}
success <- tibble(
  `Factor` = c("**Top Management Commitment**", "**Training and Education**",
               "**Small Group Activities**", "**Visual Management**",
               "**Patience and Persistence**"),
  `Why Critical` = c("Resources, culture change, sustained focus",
                     "Skills to identify problems, perform maintenance",
                     "Operator involvement, team problem-solving",
                     "Make abnormalities obvious, track progress",
                     "TPM takes 3-5 years to fully implement")
)

success %>%
  kable(format = "html", caption = "TPM Success Factors") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#27AE60", color = "white") %>%
  column_spec(1, bold = TRUE, width = "15em")
```

------------------------------------------------------------------------

## Case Study: TPM Implementation

### Background

**Company:** Automotive component manufacturer

**Equipment:** CNC machining center

**Initial OEE:** 52%

### Problem Analysis

```{r case-oee-initial, echo=TRUE}
# Initial State
cat("=== INITIAL OEE BREAKDOWN ===\n\n")

availability_initial <- 78  # %
performance_initial <- 82   # %
quality_initial <- 81       # %

oee_initial <- (availability_initial/100) * (performance_initial/100) * (quality_initial/100) * 100
cat("Availability:", availability_initial, "%\n")
cat("Performance:", performance_initial, "%\n")
cat("Quality:", quality_initial, "%\n")
cat("OEE:", round(oee_initial, 1), "%\n\n")

# Loss breakdown
cat("=== TOP LOSSES IDENTIFIED ===\n")
cat("1. Equipment breakdowns: 8% of time\n")
cat("2. Setup/changeover: 7% of time\n")
cat("3. Minor stops: 12% of time\n")
cat("4. Defects: 4% of production\n")
```

### Improvements Implemented

| Loss | Root Cause | Countermeasure | Result |
|------|------------|----------------|--------|
| Breakdowns | Lack of basic maintenance | Autonomous maintenance program | 8% → 3% |
| Setup time | No standard procedure | SMED implementation | 35 min → 12 min |
| Minor stops | Chip buildup in sensors | Improved chip management | 12% → 4% |
| Defects | Tool wear not detected | In-process gauging | 4% → 1.5% |

### Results After 18 Months

```{r case-oee-final, echo=TRUE}
# After TPM Implementation
cat("=== FINAL OEE BREAKDOWN ===\n\n")

availability_final <- 91    # %
performance_final <- 94     # %
quality_final <- 98.5       # %

oee_final <- (availability_final/100) * (performance_final/100) * (quality_final/100) * 100
cat("Availability:", availability_final, "% (was", availability_initial, "%)\n")
cat("Performance:", performance_final, "% (was", performance_initial, "%)\n")
cat("Quality:", quality_final, "% (was", quality_initial, "%)\n")
cat("OEE:", round(oee_final, 1), "% (was", round(oee_initial, 1), "%)\n\n")

improvement <- oee_final - oee_initial
cat("=== IMPROVEMENT ===\n")
cat("OEE Improvement:", round(improvement, 1), "percentage points\n")
cat("Relative Improvement:", round((improvement/oee_initial)*100, 0), "%\n")
```

```{r case-visualization, echo=FALSE, fig.align="center", fig.cap="OEE Improvement: Before and After TPM", fig.width=9, fig.height=5}
case_data <- data.frame(
  component = rep(c("Availability", "Performance", "Quality", "OEE"), 2),
  value = c(78, 82, 81, 52, 91, 94, 98.5, 84),
  period = rep(c("Before TPM", "After TPM"), each = 4)
)

ggplot(case_data, aes(x = component, y = value, fill = period)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.7) +
  geom_text(aes(label = paste0(value, "%")), position = position_dodge(width = 0.7),
            vjust = -0.5, size = 3.5) +
  scale_fill_manual(values = c("Before TPM" = "#E74C3C", "After TPM" = "#27AE60")) +
  geom_hline(yintercept = 85, linetype = "dashed", color = "#F39C12", size = 1) +
  annotate("text", x = 4.5, y = 87, label = "World Class", color = "#F39C12", fontface = "bold") +
  labs(title = "OEE Improvement Through TPM",
       x = "", y = "Percentage (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "bottom"
  ) +
  ylim(0, 105)
```

------------------------------------------------------------------------

## Summary

```{r summary-table-ch10, echo=FALSE}
summary_data <- tibble(
  `Topic` = c("**TPM Definition**", "**Eight Pillars**", "**OEE**",
              "**Six Big Losses**", "**Autonomous Maintenance**", "**Planned Maintenance**"),
  `Key Points` = c("Total involvement, productive focus, maintenance excellence; zero breakdowns/defects/accidents",
                   "AM, PM, Quality, Focused Improvement, Early Equipment, Training, Safety, Office — built on 5S",
                   "OEE = Availability × Performance × Quality; World class > 85%",
                   "Equipment failure, setup, minor stops, speed loss, defects, startup rejects",
                   "Operators maintain own equipment; 7 steps from cleaning to full ownership",
                   "Preventive → Predictive → Proactive; use P-F curve for optimal timing")
)

summary_data %>%
  kable(format = "html", caption = "TPM Key Concepts Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "bordered"),
                full_width = TRUE, position = "center") %>%
  row_spec(0, bold = TRUE, background = "#2C3E50", color = "white") %>%
  column_spec(1, width = "12em")
```

------------------------------------------------------------------------

## Review Questions

### Conceptual Questions

<details>
<summary>Question 1: What does "Total" mean in Total Productive Maintenance?</summary>

**"Total" has three dimensions:**

1. **Total participation:** Everyone participates, from operators to top management
2. **Total equipment effectiveness:** Aim for maximum OEE (zero losses)
3. **Total system:** Covers the entire equipment lifecycle, from design to disposal

**Key insight:** TPM is not just a maintenance program — it's a company-wide philosophy where everyone takes responsibility for equipment care.

</details>

<details>
<summary>Question 2: Why is OEE calculated as a product rather than a sum?</summary>

**OEE uses multiplication because losses are sequential and compound:**

1. **Availability** determines how much time is available
2. **Performance** determines how much of that time is productive
3. **Quality** determines how much of that production is good

**Example:**
- If each factor is 90%: OEE = 0.9 × 0.9 × 0.9 = 72.9% (not 270% or 90%)
- This reflects reality: you can only achieve quality on parts that were produced (performance) during time the machine ran (availability)

**Why this matters:**
- Small improvements in all three factors compound
- 5% improvement in each: 0.85 × 0.85 × 0.85 = 61% → 0.90 × 0.90 × 0.90 = 73%
- Focus on the weakest factor first for biggest impact

</details>

<details>
<summary>Question 3: What is the difference between autonomous maintenance and planned maintenance?</summary>

| Aspect | Autonomous Maintenance | Planned Maintenance |
|--------|------------------------|---------------------|
| **Who** | Operators | Maintenance technicians |
| **What** | Basic care (clean, inspect, lubricate) | Complex repairs, overhauls |
| **When** | Daily, during operation | Scheduled intervals |
| **Skills** | Basic equipment knowledge | Technical expertise |
| **Goal** | Prevent deterioration | Restore/improve equipment |

**They complement each other:**
- AM catches problems early (first line of defense)
- PM provides specialized skills when needed
- Together they achieve zero breakdowns

</details>

### Calculation Questions

<details>
<summary>Question 4: Calculate OEE given the following data.</summary>

**Given:**
- Shift length: 480 minutes
- Breaks: 30 minutes
- Changeover: 45 minutes
- Breakdown: 20 minutes
- Ideal cycle time: 30 seconds (0.5 min)
- Total parts produced: 580
- Rejected parts: 23

**Solution:**

```
Planned Production Time = 480 - 30 = 450 minutes
Run Time = 450 - 45 - 20 = 385 minutes

Availability = 385 / 450 = 85.6%

Theoretical Output = 385 / 0.5 = 770 parts
Performance = 580 / 770 = 75.3%

Quality = (580 - 23) / 580 = 557 / 580 = 96.0%

OEE = 85.6% × 75.3% × 96.0% = 61.9%
```

**Analysis:** Performance is the biggest opportunity for improvement (75.3% vs. targets of 95%). Investigate minor stops and speed losses.

</details>

<details>
<summary>Question 5: A machine has OEE of 65% with Availability 90%, Performance 80%, Quality 90%. Which factor should be prioritized?</summary>

**Analysis:**

Current state:
- Availability: 90% (Gap to world class: 5%)
- Performance: 80% (Gap to world class: 15%)
- Quality: 90% (Gap to world class: 9%)

**Performance should be prioritized because:**

1. **Biggest gap:** 15 percentage points below world class (95%)
2. **Biggest OEE impact:** Improving performance 10% → OEE = 90% × 90% × 90% = 72.9%
3. **Often overlooked:** Speed losses and minor stops are frequently accepted as normal

**Investigation areas for performance:**
- Minor stops (jams, blockages, sensor trips)
- Reduced speed operation
- Idling and waiting
- Operator pace

</details>

<details>
<summary>Question 6: If current OEE is 60% and target is 85%, what improvement is needed in each component assuming equal improvement?</summary>

**Solution:**

Current: 60% = A × P × Q

If we improve each equally, we need:
- Target: 85% = A' × P' × Q'
- If A' = P' = Q' = x, then x³ = 0.85
- x = ∛0.85 = 0.947 = 94.7%

**Each component needs to reach approximately 95%**

**Check:** 0.947 × 0.947 × 0.947 = 0.849 ≈ 85%

**If current factors are A=80%, P=85%, Q=88%:**
- Availability needs: +15 points (80% → 95%)
- Performance needs: +10 points (85% → 95%)
- Quality needs: +7 points (88% → 95%)

**Prioritize by gap size:** Availability first, then Performance, then Quality.

</details>

### Application Questions

<details>
<summary>Question 7: An operator notices a small oil leak on a machine. Under traditional maintenance vs. TPM, what happens?</summary>

**Traditional Maintenance Approach:**
1. Operator continues running machine
2. May or may not report to maintenance
3. If reported, added to backlog
4. Maintenance addresses when convenient (days/weeks)
5. Leak worsens, potential bearing damage
6. Eventually leads to breakdown

**TPM Approach:**
1. Operator notices during routine inspection
2. Tags the abnormality immediately
3. Determines if operator can fix (blue tag) or needs maintenance (red tag)
4. If simple: operator tightens fitting or adds sealant
5. If complex: maintenance prioritizes based on severity
6. Root cause investigated to prevent recurrence
7. Finding shared in team meeting

**Key Differences:**
- **Ownership:** Operator takes responsibility vs. "not my job"
- **Speed:** Immediate action vs. delayed response
- **Prevention:** Fixed before failure vs. reactive repair
- **Cost:** $10 seal vs. $5,000 bearing replacement + downtime

</details>

<details>
<summary>Question 8: List five items an operator should check during daily autonomous maintenance.</summary>

**Five Essential Daily AM Checks:**

1. **Cleanliness:** Remove chips, debris, dust; clean safety windows and sensors
   - *Why:* Contamination causes wear, sensor malfunctions, quality issues

2. **Lubrication:** Check oil levels, grease points, coolant level
   - *Why:* Inadequate lubrication causes friction, heat, accelerated wear

3. **Fasteners:** Check for loose bolts, guards, covers
   - *Why:* Loose fasteners cause vibration, safety hazards, misalignment

4. **Leaks:** Look for oil, coolant, air, hydraulic leaks
   - *Why:* Leaks indicate seal failure, waste resources, create hazards

5. **Abnormal sounds/vibration:** Listen and feel during startup
   - *Why:* Changes indicate developing problems (bearings, alignment)

**Bonus items:**
- Safety guards in place
- Emergency stops functional
- Pressure/temperature gauges in normal range
- No unusual smells (burning, chemical)

</details>

<details>
<summary>Question 9: Explain how SMED relates to OEE improvement.</summary>

**SMED (Single Minute Exchange of Die) directly improves Availability:**

**Loss #2: Setup and Adjustment** is an availability loss captured in OEE.

**How SMED helps:**

1. **Reduces changeover time:**
   - Before SMED: 45-minute changeover
   - After SMED: 10-minute changeover
   - Gain: 35 minutes per changeover

2. **Impact on OEE:**
   - If 2 changeovers per shift: 70 minutes saved
   - On 450-minute shift: Availability improves 15%+

3. **Secondary benefits:**
   - More changeovers become practical
   - Smaller batch sizes possible
   - Flexibility increased
   - Less WIP inventory

**SMED Process:**
1. Separate internal (machine stopped) from external (while running) setup
2. Convert internal to external where possible
3. Streamline remaining internal operations
4. Practice and standardize

**Example:** Die change on press
- External: Stage next die, prepare tools, preheat
- Internal: Remove old die, install new die, adjust
- Target: All possible work done while machine runs

</details>

------------------------------------------------------------------------

## References

- Nakajima, S. (1988). *Introduction to TPM: Total Productive Maintenance*. Productivity Press.
- Nakajima, S. (1989). *TPM Development Program: Implementing Total Productive Maintenance*. Productivity Press.
- Shirose, K. (1992). *TPM for Operators*. Productivity Press.
- Willmott, P., & McCarthy, D. (2001). *TPM: A Route to World-Class Performance*. Butterworth-Heinemann.
- JIPM (Japan Institute of Plant Maintenance). *TPM Awards Criteria*.
- Hansen, R.C. (2001). *Overall Equipment Effectiveness*. Industrial Press.
- Borris, S. (2006). *Total Productive Maintenance*. McGraw-Hill.

------------------------------------------------------------------------

<!--chapter:end:10-TPM.Rmd-->

# Troubleshooting and Root Cause Analysis

```{r setup-ch11, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

After completing this chapter, you will be able to:

1. Apply systematic troubleshooting methodologies to diagnose equipment and process failures
2. Distinguish between symptoms, immediate causes, and root causes
3. Use the 5 Whys technique to drill down to fundamental causes
4. Construct and analyze Ishikawa (fishbone) diagrams
5. Apply Fault Tree Analysis (FTA) to complex failure scenarios
6. Use Pareto analysis to prioritize problem-solving efforts
7. Implement the 8D problem-solving methodology
8. Document findings and implement effective corrective actions
9. Prevent problem recurrence through systemic improvements

---

## Introduction to Troubleshooting

**Troubleshooting** is the systematic process of identifying, diagnosing, and resolving problems in equipment, processes, or systems. For electromechanical technicians, effective troubleshooting is perhaps the most valuable skill you can develop.

### The Cost of Downtime

Equipment failures and process problems have significant financial impacts:

```{r downtime-costs, echo=FALSE, fig.width=10, fig.height=6}
industry_data <- data.frame(
  Industry = c("Automotive", "Food Processing", "Aerospace/Defense",
               "Pharmaceutical", "Oil & Gas"),
  Cost_Per_Hour = c(22000, 15000, 35000, 25000, 50000),
  Avg_Downtime_Hours = c(4, 6, 8, 5, 12)
)

industry_data$Total_Cost <- industry_data$Cost_Per_Hour * industry_data$Avg_Downtime_Hours

ggplot(industry_data, aes(x = reorder(Industry, Cost_Per_Hour), y = Cost_Per_Hour)) +
  geom_bar(stat = "identity", fill = "steelblue", width = 0.7) +
  geom_text(aes(label = paste0("$", format(Cost_Per_Hour, big.mark = ","))),
            hjust = -0.1, size = 4) +
  coord_flip() +
  scale_y_continuous(labels = scales::dollar_format(), limits = c(0, 60000)) +
  labs(title = "Average Cost of Unplanned Downtime by Industry",
       subtitle = "Per hour of production stoppage",
       x = "",
       y = "Cost per Hour (USD)") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.text = element_text(size = 11)
  )
```

### Reactive vs. Proactive Problem Solving

```{r reactive-proactive, echo=FALSE}
approach_comparison <- data.frame(
  Aspect = c("Timing", "Focus", "Stress Level", "Cost", "Learning", "Documentation"),
  Reactive = c("After failure occurs", "Quick fix to restore operation",
               "High - production pressure", "High - emergency repairs",
               "Limited - rush to fix", "Often skipped"),
  Proactive = c("Before or early in failure", "Root cause elimination",
                "Lower - planned approach", "Lower - scheduled work",
                "High - thorough analysis", "Systematic and complete")
)

kable(approach_comparison, col.names = c("Aspect", "Reactive Approach", "Proactive Approach"),
      caption = "Comparison of Problem-Solving Approaches") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%") %>%
  column_spec(2, background = "#ffcccc", width = "42%") %>%
  column_spec(3, background = "#ccffcc", width = "43%")
```

<details><summary>**Think About It**: Why do organizations often default to reactive troubleshooting?</summary>

Common reasons include:
- **Time pressure**: Production demands make it tempting to apply quick fixes
- **Lack of training**: Technicians may not know RCA methodologies
- **Reward systems**: Organizations may reward "firefighters" who quickly restore production
- **Missing data**: Without good records, patterns are hard to identify
- **Culture**: "We've always done it this way" mentality

The irony is that reactive troubleshooting actually costs more time in the long run due to recurring problems.
</details>

---

## Systematic Troubleshooting Methodology

Effective troubleshooting follows a structured approach rather than random trial-and-error.

### The DMAIC Troubleshooting Framework

```{r troubleshooting-flow, echo=FALSE, fig.width=12, fig.height=8}
# Create troubleshooting process flow
steps <- data.frame(
  step = 1:6,
  name = c("DEFINE", "MEASURE", "ANALYZE", "IMPLEMENT", "CONTROL", "DOCUMENT"),
  description = c(
    "Clearly state the problem",
    "Gather data and observations",
    "Identify root cause",
    "Apply corrective action",
    "Verify solution works",
    "Record findings"
  ),
  x = c(1, 2, 3, 4, 5, 6),
  y = rep(1, 6)
)

ggplot(steps, aes(x = x, y = y)) +
  geom_segment(aes(x = x, xend = x + 0.8, y = y, yend = y),
               arrow = arrow(length = unit(0.3, "cm")),
               color = "gray50", size = 1.5,
               data = steps[1:5,]) +
  geom_point(size = 25, color = c("#e74c3c", "#3498db", "#2ecc71",
                                   "#f39c12", "#9b59b6", "#1abc9c")) +
  geom_text(aes(label = step), color = "white", size = 8, fontface = "bold") +
  geom_text(aes(label = name, y = y + 0.25), size = 4, fontface = "bold") +
  geom_text(aes(label = description, y = y - 0.25), size = 3) +
  scale_x_continuous(limits = c(0.5, 6.8)) +
  scale_y_continuous(limits = c(0.5, 1.5)) +
  labs(title = "Systematic Troubleshooting Process") +
  theme_void() +
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))
```

### Step 1: Define the Problem

A well-defined problem is half-solved. Use the **5W2H** method:

```{r 5w2h-table, echo=FALSE}
w2h <- data.frame(
  Question = c("WHAT", "WHERE", "WHEN", "WHO", "WHY", "HOW", "HOW MUCH"),
  Description = c(
    "What is the problem? What is happening vs. what should happen?",
    "Where does the problem occur? Location, machine, station?",
    "When did it start? When does it occur? Continuous or intermittent?",
    "Who discovered it? Who is affected? Who was operating?",
    "Why is this a problem? What is the impact?",
    "How was the problem detected? How is it manifesting?",
    "How often? How many units affected? What is the magnitude?"
  ),
  Example = c(
    "Motor overheating on conveyor line 3",
    "Discharge end of conveyor, motor housing",
    "Started Monday, occurs after 2 hours of operation",
    "Operator noticed, maintenance called, affects packaging dept",
    "Risk of motor failure, line stoppage, safety hazard",
    "Detected by high-temp alarm at 85°C",
    "Occurs every day, 100% of shifts, 15°C above normal"
  )
)

kable(w2h, col.names = c("Question", "What to Ask", "Example Response"),
      caption = "5W2H Problem Definition Framework") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, color = "white", background = "#2c3e50", width = "12%") %>%
  column_spec(2, width = "40%") %>%
  column_spec(3, width = "48%", background = "#f8f9fa")
```

### Problem Statement Template

> **Good Problem Statement Format:**
> "[WHAT] is occurring at [WHERE] since [WHEN], affecting [WHO/WHAT], with a magnitude of [HOW MUCH]."

**Example:**
> "Motor overheating (85°C vs. normal 70°C) is occurring at Conveyor Line 3 discharge motor since Monday morning, affecting packaging department production, with the condition occurring every shift after approximately 2 hours of operation."

<details><summary>**Practice**: Write a problem statement for this scenario</summary>

**Scenario:** An injection molding machine is producing parts with short shots (incomplete fill). The problem was noticed by the quality inspector during the night shift. About 15% of parts are affected. The issue seems worse when running the larger 500g parts compared to the smaller 200g parts.

**Sample Problem Statement:**
"Short shots (incomplete cavity fill) are occurring on Injection Molding Machine #4 since night shift on Tuesday, affecting 15% of parts produced, with the defect rate increasing significantly when running 500g parts compared to 200g parts."
</details>

### Step 2: Gather Data and Observations

Before making any changes, collect information systematically:

```{r data-gathering, echo=FALSE}
data_sources <- data.frame(
  Source = c("Visual Inspection", "Operator Interview", "Machine Parameters",
             "Historical Records", "Product/Output", "Environmental"),
  What_to_Check = c(
    "Physical condition, wear, contamination, alignment, damage",
    "What changed? When did it start? Any unusual events?",
    "Temperatures, pressures, speeds, currents, positions",
    "Maintenance logs, previous repairs, similar issues",
    "Defect patterns, measurements, reject rates",
    "Temperature, humidity, vibration, power quality"
  ),
  Tools = c(
    "Flashlight, mirror, magnifier, camera",
    "Open-ended questions, active listening",
    "HMI screens, gauges, multimeter, thermal camera",
    "CMMS, logbooks, work orders",
    "Calipers, gauges, CMM, visual inspection",
    "Thermometer, hygrometer, vibration analyzer"
  )
)

kable(data_sources, col.names = c("Data Source", "What to Check", "Tools/Methods"),
      caption = "Systematic Data Gathering Checklist") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### The "Change Analysis" Approach

Many problems are caused by changes. Ask:

- What changed recently?
- New materials, suppliers, or batches?
- New operators or different shifts?
- Maintenance performed?
- Environmental changes (weather, season)?
- Software updates or parameter changes?
- New products or recipes running?

```{r change-timeline, echo=FALSE, fig.width=11, fig.height=5}
# Create a change timeline visualization
timeline_data <- data.frame(
  event = c("New lubricant\nsupplier", "Operator\ntraining", "PM\ncompleted",
            "Software\nupdate", "Problem\nstarted", "New shift\nschedule"),
  date = as.Date(c("2024-01-15", "2024-01-22", "2024-02-01",
                   "2024-02-05", "2024-02-07", "2024-02-10")),
  y = c(1, -1, 1, -1, 1, -1),
  type = c("Change", "Change", "Change", "Change", "Problem", "Change")
)

ggplot(timeline_data, aes(x = date, y = 0)) +
  geom_hline(yintercept = 0, color = "gray50", size = 1) +
  geom_segment(aes(xend = date, yend = y), color = "gray70") +
  geom_point(aes(y = y, color = type), size = 8) +
  geom_text(aes(y = y, label = event), vjust = ifelse(timeline_data$y > 0, -1, 2),
            size = 3) +
  geom_text(aes(label = format(date, "%b %d")), vjust = 2, size = 2.5) +
  scale_color_manual(values = c("Change" = "steelblue", "Problem" = "red")) +
  scale_y_continuous(limits = c(-2, 2)) +
  labs(title = "Change Timeline Analysis",
       subtitle = "Map changes against problem occurrence to identify correlations",
       x = "", y = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid = element_blank(),
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 14)
  )
```

---

## Understanding Root Cause vs. Symptoms

A critical concept in troubleshooting is distinguishing between different levels of causation.

### The Causation Hierarchy

```{r causation-levels, echo=FALSE, fig.width=10, fig.height=7}
# Create causation hierarchy pyramid
levels <- data.frame(
  level = c("Symptom", "Immediate Cause", "Contributing Cause", "Root Cause"),
  y = c(4, 3, 2, 1),
  width = c(3, 4, 5, 6),
  description = c(
    "Observable effect of the problem",
    "Direct cause of the symptom",
    "Factors that enabled the cause",
    "Fundamental reason - fix this to prevent recurrence"
  ),
  example = c(
    "Motor is overheating",
    "Bearing is worn",
    "Lubrication was inadequate",
    "No PM schedule for bearing lubrication"
  ),
  color = c("#e74c3c", "#f39c12", "#3498db", "#27ae60")
)

ggplot(levels, aes(x = 0, y = y)) +
  geom_tile(aes(width = width, height = 0.8, fill = color), color = "white", size = 2) +
  geom_text(aes(label = level), fontface = "bold", size = 5, color = "white") +
  geom_text(aes(label = description, y = y - 0.25), size = 3, color = "white") +
  scale_fill_identity() +
  annotate("text", x = 4, y = 4, label = "Example: Motor is overheating",
           hjust = 0, size = 3.5, fontface = "italic") +
  annotate("text", x = 4, y = 3, label = "Example: Bearing is worn",
           hjust = 0, size = 3.5, fontface = "italic") +
  annotate("text", x = 4, y = 2, label = "Example: Lubrication inadequate",
           hjust = 0, size = 3.5, fontface = "italic") +
  annotate("text", x = 4, y = 1, label = "Example: No PM schedule exists",
           hjust = 0, size = 3.5, fontface = "italic") +
  coord_cartesian(xlim = c(-4, 7)) +
  labs(title = "Causation Hierarchy",
       subtitle = "Dig deeper to find the root cause - don't stop at symptoms") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Why Finding Root Cause Matters

```{r fix-comparison, echo=FALSE}
fix_levels <- data.frame(
  Level = c("Symptom", "Immediate Cause", "Root Cause"),
  Fix = c("Add cooling fan to motor", "Replace worn bearing",
          "Implement PM schedule with lubrication tasks"),
  Result = c("Motor runs cooler temporarily", "Motor works for a while",
             "Problem eliminated permanently"),
  Recurrence = c("Problem returns in days", "Problem returns in months",
                 "Problem does not recur"),
  Cost_Short = c("$50", "$200", "$500"),
  Cost_Long = c("$5000+ (repeated failures)", "$2400 (annual replacements)",
                "$500 (one-time implementation)")
)

kable(fix_levels, col.names = c("Fix Level", "Action Taken", "Immediate Result",
                                 "Recurrence", "Short-term Cost", "Long-term Cost"),
      caption = "Comparison of Fixes at Different Causation Levels") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  row_spec(3, background = "#d4edda", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%")
```

---

## The 5 Whys Technique

The **5 Whys** is a simple but powerful technique developed by Sakichi Toyoda and used within Toyota's manufacturing methods.

### How It Works

1. State the problem
2. Ask "Why?" to identify the cause
3. Ask "Why?" again about that cause
4. Continue asking "Why?" until you reach the root cause
5. Typically requires 5 iterations (sometimes more, sometimes less)

### 5 Whys Example: Production Line Stoppage

```{r five-whys-visual, echo=FALSE, fig.width=11, fig.height=8}
whys <- data.frame(
  level = 1:6,
  question = c("Problem:", "Why #1:", "Why #2:", "Why #3:", "Why #4:", "Why #5:"),
  answer = c(
    "Production line stopped",
    "The robot arm stopped moving",
    "The servo motor overloaded and faulted",
    "The gearbox was binding due to wear",
    "The gearbox lubrication had degraded",
    "The lubrication was never changed\n(No PM schedule existed)"
  ),
  y = 6:1
)

ggplot(whys, aes(x = 1, y = y)) +
  geom_tile(aes(fill = level), width = 5, height = 0.8, color = "white", size = 1) +
  geom_text(aes(x = -0.8, label = question), hjust = 1, fontface = "bold", size = 4) +
  geom_text(aes(label = answer), hjust = 0.5, size = 3.5,
            color = ifelse(whys$level == 6, "white", "black")) +
  geom_segment(aes(x = 0.5, xend = 0.5, y = y - 0.4, yend = y - 0.6),
               arrow = arrow(length = unit(0.2, "cm")),
               data = whys[1:5,], color = "gray40") +
  scale_fill_gradient(low = "#3498db", high = "#c0392b", guide = "none") +
  coord_cartesian(xlim = c(-2.5, 3.5)) +
  labs(title = "5 Whys Analysis: Production Line Stoppage",
       subtitle = "Each 'Why?' digs deeper toward the root cause") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, size = 11))
```

### 5 Whys Template

```{r five-whys-template, echo=FALSE}
template <- data.frame(
  Step = c("Problem Statement", "Why #1", "Why #2", "Why #3", "Why #4", "Why #5", "Root Cause"),
  Description = c(
    "Clear, specific description of what happened",
    "First-level cause (usually technical/physical)",
    "Why did that first cause occur?",
    "Why did the second cause occur?",
    "Why did the third cause occur?",
    "Why did the fourth cause occur?",
    "The fundamental cause that, if fixed, prevents recurrence"
  ),
  Type = c("Symptom", "Physical", "Physical/Human", "Human/Process",
           "Process/System", "System/Culture", "Root")
)

kable(template, col.names = c("Step", "Description", "Typical Cause Type"),
      caption = "5 Whys Analysis Template") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  row_spec(7, background = "#d4edda", bold = TRUE)
```

### Multiple Branches in 5 Whys

Sometimes a problem has multiple causes. When you encounter this, branch your analysis:

```{r branching-whys, echo=FALSE, fig.width=12, fig.height=7}
# Create branching 5 whys diagram
nodes <- data.frame(
  id = 1:9,
  label = c(
    "Defective welds\non assembly",
    "Insufficient\nheat input",
    "Wrong wire\nfeed speed",
    "Operator set\nincorrect parameter",
    "No parameter\nsheet at station",
    "Contaminated\nbase metal",
    "Parts not\ncleaned properly",
    "Cleaning step\nskipped",
    "Rush order\npressure"
  ),
  x = c(0, -2, -3, -3, -3, 2, 2, 2, 2),
  y = c(5, 4, 3, 2, 1, 4, 3, 2, 1),
  branch = c("Main", "A", "A", "A", "A", "B", "B", "B", "B")
)

edges <- data.frame(
  from_x = c(0, -2, -3, -3, 0, 2, 2, 2),
  from_y = c(5, 4, 3, 2, 5, 4, 3, 2),
  to_x = c(-2, -3, -3, -3, 2, 2, 2, 2),
  to_y = c(4, 3, 2, 1, 4, 3, 2, 1)
)

ggplot() +
  geom_segment(data = edges, aes(x = from_x, y = from_y, xend = to_x, yend = to_y),
               arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  geom_label(data = nodes, aes(x = x, y = y, label = label, fill = branch),
             size = 3, label.padding = unit(0.3, "lines")) +
  scale_fill_manual(values = c("Main" = "#e74c3c", "A" = "#3498db", "B" = "#27ae60"),
                    guide = "none") +
  annotate("text", x = -3, y = 0.3, label = "Root Cause A:\nMissing parameter documentation",
           fontface = "bold", size = 3.5, color = "#3498db") +
  annotate("text", x = 2, y = 0.3, label = "Root Cause B:\nSchedule pressure affecting quality",
           fontface = "bold", size = 3.5, color = "#27ae60") +
  labs(title = "Branching 5 Whys Analysis",
       subtitle = "When multiple causes exist, analyze each branch separately") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

<details><summary>**Practice Exercise**: Perform a 5 Whys Analysis</summary>

**Scenario:** A CNC machine produced 50 parts that were all 0.5mm undersize on a critical diameter.

Try to complete the 5 Whys analysis before looking at the sample answer below.

---

**Sample Analysis:**

1. **Problem:** CNC produced 50 undersize parts
2. **Why #1:** The tool offset was set incorrectly
3. **Why #2:** The operator entered the wrong offset value
4. **Why #3:** The operator misread the setup sheet
5. **Why #4:** The setup sheet had poor formatting and small print
6. **Why #5:** No standard format exists for setup documentation

**Root Cause:** Lack of standardized, clear setup documentation

**Corrective Actions:**
- Create standardized setup sheet template with large, clear fonts
- Add visual verification step (photo of correct setup)
- Implement first-piece inspection requirement before production run
</details>

---

## Ishikawa (Fishbone) Diagram

The **Ishikawa diagram**, also called a **fishbone diagram** or **cause-and-effect diagram**, was developed by Kaoru Ishikawa in the 1960s. It provides a structured way to brainstorm and categorize potential causes.

### The 6M Categories

Manufacturing problems are typically organized using the **6M** categories:

```{r 6m-categories, echo=FALSE, fig.width=11, fig.height=7}
categories <- data.frame(
  category = c("Man\n(People)", "Machine\n(Equipment)", "Material",
               "Method\n(Process)", "Measurement", "Mother Nature\n(Environment)"),
  x = c(1, 2, 3, 4, 5, 6),
  examples = c(
    "Training, skill,\nfatigue, attention",
    "Wear, calibration,\nmaintenance, age",
    "Quality, variation,\nsupplier, contamination",
    "Procedures, sequence,\nparameters, SOP",
    "Accuracy, precision,\ncalibration, method",
    "Temperature, humidity,\nvibration, cleanliness"
  )
)

ggplot(categories, aes(x = x, y = 1)) +
  geom_tile(aes(fill = category), width = 0.9, height = 1.5, color = "white", size = 2) +
  geom_text(aes(label = category), y = 1.3, fontface = "bold", size = 4, color = "white") +
  geom_text(aes(label = examples), y = 0.7, size = 2.8, color = "white") +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  labs(title = "The 6M Categories for Cause Analysis",
       subtitle = "Standard categories for organizing potential causes in manufacturing") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Constructing a Fishbone Diagram

```{r fishbone-example, echo=FALSE, fig.width=14, fig.height=9}
# Create a fishbone diagram for "Parts have surface scratches"
# Main spine
spine <- data.frame(
  x = c(-1, 8),
  y = c(0, 0)
)

# Problem box
problem <- data.frame(
  x = 8, y = 0,
  label = "Parts have\nsurface scratches"
)

# Main bones (categories)
bones <- data.frame(
  category = c("Man", "Machine", "Material", "Method", "Measurement", "Environment"),
  x_start = c(1, 3, 5, 1, 3, 5),
  y_start = c(3, 3, 3, -3, -3, -3),
  x_end = c(2, 4, 6, 2, 4, 6),
  y_end = c(0, 0, 0, 0, 0, 0)
)

# Sub-causes for each category
subcauses <- data.frame(
  category = c("Man", "Man", "Machine", "Machine", "Machine",
               "Material", "Material", "Method", "Method",
               "Measurement", "Environment", "Environment"),
  label = c("Improper handling", "Lack of training",
            "Worn conveyor belts", "Chuck jaw damage", "Fixture wear",
            "Material too soft", "Contaminated surface",
            "Parts stacked", "No protective wrap",
            "Scratch spec unclear",
            "Debris in air", "Dirty work surface"),
  x = c(1.2, 0.8, 3.2, 2.8, 3.5,
        5.2, 4.8, 1.2, 0.8,
        3.2, 5.2, 4.8),
  y = c(2.2, 1.5, 2.2, 1.5, 0.8,
        2.2, 1.5, -2.2, -1.5,
        -2.2, -2.2, -1.5)
)

ggplot() +
  # Main spine
  geom_segment(data = spine, aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),
               size = 2, color = "gray30") +
  # Problem box
  geom_label(data = problem, aes(x = x, y = y, label = label),
             fill = "#e74c3c", color = "white", fontface = "bold",
             size = 5, label.padding = unit(0.5, "lines")) +
  # Category bones
  geom_segment(data = bones, aes(x = x_start, y = y_start, xend = x_end, yend = y_end),
               size = 1.5, color = "steelblue") +
  # Category labels
  geom_label(data = bones, aes(x = x_start, y = y_start, label = category),
             fill = "steelblue", color = "white", fontface = "bold", size = 4) +
  # Sub-cause labels
  geom_text(data = subcauses, aes(x = x, y = y, label = label),
            size = 3, hjust = 0) +
  # Sub-cause lines
  geom_segment(data = subcauses,
               aes(x = x - 0.05, y = y,
                   xend = ifelse(y > 0, x + (3-y)/3 * 1, x + (3+y)/3 * 1),
                   yend = ifelse(y > 0, y - (3-y)/3 * y/2, y - (3+y)/3 * y/2)),
               color = "gray50", size = 0.5) +
  coord_cartesian(xlim = c(-0.5, 10), ylim = c(-4, 4)) +
  labs(title = "Fishbone Diagram: Parts Have Surface Scratches",
       subtitle = "Brainstorming potential causes organized by 6M categories") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, margin = margin(b = 20)))
```

### Fishbone Diagram Best Practices

```{r fishbone-tips, echo=FALSE}
tips <- data.frame(
  Guideline = c(
    "Team Approach",
    "No Evaluation During Brainstorming",
    "Use Specific Language",
    "Aim for 3-5 Causes per Category",
    "Circle the Most Likely",
    "Verify with Data"
  ),
  Description = c(
    "Include operators, engineers, maintenance, quality - diverse perspectives",
    "Capture all ideas first; evaluate feasibility later",
    "Not 'machine problem' but 'bearing wear on spindle motor'",
    "Some categories may have more; don't force causes into categories",
    "After brainstorming, identify 2-3 most probable causes to investigate",
    "Don't assume - test hypotheses with data before implementing fixes"
  )
)

kable(tips, caption = "Best Practices for Fishbone Diagram Development") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "28%")
```

### Video: How to Create a Fishbone Diagram

<iframe width="560" height="315" src="https://www.youtube.com/embed/mLvizyDFLQ4" title="Fishbone Diagram Tutorial" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Fault Tree Analysis (FTA)

**Fault Tree Analysis** is a top-down, deductive analysis method that uses Boolean logic to analyze undesired events. Originally developed for the aerospace industry, FTA is particularly useful for complex systems with multiple potential failure paths.

### FTA Symbols

```{r fta-symbols, echo=FALSE}
symbols <- data.frame(
  Symbol = c("Rectangle", "Circle", "Diamond", "House", "AND Gate", "OR Gate"),
  Name = c("Intermediate Event", "Basic Event", "Undeveloped Event",
           "Normal Event", "AND Gate", "OR Gate"),
  Meaning = c(
    "A fault event that results from combination of other events",
    "A basic failure that cannot be broken down further",
    "Event not analyzed further (outside scope or insufficient data)",
    "An event expected to occur during normal operation",
    "Output occurs only if ALL inputs occur",
    "Output occurs if ANY input occurs"
  ),
  Example = c(
    "Pump fails to deliver flow",
    "Motor winding burnout",
    "Power grid failure",
    "Normal wear over time",
    "Both sensor AND controller fail",
    "Either fuse blows OR breaker trips"
  )
)

kable(symbols, caption = "Fault Tree Analysis Symbols") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%") %>%
  column_spec(2, width = "18%")
```

### FTA Example: Pump Fails to Deliver Flow

```{r fta-example, echo=FALSE, fig.width=14, fig.height=10}
# Create FTA diagram nodes
fta_nodes <- data.frame(
  id = 1:13,
  label = c(
    "Pump fails to\ndeliver flow",
    "No power\nto pump",
    "Mechanical\nfailure",
    "No fluid\navailable",
    "Main breaker\ntripped",
    "Motor\nfailure",
    "Impeller\nfailure",
    "Shaft\nseized",
    "Tank\nempty",
    "Inlet valve\nclosed",
    "Suction line\nblocked",
    "Impeller\nworn",
    "Impeller\nbroken"
  ),
  x = c(7, 3, 7, 11, 3, 5.5, 7, 8.5, 10, 11, 12, 6.5, 7.5),
  y = c(10, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 1, 1),
  type = c("intermediate", "intermediate", "intermediate", "intermediate",
           "basic", "basic", "intermediate", "basic",
           "basic", "basic", "basic", "basic", "basic"),
  gate = c("OR", "OR", "OR", "OR", NA, NA, "OR", NA, NA, NA, NA, NA, NA)
)

# Create edges
fta_edges <- data.frame(
  from = c(1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 7, 7),
  to = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)
)

ggplot() +
  # Draw connecting lines
  geom_segment(aes(x = 7, y = 9.3, xend = 3, yend = 7.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 9.3, xend = 7, yend = 7.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 9.3, xend = 11, yend = 7.7), color = "gray30") +
  geom_segment(aes(x = 3, y = 6.3, xend = 3, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 6.3, xend = 5.5, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 6.3, xend = 7, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 6.3, xend = 8.5, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 11, y = 6.3, xend = 10, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 11, y = 6.3, xend = 11, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 11, y = 6.3, xend = 12, yend = 4.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 3.3, xend = 6.5, yend = 1.7), color = "gray30") +
  geom_segment(aes(x = 7, y = 3.3, xend = 7.5, yend = 1.7), color = "gray30") +
  # OR gates (simplified as triangles)
  geom_point(aes(x = c(7, 3, 7, 11, 7), y = c(9, 6, 6, 6, 3)),
             shape = 25, size = 8, fill = "yellow", color = "black") +
  annotate("text", x = c(7, 3, 7, 11, 7), y = c(9, 6, 6, 6, 3),
           label = "OR", size = 2, fontface = "bold") +
  # Intermediate events (rectangles)
  geom_tile(data = fta_nodes[fta_nodes$type == "intermediate",],
            aes(x = x, y = y, width = 2.3, height = 1.2),
            fill = "#3498db", color = "black") +
  geom_text(data = fta_nodes[fta_nodes$type == "intermediate",],
            aes(x = x, y = y, label = label),
            color = "white", size = 2.8, fontface = "bold") +
  # Basic events (circles)
  geom_point(data = fta_nodes[fta_nodes$type == "basic",],
             aes(x = x, y = y), size = 15, color = "black", fill = "#27ae60", shape = 21) +
  geom_text(data = fta_nodes[fta_nodes$type == "basic",],
            aes(x = x, y = y, label = label),
            color = "white", size = 2.5) +
  # Top event styling
  geom_tile(aes(x = 7, y = 10, width = 2.5, height = 1.3),
            fill = "#e74c3c", color = "black", size = 1.5) +
  geom_text(aes(x = 7, y = 10, label = "Pump fails to\ndeliver flow"),
            color = "white", size = 3.5, fontface = "bold") +
  scale_y_continuous(limits = c(0, 11)) +
  scale_x_continuous(limits = c(0, 14)) +
  labs(title = "Fault Tree Analysis: Pump Fails to Deliver Flow",
       subtitle = "OR gates mean any single path can cause the top event") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Calculating Probability with FTA

FTA allows quantitative risk analysis by calculating the probability of the top event:

**OR Gate:** P(output) = 1 - [(1 - P~A~) × (1 - P~B~) × ...]
*Simplified:* P(output) ≈ P~A~ + P~B~ (when probabilities are small)

**AND Gate:** P(output) = P~A~ × P~B~ × ...

```{r fta-calculation, echo=TRUE}
# Example: Calculate top event probability
# Basic event probabilities (annual failure rates)
P_breaker_trip <- 0.02
P_motor_fail <- 0.01
P_impeller_worn <- 0.03
P_impeller_break <- 0.005
P_shaft_seize <- 0.008
P_tank_empty <- 0.05
P_valve_closed <- 0.01
P_line_blocked <- 0.02

# Impeller failure (OR gate)
P_impeller_fail <- 1 - (1 - P_impeller_worn) * (1 - P_impeller_break)
cat("P(Impeller failure):", round(P_impeller_fail, 4), "\n")

# Mechanical failure (OR gate)
P_mechanical <- 1 - (1 - P_motor_fail) * (1 - P_impeller_fail) * (1 - P_shaft_seize)
cat("P(Mechanical failure):", round(P_mechanical, 4), "\n")

# No fluid available (OR gate)
P_no_fluid <- 1 - (1 - P_tank_empty) * (1 - P_valve_closed) * (1 - P_line_blocked)
cat("P(No fluid available):", round(P_no_fluid, 4), "\n")

# Top event: Pump fails (OR gate)
P_top <- 1 - (1 - P_breaker_trip) * (1 - P_mechanical) * (1 - P_no_fluid)
cat("P(Pump fails to deliver flow):", round(P_top, 4), "\n")
cat("This represents a", round(P_top * 100, 1), "% annual probability of failure")
```

---

## Pareto Analysis

**Pareto Analysis** is based on the Pareto Principle (80/20 rule): roughly 80% of effects come from 20% of causes. This helps prioritize problem-solving efforts.

### Creating a Pareto Chart

```{r pareto-example, echo=FALSE, fig.width=12, fig.height=7}
# Defect data for a manufacturing line
defects <- data.frame(
  Defect_Type = c("Surface Scratch", "Dimensional Error", "Burrs",
                  "Missing Feature", "Wrong Material", "Contamination",
                  "Color Mismatch", "Packaging Damage"),
  Count = c(145, 98, 67, 34, 28, 21, 15, 12)
)

# Sort by count
defects <- defects[order(-defects$Count),]
defects$Defect_Type <- factor(defects$Defect_Type, levels = defects$Defect_Type)

# Calculate cumulative percentage
defects$Cumulative <- cumsum(defects$Count)
defects$Cum_Percent <- defects$Cumulative / sum(defects$Count) * 100

ggplot(defects, aes(x = Defect_Type)) +
  geom_bar(aes(y = Count), stat = "identity", fill = "steelblue", width = 0.7) +
  geom_line(aes(y = Cum_Percent * max(Count) / 100, group = 1),
            color = "#e74c3c", size = 1.2) +
  geom_point(aes(y = Cum_Percent * max(Count) / 100),
             color = "#e74c3c", size = 3) +
  geom_text(aes(y = Count, label = Count), vjust = -0.5, size = 3.5) +
  geom_text(aes(y = Cum_Percent * max(Count) / 100,
                label = paste0(round(Cum_Percent, 0), "%")),
            vjust = -1, hjust = -0.2, size = 3, color = "#e74c3c") +
  geom_hline(yintercept = 80 * max(defects$Count) / 100,
             linetype = "dashed", color = "gray50") +
  annotate("text", x = 7.5, y = 80 * max(defects$Count) / 100 + 5,
           label = "80% line", size = 3.5, color = "gray40") +
  scale_y_continuous(
    name = "Defect Count",
    sec.axis = sec_axis(~. * 100 / max(defects$Count), name = "Cumulative %")
  ) +
  labs(title = "Pareto Chart: Manufacturing Defects by Type",
       subtitle = "Focus on Surface Scratch and Dimensional Error to address 58% of all defects",
       x = "Defect Type") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold", size = 14),
    axis.title.y.right = element_text(color = "#e74c3c")
  )
```

### Interpreting Pareto Analysis

```{r pareto-interpretation, echo=TRUE}
# Pareto analysis interpretation
defects <- data.frame(
  Defect = c("Surface Scratch", "Dimensional Error", "Burrs",
             "Missing Feature", "Wrong Material", "Contamination",
             "Color Mismatch", "Packaging Damage"),
  Count = c(145, 98, 67, 34, 28, 21, 15, 12)
)

defects <- defects[order(-defects$Count),]
defects$Cumulative_Pct <- cumsum(defects$Count) / sum(defects$Count) * 100

# Identify the "vital few" (those that contribute to 80%)
vital_few <- defects[defects$Cumulative_Pct <= 80 |
                      c(TRUE, defects$Cumulative_Pct[-nrow(defects)] < 80),]

cat("Total defects:", sum(defects$Count), "\n")
cat("\nVital Few (contributing to ~80% of defects):\n")
print(vital_few[, c("Defect", "Count", "Cumulative_Pct")])
cat("\nFocusing on these", nrow(vital_few), "defect types addresses",
    round(max(vital_few$Cumulative_Pct), 1), "% of all defects")
```

### Stratified Pareto Analysis

Sometimes you need to break down categories further:

```{r stratified-pareto, echo=FALSE, fig.width=12, fig.height=6}
# Stratified analysis of "Surface Scratch" defect
scratch_causes <- data.frame(
  Cause = c("Handling damage", "Fixture marks", "Chip scratches",
            "Conveyor marks", "Tool marks", "Unknown"),
  Count = c(52, 38, 28, 15, 8, 4)
)

scratch_causes <- scratch_causes[order(-scratch_causes$Count),]
scratch_causes$Cause <- factor(scratch_causes$Cause, levels = scratch_causes$Cause)
scratch_causes$Cumulative <- cumsum(scratch_causes$Count)
scratch_causes$Cum_Pct <- scratch_causes$Cumulative / sum(scratch_causes$Count) * 100

ggplot(scratch_causes, aes(x = Cause)) +
  geom_bar(aes(y = Count), stat = "identity", fill = "#27ae60", width = 0.7) +
  geom_line(aes(y = Cum_Pct * max(Count) / 100, group = 1),
            color = "#e74c3c", size = 1.2) +
  geom_point(aes(y = Cum_Pct * max(Count) / 100),
             color = "#e74c3c", size = 3) +
  geom_text(aes(y = Count, label = Count), vjust = -0.5, size = 4) +
  geom_hline(yintercept = 80 * max(scratch_causes$Count) / 100,
             linetype = "dashed", color = "gray50") +
  scale_y_continuous(
    name = "Count",
    sec.axis = sec_axis(~. * 100 / max(scratch_causes$Count), name = "Cumulative %")
  ) +
  labs(title = "Stratified Pareto: Causes of Surface Scratch Defects",
       subtitle = "Drilling down into the #1 defect type",
       x = "Scratch Cause") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold", size = 14)
  )
```

---

## Is/Is Not Analysis

**Is/Is Not Analysis** is a structured comparison technique that helps narrow down the scope and identify distinguishing factors of a problem.

### Is/Is Not Matrix

```{r is-isnot-example, echo=FALSE}
is_isnot <- data.frame(
  Dimension = c("WHAT", "WHAT", "WHERE", "WHERE", "WHEN", "WHEN", "EXTENT", "EXTENT"),
  Question = c(
    "What object has the problem?",
    "What is the defect/symptom?",
    "Where is the problem observed?",
    "Where on the object is the defect?",
    "When was it first observed?",
    "When in the process/cycle?",
    "How many units affected?",
    "Is it trending up/down/stable?"
  ),
  IS = c(
    "Motor on Line 3",
    "Overheating (85°C)",
    "Packaging area, Station 4",
    "Motor housing, bearing end",
    "Monday morning shift",
    "After 2 hours of operation",
    "100% - every shift",
    "Stable - same every day"
  ),
  IS_NOT = c(
    "Motors on Lines 1, 2, 4",
    "Noise, vibration, or failure",
    "Any other station",
    "Drive end, junction box",
    "Before weekend (Friday OK)",
    "Cold start or end of shift",
    "Intermittent",
    "Getting worse over time"
  ),
  Distinction = c(
    "Line 3 motor is older, different model",
    "Thermal issue, not mechanical yet",
    "Station 4 has higher load demand",
    "Bearing end runs hotter normally",
    "Something changed over weekend",
    "Heat buildup issue",
    "Consistent problem",
    "Stable - not progressive failure"
  )
)

kable(is_isnot, col.names = c("Dimension", "Question", "IS", "IS NOT", "What's Different?"),
      caption = "Is/Is Not Analysis: Motor Overheating Problem") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "8%") %>%
  column_spec(2, width = "20%") %>%
  column_spec(3, background = "#d4edda", width = "22%") %>%
  column_spec(4, background = "#f8d7da", width = "22%") %>%
  column_spec(5, background = "#fff3cd", width = "28%")
```

### Key Insights from Is/Is Not Analysis

From the example above, we can identify:

1. **Line 3 specific** - Not a general problem across all lines
2. **Thermal, not mechanical** - Overheating but no noise/vibration yet
3. **After warm-up** - Heat accumulation issue
4. **Started after weekend** - Something changed

**Investigation focus:** What changed over the weekend? Check maintenance logs, any work done on Line 3, any environmental changes.

---

## The 8D Problem-Solving Methodology

The **8D (Eight Disciplines)** methodology is a comprehensive problem-solving approach developed by Ford Motor Company. It's widely used in automotive and other industries.

```{r 8d-overview, echo=FALSE, fig.width=12, fig.height=8}
d8_steps <- data.frame(
  D = paste0("D", 0:8),
  Name = c("Plan", "Team", "Problem", "Containment", "Root Cause",
           "Corrective Actions", "Implementation", "Prevention", "Closure"),
  Description = c(
    "Plan the 8D approach; determine if 8D is appropriate",
    "Establish a cross-functional team with required skills",
    "Define and describe the problem in measurable terms",
    "Implement temporary actions to protect customer",
    "Identify and verify root cause(s) using RCA tools",
    "Develop and verify permanent corrective actions",
    "Implement and validate permanent corrective actions",
    "Prevent recurrence; update systems and procedures",
    "Recognize team; document learnings; close out"
  ),
  y = 9:1
)

ggplot(d8_steps, aes(x = 1, y = y)) +
  geom_tile(aes(fill = y), width = 6, height = 0.85, color = "white", size = 1) +
  geom_text(aes(x = -1.5, label = D), fontface = "bold", size = 6, color = "steelblue") +
  geom_text(aes(x = -0.5, label = Name), fontface = "bold", size = 4, hjust = 0) +
  geom_text(aes(x = 1.3, label = Description), size = 3.2, hjust = 0) +
  scale_fill_gradient(low = "#27ae60", high = "#3498db", guide = "none") +
  coord_cartesian(xlim = c(-2, 5)) +
  labs(title = "The 8D Problem-Solving Methodology",
       subtitle = "A structured approach for complex problems requiring cross-functional teams") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Detailed 8D Steps

```{r 8d-details, echo=FALSE}
d8_detail <- data.frame(
  Discipline = c("D0: Plan", "D1: Team", "D2: Problem", "D3: Containment",
                 "D4: Root Cause", "D5: Corrective Actions",
                 "D6: Implementation", "D7: Prevention", "D8: Closure"),
  Key_Activities = c(
    "Emergency response actions, initial assessment, determine if 8D needed",
    "Select team leader, identify required expertise, define roles",
    "5W2H, Is/Is Not, quantify impact, identify affected parts/lots",
    "Sort suspect material, increase inspection, alert downstream",
    "5 Whys, Fishbone, FTA, verify cause by testing",
    "Brainstorm solutions, verify effectiveness before full rollout",
    "Execute action plan, validate results, monitor KPIs",
    "Update FMEAs, procedures, training, share across organization",
    "Final documentation, lessons learned, team recognition"
  ),
  Deliverables = c(
    "8D initiation decision, emergency actions",
    "Team charter, member list with expertise",
    "Problem statement, scope definition",
    "Containment actions, protected customer",
    "Verified root cause(s)",
    "Verified corrective action plan",
    "Implemented actions, validated results",
    "Updated procedures, similar problem prevention",
    "8D report, closed status"
  )
)

kable(d8_detail, col.names = c("Discipline", "Key Activities", "Deliverables"),
      caption = "8D Methodology Detailed Breakdown") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### D3: Containment Actions

Containment is crucial to protect the customer while you investigate:

```{r containment-types, echo=FALSE}
containment <- data.frame(
  Type = c("Sort & Inspect", "Rework/Repair", "Scrap", "Hold/Quarantine",
           "Increase Monitoring", "Supplier Notification", "Customer Alert"),
  Description = c(
    "100% inspection of suspect inventory to separate good from bad",
    "Repair nonconforming units if possible and economical",
    "Dispose of units that cannot be repaired",
    "Prevent movement of suspect material until disposition",
    "Add inspections, increase sampling, tighten control limits",
    "Notify suppliers if incoming material is suspected",
    "Alert customers to check their inventory if product shipped"
  ),
  Example = c(
    "Inspect all parts from Lot 2024-0215",
    "Re-machine undersize diameters to specification",
    "Dispose of parts with cracks",
    "Tag and segregate all parts from affected shift",
    "Add 100% visual inspection at Pack station",
    "Request material certification from steel supplier",
    "Contact distributor about potentially affected batch"
  )
)

kable(containment, caption = "Types of Containment Actions") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

---

## Corrective Action Implementation

Effective corrective actions address the root cause and prevent recurrence.

### Types of Corrective Actions

```{r corrective-action-hierarchy, echo=FALSE, fig.width=11, fig.height=7}
ca_types <- data.frame(
  level = 1:5,
  type = c("Eliminate", "Substitute", "Engineering Controls",
           "Administrative Controls", "Personal Actions"),
  description = c(
    "Remove the cause entirely",
    "Replace with less risky alternative",
    "Physical changes to equipment/process",
    "Procedures, training, SOPs",
    "Rely on human behavior"
  ),
  effectiveness = c("Highest", "High", "Medium-High", "Medium", "Low"),
  example = c(
    "Eliminate manual handling by automating",
    "Replace toxic chemical with safer alternative",
    "Add interlock to prevent wrong operation",
    "Update procedure, add checklist",
    "Train operator to be more careful"
  ),
  reliability = c(95, 85, 75, 50, 30),
  color = c("#27ae60", "#2ecc71", "#f1c40f", "#e67e22", "#e74c3c")
)

ggplot(ca_types, aes(x = reorder(type, reliability), y = reliability)) +
  geom_bar(stat = "identity", aes(fill = color), width = 0.7) +
  geom_text(aes(label = paste0(reliability, "%")), hjust = -0.2, size = 4) +
  geom_text(aes(y = 5, label = example), hjust = 0, size = 3, color = "white") +
  scale_fill_identity() +
  coord_flip() +
  scale_y_continuous(limits = c(0, 110)) +
  labs(title = "Corrective Action Hierarchy",
       subtitle = "Higher-level controls are more reliable and effective",
       x = "", y = "Reliability (% effective in preventing recurrence)") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 11)
  )
```

### SMART Corrective Actions

Corrective actions should be **SMART**:

```{r smart-actions, echo=FALSE}
smart <- data.frame(
  Letter = c("S", "M", "A", "R", "T"),
  Meaning = c("Specific", "Measurable", "Achievable", "Relevant", "Time-bound"),
  Description = c(
    "Clearly defined action, not vague",
    "Can verify completion and effectiveness",
    "Realistic with available resources",
    "Directly addresses the root cause",
    "Has a target completion date"
  ),
  Bad_Example = c(
    "Improve quality",
    "Train operators",
    "Redesign entire product line",
    "Repaint the floor",
    "Do this sometime soon"
  ),
  Good_Example = c(
    "Install poka-yoke sensor on Station 3 to detect missing holes",
    "Train all operators on new SOP-234 with signed competency verification",
    "Add inspection step (1 min/part) with existing CMM capacity",
    "Add check fixture to verify hole position before assembly",
    "Complete by March 15, 2024"
  )
)

kable(smart, col.names = c("", "Meaning", "Description", "Poor Example", "Good Example"),
      caption = "SMART Corrective Action Criteria") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, background = "steelblue", color = "white", width = "4%") %>%
  column_spec(4, background = "#f8d7da") %>%
  column_spec(5, background = "#d4edda")
```

---

## Verification and Validation

Before closing out a problem, verify that your actions worked.

### Verification vs. Validation

```{r vv-comparison, echo=FALSE}
vv <- data.frame(
  Aspect = c("Definition", "Focus", "Question", "Timing", "Methods"),
  Verification = c(
    "Did we implement the action correctly?",
    "Process compliance",
    "Did we build the fix right?",
    "During/after implementation",
    "Audits, inspections, checklists"
  ),
  Validation = c(
    "Did the action solve the problem?",
    "Results and effectiveness",
    "Did we build the right fix?",
    "After implementation, during monitoring",
    "Data analysis, trend charts, capability studies"
  )
)

kable(vv, col.names = c("Aspect", "Verification", "Validation"),
      caption = "Verification vs. Validation of Corrective Actions") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%") %>%
  column_spec(2, background = "#e3f2fd") %>%
  column_spec(3, background = "#e8f5e9")
```

### Effectiveness Monitoring

```{r effectiveness-tracking, echo=FALSE, fig.width=12, fig.height=6}
# Simulate defect rate before and after corrective action
set.seed(42)
n <- 30
dates <- seq.Date(from = as.Date("2024-01-01"), by = "day", length.out = n)
ca_date <- as.Date("2024-01-15")  # Corrective action implemented

defect_rate <- c(
  rnorm(14, mean = 4.5, sd = 1),  # Before CA
  rnorm(16, mean = 1.5, sd = 0.5)  # After CA
)
defect_rate[defect_rate < 0] <- 0.2

effectiveness_data <- data.frame(
  Date = dates,
  Defect_Rate = defect_rate,
  Period = ifelse(dates < ca_date, "Before CA", "After CA")
)

ggplot(effectiveness_data, aes(x = Date, y = Defect_Rate)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(aes(color = Period), size = 3) +
  geom_vline(xintercept = as.numeric(ca_date), linetype = "dashed",
             color = "red", size = 1) +
  annotate("text", x = ca_date, y = max(defect_rate) * 0.95,
           label = "Corrective Action\nImplemented", hjust = -0.1,
           fontface = "bold", color = "red", size = 3.5) +
  geom_hline(yintercept = mean(defect_rate[1:14]), linetype = "dashed",
             color = "orange", alpha = 0.7) +
  annotate("text", x = min(dates), y = mean(defect_rate[1:14]) + 0.3,
           label = paste0("Before avg: ", round(mean(defect_rate[1:14]), 1), "%"),
           hjust = 0, size = 3, color = "orange") +
  geom_hline(yintercept = mean(defect_rate[15:30]), linetype = "dashed",
             color = "darkgreen", alpha = 0.7) +
  annotate("text", x = max(dates), y = mean(defect_rate[15:30]) + 0.3,
           label = paste0("After avg: ", round(mean(defect_rate[15:30]), 1), "%"),
           hjust = 1, size = 3, color = "darkgreen") +
  scale_color_manual(values = c("Before CA" = "orange", "After CA" = "darkgreen")) +
  labs(title = "Corrective Action Effectiveness Monitoring",
       subtitle = "Defect rate tracked before and after implementation",
       x = "", y = "Defect Rate (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom"
  )
```

```{r effectiveness-calculation, echo=TRUE}
# Calculate improvement
before_avg <- mean(defect_rate[1:14])
after_avg <- mean(defect_rate[15:30])
improvement <- (before_avg - after_avg) / before_avg * 100

cat("Before corrective action: ", round(before_avg, 2), "% defect rate\n")
cat("After corrective action:  ", round(after_avg, 2), "% defect rate\n")
cat("Improvement:              ", round(improvement, 1), "% reduction\n")
```

---

## Case Study: Automotive Welding Defects

Let's work through a comprehensive troubleshooting case using multiple RCA tools.

### The Problem

A Tier-1 automotive supplier is experiencing weld porosity defects on a critical structural component. Customer complaints have increased, and the plant has received a quality alert.

### Initial Problem Definition (5W2H)

```{r case-5w2h, echo=FALSE}
case_problem <- data.frame(
  Question = c("WHAT", "WHERE", "WHEN", "WHO", "WHY", "HOW", "HOW MUCH"),
  Answer = c(
    "Porosity (gas pockets) in MIG welds on crossmember subassembly",
    "Robot welding Cell 4, occurring at weld joint W-23 (corner weld)",
    "Started approximately 2 weeks ago, occurs on all shifts",
    "Detected by customer during their incoming inspection",
    "Customer rejecting parts; risk of production line stop",
    "Visible voids on X-ray inspection; some visible to naked eye",
    "Estimated 8% of parts affected (up from baseline of 0.5%)"
  )
)

kable(case_problem, col.names = c("Question", "Details"),
      caption = "Case Study Problem Definition") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%")
```

### 5 Whys Analysis

```{r case-5whys, echo=FALSE}
case_whys <- data.frame(
  Level = c("Problem", "Why #1", "Why #2", "Why #3", "Why #4", "Why #5"),
  Finding = c(
    "Porosity in welds at joint W-23",
    "Gas entrapment during solidification",
    "Inadequate shielding gas coverage",
    "Gas flow rate dropped below specification",
    "Flow meter was not calibrated; showing higher than actual",
    "No calibration schedule existed for welding gas flow meters"
  )
)

kable(case_whys, caption = "5 Whys Analysis: Weld Porosity") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%") %>%
  row_spec(6, background = "#d4edda", bold = TRUE)
```

### Fishbone Diagram Findings

After brainstorming with the cross-functional team:

```{r case-fishbone-findings, echo=FALSE}
fishbone_findings <- data.frame(
  Category = c("Machine", "Machine", "Material", "Material",
               "Method", "Method", "Man", "Environment"),
  Potential_Cause = c(
    "Gas flow meter out of calibration",
    "Worn contact tip affecting arc stability",
    "Different wire lot from new supplier",
    "Base metal surface contamination",
    "Robot path too fast for corner weld",
    "Gas pre-flow time insufficient",
    "Recent operator turnover, less experience",
    "Seasonal humidity changes"
  ),
  Likelihood = c("HIGH", "Medium", "Medium", "Low",
                 "Medium", "HIGH", "Low", "Low"),
  Verified = c("YES - Root cause", "No - tips OK", "No - tested OK",
               "No - clean parts", "Partial contributor",
               "YES - Contributing", "No - all shifts affected", "No - controlled")
)

kable(fishbone_findings,
      col.names = c("Category", "Potential Cause", "Likelihood", "Verification Result"),
      caption = "Fishbone Analysis Results with Verification") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%") %>%
  row_spec(c(1, 6), background = "#d4edda")
```

### 8D Report Summary

```{r case-8d, echo=FALSE}
d8_report <- data.frame(
  D = paste0("D", 1:8),
  Discipline = c("Team", "Problem", "Containment", "Root Cause",
                 "Corrective Actions", "Implementation", "Prevention", "Closure"),
  Actions = c(
    "Team: Weld Engineer (lead), Quality, Maintenance, Production Supervisor, Supplier Quality",
    "8% porosity rate at W-23 joint since Jan 15; customer quality alert received Jan 28",
    "100% X-ray inspection of all crossmembers; sort and quarantine 3 days production",
    "Primary: Flow meter out of calibration (reading 25 CFH, actual 18 CFH). Contributing: Pre-flow time was 0.3s, spec requires 0.5s",
    "1. Recalibrate flow meter immediately; 2. Increase pre-flow time to 0.5s; 3. Add flow meter to calibration schedule",
    "Actions completed Feb 5; validation testing shows 0.1% porosity rate (below 0.5% target)",
    "Updated PM schedule to include all gas flow meters quarterly; added to PFMEA with RPN recalculation",
    "Customer satisfied with response; 8D closed Feb 15; cost avoidance: $45,000 (avoided line stop)"
  )
)

kable(d8_report, col.names = c("D#", "Discipline", "Summary"),
      caption = "8D Report: Weld Porosity Case Study") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "6%") %>%
  column_spec(2, bold = TRUE, width = "15%")
```

---

## Documentation and Knowledge Management

Proper documentation ensures learnings are captured and problems don't recur.

### Key Documentation Elements

```{r documentation-checklist, echo=FALSE}
doc_elements <- data.frame(
  Element = c("Problem Description", "Timeline", "Data Collected",
              "Root Cause Analysis", "Corrective Actions", "Verification Results",
              "Lessons Learned", "System Updates"),
  Contents = c(
    "5W2H, problem statement, impact/cost",
    "When discovered, key investigation dates, implementation dates",
    "Measurements, photos, test results, operator interviews",
    "5 Whys, fishbone diagrams, FTA as applicable",
    "Actions taken, responsible parties, target/actual dates",
    "Before/after data, statistical comparison, effectiveness %",
    "What we'd do differently, recommendations for similar situations",
    "PFMEA updates, procedure changes, training records"
  ),
  Benefit = c(
    "Clear reference for similar future problems",
    "Understanding of response time, identifying delays",
    "Evidence-based analysis, reference for future",
    "Documented logical process, training material",
    "Accountability, closure verification",
    "Proof of effectiveness, audit trail",
    "Continuous improvement, organizational learning",
    "Prevention of recurrence, compliance"
  )
)

kable(doc_elements, caption = "RCA Documentation Checklist") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Creating a Troubleshooting Knowledge Base

Build organizational memory by:

1. **Standardized templates** - Use consistent formats for all RCA documents
2. **Searchable database** - Store in CMMS, SharePoint, or dedicated quality system
3. **Categories and tags** - Equipment type, failure mode, root cause category
4. **Cross-references** - Link related issues and solutions
5. **Regular reviews** - Periodic analysis of trends and patterns

---

## Troubleshooting Tools Quick Reference

```{r tool-selection, echo=FALSE}
tool_guide <- data.frame(
  Tool = c("5 Whys", "Fishbone Diagram", "Fault Tree Analysis",
           "Pareto Chart", "Is/Is Not", "8D", "Change Analysis"),
  Best_For = c(
    "Simple problems with linear cause chains",
    "Brainstorming multiple potential causes",
    "Complex systems with multiple failure paths",
    "Prioritizing which problems to tackle first",
    "Narrowing down scope and identifying distinctions",
    "Customer complaints requiring formal response",
    "Problems that started suddenly"
  ),
  When_to_Use = c(
    "Quick investigations, starting point for analysis",
    "Team problem-solving sessions",
    "Safety-critical systems, reliability analysis",
    "When facing multiple problems or defect types",
    "When problem is hard to define clearly",
    "Formal quality requirements, major issues",
    "When timing of problem onset is known"
  ),
  Team_Size = c("1-3", "4-8", "2-5", "1-3", "2-4", "5-10", "1-4")
)

kable(tool_guide,
      col.names = c("Tool", "Best For", "When to Use", "Team Size"),
      caption = "RCA Tool Selection Guide") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%")
```

---

## Video Resources

### Understanding 5 Whys

<iframe width="560" height="315" src="https://www.youtube.com/embed/SrlYkx41wEE" title="5 Whys Root Cause Analysis" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### 8D Problem Solving

<iframe width="560" height="315" src="https://www.youtube.com/embed/-9MUBLT0DjI" title="8D Problem Solving Methodology" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Summary

Effective troubleshooting and root cause analysis require:

1. **Systematic approach** - Don't guess; follow a structured methodology
2. **Clear problem definition** - Use 5W2H to clearly define what you're solving
3. **Data-driven analysis** - Collect facts before jumping to conclusions
4. **Root cause focus** - Don't stop at symptoms; dig to fundamental causes
5. **Multiple tools** - Use 5 Whys, Fishbone, FTA, Pareto as appropriate
6. **Effective corrective actions** - Aim for elimination, not just mitigation
7. **Verification** - Confirm your fix actually works with data
8. **Documentation** - Capture learnings to prevent recurrence

Remember: The goal isn't just to fix today's problem - it's to prevent tomorrow's.

---

## Review Questions

<details><summary>**Question 1**: What is the difference between a symptom, immediate cause, and root cause? Provide an example of each for a machine that is producing parts with excessive surface roughness.</summary>

**Answer:**

- **Symptom**: The observable effect of the problem
  - *Example: Parts have Ra surface roughness of 3.2 μm when specification is 1.6 μm*

- **Immediate cause**: The direct, technical cause of the symptom
  - *Example: Cutting tool is worn beyond its effective life*

- **Root cause**: The fundamental reason that, if eliminated, prevents recurrence
  - *Example: No tool life monitoring system exists; operators judge tool changes by intuition rather than data*

Fixing the root cause (implementing tool life tracking) prevents the problem from recurring, whereas just replacing the tool (addressing immediate cause) means it will happen again.
</details>

<details><summary>**Question 2**: A food processing plant is experiencing frequent jams on their packaging line. Perform a 5 Whys analysis given the following information: The jam occurs at the carton loading station, started last week, happens 4-5 times per shift, and the maintenance team found the timing of the pusher mechanism is off.</summary>

**Answer:**

1. **Problem**: Carton loading station jams 4-5 times per shift
2. **Why #1**: Cartons are not in position when pusher activates → Timing mismatch
3. **Why #2**: Pusher timing is off by approximately 0.3 seconds
4. **Why #3**: Timing adjustment was changed during last week's maintenance
5. **Why #4**: Technician didn't have correct specification for timing setting
6. **Why #5**: Maintenance procedure doesn't include timing specifications

**Root Cause**: Maintenance procedures lack critical parameter specifications

**Corrective Actions**:
- Update maintenance procedure with correct timing specification (180ms ± 10ms)
- Restore timing to correct setting immediately
- Review other procedures for missing specifications
- Add parameter verification checklist to PM activities
</details>

<details><summary>**Question 3**: Create a fishbone diagram outline (list the potential causes under each 6M category) for the problem "CNC machine producing parts 0.05mm oversize."</summary>

**Answer:**

**MAN (People)**
- Operator entered wrong offset
- Incorrect setup procedure followed
- Inadequate training on new program
- Fatigue/distraction during setup

**MACHINE (Equipment)**
- Spindle thermal growth
- Ballscrew wear/backlash
- Tool holder runout
- Axis positioning error

**MATERIAL**
- Material hardness variation
- Different lot from supplier
- Material springback
- Incorrect material grade

**METHOD (Process)**
- Wrong tool offset entered
- Program error in G-code
- Incorrect cutting parameters
- Missing roughing pass

**MEASUREMENT**
- Gauge out of calibration
- Wrong measurement technique
- Temperature affecting measurement
- Incorrect datum reference

**MOTHER NATURE (Environment)**
- Shop temperature variation
- Coolant temperature change
- Vibration from nearby equipment
- Humidity affecting gauges
</details>

<details><summary>**Question 4**: Given the following defect data from a sheet metal stamping operation, create a Pareto analysis and identify the vital few defects to focus on.</summary>

| Defect Type | Count |
|------------|-------|
| Scratches | 89 |
| Burrs | 156 |
| Wrinkles | 45 |
| Splits/Cracks | 28 |
| Dimensional | 112 |
| Surface Dents | 67 |
| Missing Features | 18 |

**Answer:**

```{r pareto-practice, echo=TRUE}
# Create and analyze the data
defects <- data.frame(
  Type = c("Burrs", "Dimensional", "Scratches", "Surface Dents",
           "Wrinkles", "Splits/Cracks", "Missing Features"),
  Count = c(156, 112, 89, 67, 45, 28, 18)
)

# Sort by count descending
defects <- defects[order(-defects$Count),]

# Calculate percentages
defects$Percent <- defects$Count / sum(defects$Count) * 100
defects$Cumulative <- cumsum(defects$Percent)

# Display results
print(defects)

# Identify vital few
vital_few <- defects$Type[defects$Cumulative <= 80 |
                           c(TRUE, defects$Cumulative[-nrow(defects)] < 80)]
cat("\nVital Few (contributing to ~80%):", paste(vital_few, collapse = ", "))
```

The **vital few** are Burrs, Dimensional errors, and Scratches - addressing these three defect types would address approximately 69% of all defects. Adding Surface Dents would bring the total to 82%.
</details>

<details><summary>**Question 5**: What are the key differences between verification and validation in the context of corrective actions?</summary>

**Answer:**

| Aspect | Verification | Validation |
|--------|--------------|------------|
| Question asked | Did we implement the action correctly? | Did the action solve the problem? |
| Focus | Process compliance | Results/outcomes |
| Timing | During/immediately after implementation | Ongoing monitoring after implementation |
| Methods | Audits, checklists, inspections | Data analysis, trend charts, SPC |
| Example | Confirm new sensor was installed per specification | Measure defect rate over 30 days to confirm reduction |

**Verification** confirms the action was done right.
**Validation** confirms we did the right action.

Both are required - an action can be implemented perfectly (verified) but still not solve the problem (not validated).
</details>

<details><summary>**Question 6**: An aerospace manufacturer has a requirement to use the 8D methodology for customer complaints. What happens in D3 (Containment) and why is it critical?</summary>

**Answer:**

**D3 Containment Actions** protect the customer while the root cause investigation continues. Key activities include:

1. **Immediate actions**:
   - Quarantine suspect inventory (tagged, segregated)
   - 100% inspection of suspect lots
   - Increase monitoring at subsequent operations
   - Sort parts at customer location if already shipped

2. **Documentation**:
   - Identify affected lot numbers, date codes, serial numbers
   - Quantify the scope of potential exposure
   - Document all containment actions taken

3. **Communication**:
   - Notify customer of actions being taken
   - Alert downstream operations
   - Inform suppliers if incoming material involved

**Why critical**:
- Prevents additional defective product from reaching the customer
- Limits the scope of the problem (cost, liability)
- Demonstrates responsiveness to customer
- Buys time for proper root cause investigation
- In aerospace, safety-of-flight concerns make containment essential

Without effective containment, the problem continues while you investigate, increasing customer impact and costs exponentially.
</details>

<details><summary>**Question 7**: Why might a team's 5 Whys analysis stop too early? What are signs that you haven't reached the true root cause?</summary>

**Answer:**

**Reasons teams stop too early**:
1. **Blame arrives** - Analysis ends at "operator error" without asking why the error occurred
2. **Comfort zone** - Team stops when they reach a cause they can easily fix
3. **Time pressure** - Rush to implement a fix, skipping deeper analysis
4. **Technical limit** - Team lacks expertise to go deeper into certain areas
5. **Defensiveness** - Reaching causes that implicate management or systems creates resistance

**Signs you haven't reached root cause**:
1. **Recurrence** - If the fix is "more training" or "be more careful," problem will return
2. **Human-based answer** - Root causes should typically be systems/processes, not individuals
3. **No prevention mechanism** - If fixing this cause doesn't prevent future occurrences, keep asking why
4. **Can still ask "why?"** - If there's a logical next level to investigate
5. **Administrative fix only** - If the solution is just a procedure or checklist with no engineering controls

**Example of stopping too early**:
- Stopping at: "Operator set wrong parameter"
- Should continue: Why? → No parameter sheet at workstation → Why? → No standard work documentation exists → Root cause: Missing standardized work process

The true root cause typically relates to systems, processes, or management decisions rather than individual actions.
</details>

<details><summary>**Question 8**: Describe how you would use Pareto analysis in a stratified manner to drill down into a quality problem.</summary>

**Answer:**

**Stratified Pareto Analysis** involves creating multiple levels of Pareto charts, progressively drilling down into the vital few categories.

**Example: High scrap rate at a machining shop**

**Level 1: Scrap by defect type**
1. Create Pareto of all defect types
2. Result: "Dimensional errors" is 45% of all scrap - investigate this first

**Level 2: Dimensional errors by machine**
1. Create Pareto of dimensional errors broken down by machine
2. Result: Machine #4 accounts for 60% of dimensional errors

**Level 3: Machine #4 dimensional errors by feature**
1. Create Pareto of which dimensions are failing on Machine #4
2. Result: Bore diameter is 70% of Machine #4 dimensional issues

**Level 4: Bore diameter issues by shift/operator**
1. Create Pareto by shift
2. Result: Evenly distributed - not operator-dependent (machine issue confirmed)

**Final Analysis**: Investigate boring operation on Machine #4 specifically - likely tool wear, spindle issue, or program error.

The stratified approach efficiently narrows focus from "we have a scrap problem" to "boring operation on Machine #4 has a systematic error."
</details>

<details><summary>**Question 9**: A defense contractor needs to analyze a safety-critical failure. Why might Fault Tree Analysis (FTA) be preferred over simpler methods like 5 Whys?</summary>

**Answer:**

**FTA advantages for safety-critical analysis**:

1. **Handles complexity**:
   - Safety-critical systems often have multiple redundancies and complex failure paths
   - FTA can model combinations of events that must occur together (AND gates) or alternatively (OR gates)
   - 5 Whys follows single linear path; FTA captures parallel paths

2. **Quantitative capability**:
   - FTA allows probability calculations for top event
   - Can identify minimum cut sets (smallest combinations that cause failure)
   - Supports reliability and safety integrity level (SIL) calculations
   - Defense/aerospace require quantitative risk assessment

3. **Documentation requirements**:
   - Regulatory bodies (FAA, DoD) often require FTA for critical systems
   - Provides auditable, traceable analysis
   - Standard symbols and methodology

4. **Identifies hidden failures**:
   - Can reveal single points of failure
   - Shows where redundancy is (or isn't) effective
   - Identifies common cause failures that defeat redundancy

5. **Design improvement**:
   - Visual representation helps identify where to add safeguards
   - Sensitivity analysis shows which basic events most affect risk
   - Supports design reviews and safety cases

**Example**: A missile guidance system failure
- 5 Whys might identify one cause path
- FTA would show all possible failure paths, calculate overall failure probability, and identify that two specific sensor failures AND a software error all occurring together could cause the top event, even though each alone is unlikely.
</details>

---

## References

1. Latino, R.J., Latino, K.C., & Latino, M.A. (2019). *Root Cause Analysis: Improving Performance for Bottom-Line Results* (5th ed.). CRC Press.

2. Okes, D. (2019). *Root Cause Analysis: The Core of Problem Solving and Corrective Action* (2nd ed.). ASQ Quality Press.

3. Andersen, B., & Fagerhaug, T. (2006). *Root Cause Analysis: Simplified Tools and Techniques* (2nd ed.). ASQ Quality Press.

4. AIAG. (2018). *CQI-20: Effective Problem Solving Guide*. Automotive Industry Action Group.

5. IEC 61025:2006. *Fault Tree Analysis (FTA)*. International Electrotechnical Commission.

6. Ishikawa, K. (1990). *Introduction to Quality Control*. 3A Corporation.

7. Juran, J.M. (1988). *Juran on Planning for Quality*. Free Press.

8. Ford Motor Company. (2019). *Global 8D Problem Solving Manual*. Ford Motor Company.

9. NASA. (2002). *Fault Tree Handbook with Aerospace Applications*. NASA Office of Safety and Mission Assurance.

10. Wilson, P.F., Dell, L.D., & Anderson, G.F. (1993). *Root Cause Analysis: A Tool for Total Quality Management*. ASQ Quality Press.

<!--chapter:end:11-Troubleshooting-RCA.Rmd-->

# Measurement Systems Analysis

```{r setup-ch12, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
library(ggforce)
```

## Learning Objectives

After completing this chapter, you will be able to:

1. Explain the importance of measurement system quality in process control
2. Identify the components of measurement system variation
3. Define and calculate accuracy, bias, linearity, stability, repeatability, and reproducibility
4. Conduct and interpret a Gauge R&R study using both the Range and ANOVA methods
5. Determine measurement system acceptability using %GRR and ndc criteria
6. Apply attribute measurement system analysis for pass/fail decisions
7. Recognize common sources of measurement error and implement improvements
8. Understand the relationship between MSA and SPC effectiveness

---

## Introduction to Measurement Systems Analysis

**Measurement Systems Analysis (MSA)** is the science of evaluating the quality of measurement processes. Before we can trust our data for process control, quality decisions, or capability studies, we must first verify that our measurement system is capable of providing reliable results.

### Why MSA Matters

> "You can't improve what you can't measure - but you also can't improve what you measure incorrectly."

Consider this scenario:

```{r msa-importance, echo=FALSE, fig.width=11, fig.height=6}
set.seed(42)
# Simulate the same part measured with good vs. poor measurement systems
true_value <- 25.00
n_measurements <- 50

# Good measurement system
good_system <- rnorm(n_measurements, mean = true_value, sd = 0.02)

# Poor measurement system
poor_system <- rnorm(n_measurements, mean = true_value + 0.05, sd = 0.15)

measurement_data <- data.frame(
  Measurement = c(good_system, poor_system),
  System = rep(c("Good Measurement System\n(Low variation, no bias)",
                  "Poor Measurement System\n(High variation, biased)"), each = n_measurements)
)

ggplot(measurement_data, aes(x = Measurement, fill = System)) +
  geom_histogram(bins = 20, color = "white", alpha = 0.8) +
  geom_vline(xintercept = true_value, linetype = "dashed", color = "red", size = 1.2) +
  geom_vline(xintercept = 25.00 - 0.10, linetype = "solid", color = "darkred", size = 0.8) +
  geom_vline(xintercept = 25.00 + 0.10, linetype = "solid", color = "darkred", size = 0.8) +
  annotate("text", x = true_value, y = 12, label = "True Value",
           color = "red", fontface = "bold", hjust = -0.1) +
  annotate("text", x = 24.90, y = 12, label = "LSL", color = "darkred", hjust = 1.1) +
  annotate("text", x = 25.10, y = 12, label = "USL", color = "darkred", hjust = -0.1) +
  facet_wrap(~System, ncol = 1) +
  labs(title = "The Same Parts Measured by Two Different Systems",
       subtitle = "Poor measurement systems lead to incorrect accept/reject decisions",
       x = "Measured Value (mm)", y = "Count") +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", size = 14),
        strip.text = element_text(face = "bold", size = 11))
```

### The Cost of Poor Measurement

```{r measurement-costs, echo=FALSE}
cost_impacts <- data.frame(
  Impact = c("False Accepts (Type II Error)",
             "False Rejects (Type I Error)",
             "Process Adjustment Errors",
             "Capability Misassessment",
             "Customer Complaints"),
  Description = c(
    "Bad parts passed as good; reach customer",
    "Good parts rejected as bad; scrapped or reworked",
    "Adjusting process based on measurement noise, not real changes",
    "Cp/Cpk calculations are wrong; true capability unknown",
    "Inconsistent quality due to measurement-based decisions"
  ),
  Consequence = c(
    "Warranty claims, recalls, reputation damage",
    "Increased scrap costs, reduced yield",
    "Over-adjustment increases variation (tampering)",
    "False confidence or unnecessary investment",
    "Loss of customer trust and business"
  )
)

kable(cost_impacts, caption = "Business Impact of Poor Measurement Systems") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "22%")
```

### MSA in Industry Standards

MSA is required by multiple quality standards:

- **IATF 16949** (Automotive): Requires MSA for all measurement systems referenced in control plans
- **AS9100** (Aerospace): Requires demonstrated measurement capability
- **ISO 9001**: Requires monitoring and measurement resources to be suitable
- **FDA 21 CFR Part 820** (Medical Devices): Requires validated measurement equipment

---

## Components of Measurement Variation

Total measurement variation comes from multiple sources. Understanding these components is essential for improvement.

### The Measurement System Model

```{r variation-components, echo=FALSE, fig.width=12, fig.height=8}
# Create hierarchical breakdown of measurement variation
components <- data.frame(
  label = c("Total Observed\nVariation",
            "Actual Part\nVariation", "Measurement\nSystem Variation",
            "Accuracy\n(Location)", "Precision\n(Spread)",
            "Bias", "Linearity", "Stability",
            "Repeatability\n(Equipment)", "Reproducibility\n(Appraiser)"),
  x = c(6, 3, 9, 7, 11, 6, 7, 8, 10, 12),
  y = c(5, 3, 3, 1, 1, -1, -1, -1, -1, -1),
  level = c(1, 2, 2, 3, 3, 4, 4, 4, 4, 4)
)

# Define connections
connections <- data.frame(
  x = c(6, 6, 9, 9, 7, 7, 7, 11, 11),
  xend = c(3, 9, 7, 11, 6, 7, 8, 10, 12),
  y = c(4.5, 4.5, 2.5, 2.5, 0.5, 0.5, 0.5, 0.5, 0.5),
  yend = c(3.5, 3.5, 1.5, 1.5, -0.5, -0.5, -0.5, -0.5, -0.5)
)

ggplot() +
  geom_segment(data = connections,
               aes(x = x, y = y, xend = xend, yend = yend),
               color = "gray50", size = 1) +
  geom_label(data = components,
             aes(x = x, y = y, label = label, fill = factor(level)),
             size = 3.5, fontface = "bold", color = "white",
             label.padding = unit(0.4, "lines")) +
  scale_fill_manual(values = c("1" = "#2c3e50", "2" = "#3498db",
                               "3" = "#27ae60", "4" = "#e74c3c"),
                    guide = "none") +
  coord_cartesian(xlim = c(0, 15), ylim = c(-2, 6)) +
  labs(title = "Components of Measurement System Variation",
       subtitle = "Total variation = Part variation + Measurement system variation") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, size = 11))
```

### Accuracy vs. Precision

These are often confused but are fundamentally different concepts:

```{r accuracy-precision, echo=FALSE, fig.width=12, fig.height=6}
set.seed(123)
n <- 30

# Create four scenarios
scenarios <- data.frame(
  x = c(rnorm(n, 0, 0.3), rnorm(n, 0, 1.2),
        rnorm(n, 1.5, 0.3), rnorm(n, 1.5, 1.2)),
  y = c(rnorm(n, 0, 0.3), rnorm(n, 0, 1.2),
        rnorm(n, 1.5, 0.3), rnorm(n, 1.5, 1.2)),
  Scenario = rep(c("Accurate & Precise\n(IDEAL)",
                   "Accurate but Imprecise",
                   "Precise but Inaccurate\n(Biased)",
                   "Inaccurate & Imprecise\n(WORST)"), each = n)
)

scenarios$Scenario <- factor(scenarios$Scenario,
                              levels = c("Accurate & Precise\n(IDEAL)",
                                        "Accurate but Imprecise",
                                        "Precise but Inaccurate\n(Biased)",
                                        "Inaccurate & Imprecise\n(WORST)"))

ggplot(scenarios, aes(x = x, y = y)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_point(aes(x = 0, y = 0), color = "red", size = 4, shape = 3, stroke = 2) +
  geom_circle(aes(x0 = 0, y0 = 0, r = 0.5), inherit.aes = FALSE,
              color = "red", linetype = "dashed") +
  geom_circle(aes(x0 = 0, y0 = 0, r = 1), inherit.aes = FALSE,
              color = "orange", linetype = "dashed") +
  geom_circle(aes(x0 = 0, y0 = 0, r = 1.5), inherit.aes = FALSE,
              color = "gold", linetype = "dashed") +
  facet_wrap(~Scenario, nrow = 1) +
  coord_fixed(xlim = c(-3, 3), ylim = c(-3, 3)) +
  labs(title = "Accuracy vs. Precision: The Target Analogy",
       subtitle = "Red crosshair = True value (bullseye)",
       x = "", y = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold", size = 10),
    axis.text = element_blank(),
    panel.grid = element_blank()
  )
```

```{r accuracy-precision-table, echo=FALSE}
ap_table <- data.frame(
  Characteristic = c("Accuracy", "Precision"),
  Definition = c("How close measurements are to the true value (average)",
                 "How close measurements are to each other (spread)"),
  Affected_By = c("Calibration, bias, linearity",
                  "Repeatability, reproducibility, resolution"),
  Correctable = c("Yes - through calibration and adjustment",
                  "Harder - often requires equipment upgrade"),
  Metric = c("Bias (average error from reference)",
             "Standard deviation of repeated measurements")
)

kable(ap_table, col.names = c("", "Definition", "Affected By", "Correctable?", "Primary Metric"),
      caption = "Accuracy vs. Precision Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%")
```

---

## Accuracy Studies

Accuracy studies evaluate how well the measurement system indicates the true value.

### Bias

**Bias** is the systematic error - the difference between the average of measurements and the true (reference) value.

$$\text{Bias} = \bar{x}_{observed} - x_{reference}$$

```{r bias-example, echo=FALSE, fig.width=10, fig.height=5}
set.seed(456)
reference <- 50.00
measurements <- rnorm(25, mean = 50.08, sd = 0.03)

bias_data <- data.frame(
  measurement = 1:25,
  value = measurements
)

ggplot(bias_data, aes(x = measurement, y = value)) +
  geom_point(color = "steelblue", size = 3) +
  geom_hline(yintercept = reference, color = "red", linetype = "dashed", size = 1) +
  geom_hline(yintercept = mean(measurements), color = "blue", size = 1) +
  annotate("text", x = 26, y = reference, label = "Reference = 50.00",
           hjust = 0, color = "red", fontface = "bold") +
  annotate("text", x = 26, y = mean(measurements),
           label = paste0("Average = ", round(mean(measurements), 3)),
           hjust = 0, color = "blue", fontface = "bold") +
  annotate("segment", x = 24, xend = 24, y = reference, yend = mean(measurements),
           arrow = arrow(ends = "both", length = unit(0.1, "inches")), color = "purple") +
  annotate("text", x = 23.5, y = (reference + mean(measurements))/2,
           label = paste0("Bias = ", round(mean(measurements) - reference, 3)),
           hjust = 1, color = "purple", fontface = "bold") +
  scale_x_continuous(limits = c(0, 30)) +
  labs(title = "Bias Study: Measuring a Reference Standard",
       subtitle = "25 repeated measurements of a certified reference block",
       x = "Measurement Number", y = "Measured Value (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
```

```{r bias-calculation, echo=TRUE}
# Bias study calculation
reference_value <- 50.000  # Certified reference standard
measurements <- c(50.08, 50.07, 50.09, 50.08, 50.06, 50.10, 50.07, 50.08,
                  50.09, 50.08, 50.07, 50.11, 50.08, 50.09, 50.07)

# Calculate bias
average_measured <- mean(measurements)
bias <- average_measured - reference_value

cat("Reference Value:", reference_value, "mm\n")
cat("Average Measured:", round(average_measured, 4), "mm\n")
cat("Bias:", round(bias, 4), "mm\n")
cat("Bias as % of Tolerance (±0.10):", round(abs(bias) / 0.10 * 100, 1), "%\n")

# Statistical test for significance
t_test <- t.test(measurements, mu = reference_value)
cat("\nt-test p-value:", round(t_test$p.value, 4))
if(t_test$p.value < 0.05) {
  cat(" - Bias is statistically significant\n")
} else {
  cat(" - Bias is not statistically significant\n")
}
```

### Linearity

**Linearity** measures whether bias changes across the measurement range. A gauge might be accurate at one end of its range but biased at the other.

```{r linearity-study, echo=FALSE, fig.width=11, fig.height=6}
# Simulate linearity study data
set.seed(789)
reference_points <- c(10, 25, 40, 55, 70)
n_per_point <- 12

linearity_data <- data.frame(
  Reference = rep(reference_points, each = n_per_point),
  Bias = c(
    rnorm(n_per_point, 0.02, 0.01),   # Small positive bias at low end
    rnorm(n_per_point, 0.01, 0.01),   # Slight positive bias
    rnorm(n_per_point, 0.00, 0.01),   # No bias at midpoint
    rnorm(n_per_point, -0.02, 0.01),  # Slight negative bias
    rnorm(n_per_point, -0.05, 0.01)   # Larger negative bias at high end
  )
)

# Fit regression
linearity_model <- lm(Bias ~ Reference, data = linearity_data)

ggplot(linearity_data, aes(x = Reference, y = Bias)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "lm", color = "red", se = TRUE, alpha = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  annotate("text", x = 60, y = 0.04,
           label = paste0("Slope = ", round(coef(linearity_model)[2], 5),
                         "\nLinearity = ", round(abs(coef(linearity_model)[2]) *
                                                   diff(range(reference_points)), 4), " mm"),
           hjust = 0, size = 4, fontface = "bold") +
  labs(title = "Linearity Study Results",
       subtitle = "Bias plotted against reference value across operating range",
       x = "Reference Value (mm)", y = "Bias (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
```

```{r linearity-calc, echo=TRUE}
# Linearity calculation
reference <- c(10, 25, 40, 55, 70)
avg_bias <- c(0.020, 0.008, -0.002, -0.018, -0.048)

# Fit linear regression
model <- lm(avg_bias ~ reference)

# Calculate linearity
slope <- coef(model)[2]
range_used <- max(reference) - min(reference)
linearity <- abs(slope) * range_used

cat("Regression equation: Bias =", round(coef(model)[1], 4), "+",
    round(slope, 5), "× Reference\n")
cat("Linearity (slope × range):", round(linearity, 4), "mm\n")
cat("As % of tolerance (±0.10):", round(linearity / 0.10 * 100, 1), "%\n")

# R-squared
cat("R² =", round(summary(model)$r.squared, 3),
    "- indicates", ifelse(summary(model)$r.squared > 0.7, "significant", "minor"),
    "linearity issue\n")
```

### Stability

**Stability** (also called drift) measures whether the measurement system's accuracy changes over time.

```{r stability-study, echo=FALSE, fig.width=11, fig.height=6}
set.seed(321)
# Simulate stability study over 30 days
days <- 1:30
reference <- 25.00

# Measurements showing some drift
measurements <- 25.00 + 0.001 * days + rnorm(30, 0, 0.015)

stability_data <- data.frame(
  Day = days,
  Measurement = measurements,
  Bias = measurements - reference
)

ggplot(stability_data, aes(x = Day, y = Bias)) +
  geom_point(color = "steelblue", size = 3) +
  geom_line(color = "steelblue", alpha = 0.5) +
  geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_hline(yintercept = c(-0.05, 0.05), linetype = "dotted", color = "orange") +
  annotate("text", x = 30, y = 0.05, label = "±5% tolerance",
           hjust = 1, vjust = -0.5, color = "orange") +
  labs(title = "Stability Study: Daily Measurements of Reference Standard",
       subtitle = "Tracking bias over 30 days to detect drift",
       x = "Day", y = "Bias from Reference (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
```

### Stability Control Chart

For ongoing stability monitoring, use a control chart:

```{r stability-control-chart, echo=TRUE}
# Stability monitoring with control chart
reference <- 25.000
measurements <- c(25.012, 25.008, 25.015, 25.018, 25.022, 25.019, 25.025,
                  25.028, 25.031, 25.026, 25.033, 25.038, 25.035, 25.041, 25.039)
days <- 1:15

# Calculate control limits (based on historical sigma)
historical_sigma <- 0.010
x_bar <- mean(measurements[1:5])  # Baseline from first 5 days
UCL <- x_bar + 3 * historical_sigma
LCL <- x_bar - 3 * historical_sigma

cat("Baseline Average:", round(x_bar, 4), "\n")
cat("UCL:", round(UCL, 4), "\n")
cat("LCL:", round(LCL, 4), "\n")

# Check for out-of-control
out_of_control <- which(measurements > UCL | measurements < LCL)
if(length(out_of_control) > 0) {
  cat("\nOut-of-control points on days:", out_of_control, "\n")
  cat("Drift detected - recalibration recommended\n")
} else {
  cat("\nNo out-of-control points - measurement system stable\n")
}
```

---

## Precision Studies: Gauge R&R

**Gauge R&R** (Repeatability and Reproducibility) is the most common MSA study. It quantifies precision variation.

### Repeatability vs. Reproducibility

```{r rr-visual, echo=FALSE, fig.width=12, fig.height=6}
set.seed(555)
n_parts <- 3
n_trials <- 5

# Operator A - consistent
op_a <- data.frame(
  Part = rep(c("Part 1", "Part 2", "Part 3"), each = n_trials),
  Trial = rep(1:n_trials, n_parts),
  Measurement = c(rnorm(n_trials, 10.02, 0.008),
                  rnorm(n_trials, 10.05, 0.008),
                  rnorm(n_trials, 10.01, 0.008)),
  Operator = "Operator A"
)

# Operator B - same equipment variation, different average
op_b <- data.frame(
  Part = rep(c("Part 1", "Part 2", "Part 3"), each = n_trials),
  Trial = rep(1:n_trials, n_parts),
  Measurement = c(rnorm(n_trials, 10.04, 0.008),
                  rnorm(n_trials, 10.07, 0.008),
                  rnorm(n_trials, 10.03, 0.008)),
  Operator = "Operator B"
)

rr_data <- rbind(op_a, op_b)

ggplot(rr_data, aes(x = Trial, y = Measurement, color = Operator, shape = Operator)) +
  geom_point(size = 3) +
  geom_line(aes(group = Operator), alpha = 0.5) +
  facet_wrap(~Part) +
  labs(title = "Repeatability and Reproducibility Illustrated",
       subtitle = "Repeatability = variation within each operator | Reproducibility = variation between operators",
       x = "Trial Number", y = "Measurement (mm)") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom"
  ) +
  annotate("segment", x = 0.5, xend = 5.5, y = 10.02, yend = 10.02,
           color = "gray50", linetype = "dashed")
```

```{r rr-definitions, echo=FALSE}
rr_defs <- data.frame(
  Component = c("Repeatability (EV)", "Reproducibility (AV)", "Gauge R&R (GRR)"),
  Also_Known_As = c("Equipment Variation, Within-operator variation",
                    "Appraiser Variation, Between-operator variation",
                    "Total measurement system variation"),
  Definition = c(
    "Variation when same operator measures same part multiple times with same gauge",
    "Variation when different operators measure the same parts",
    "Combined repeatability and reproducibility"
  ),
  Caused_By = c(
    "Gauge resolution, gauge condition, fixture, technique consistency",
    "Training differences, technique differences, interpretation",
    "All measurement system sources combined"
  )
)

kable(rr_defs, col.names = c("Component", "Also Known As", "Definition", "Caused By"),
      caption = "Gauge R&R Components") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Gauge R&R Study Design

```{r grr-design, echo=FALSE}
grr_design <- data.frame(
  Parameter = c("Number of Parts", "Number of Operators", "Number of Trials",
                "Total Measurements", "Part Selection", "Randomization"),
  Typical_Value = c("10", "3", "3", "10 × 3 × 3 = 90",
                    "Cover the full process range",
                    "Randomize measurement order"),
  Notes = c(
    "Minimum 5, 10 recommended for statistical power",
    "Minimum 2, 3 is standard for detecting operator effects",
    "Minimum 2, 3 is standard for repeatability estimation",
    "More measurements = better precision in estimates",
    "Parts should represent typical production variation",
    "Blind measurements when possible; prevents bias"
  )
)

kable(grr_design, caption = "Standard Gauge R&R Study Design Parameters") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

### Range Method (Short Form)

The Range Method is a quick approximation useful for initial screening.

```{r range-method, echo=TRUE}
# Range Method Gauge R&R Calculation
# Two operators, five parts, two trials each

# Data: Measurements by each operator (2 trials per part)
operator_a <- matrix(c(
  0.85, 0.87,  # Part 1
  0.92, 0.91,  # Part 2
  0.78, 0.80,  # Part 3
  0.95, 0.96,  # Part 4
  0.88, 0.85   # Part 5
), ncol = 2, byrow = TRUE)

operator_b <- matrix(c(
  0.86, 0.88,  # Part 1
  0.93, 0.92,  # Part 2
  0.80, 0.79,  # Part 3
  0.94, 0.97,  # Part 4
  0.87, 0.88   # Part 5
), ncol = 2, byrow = TRUE)

# Step 1: Calculate ranges for each part-operator combination
range_a <- apply(operator_a, 1, function(x) max(x) - min(x))
range_b <- apply(operator_b, 1, function(x) max(x) - min(x))

# Step 2: Average range
R_bar <- mean(c(range_a, range_b))

# Step 3: Calculate Repeatability (EV)
# d2 for 2 trials = 1.128
d2_trials <- 1.128
EV <- R_bar / d2_trials

# Step 4: Calculate part averages by operator
avg_a <- rowMeans(operator_a)
avg_b <- rowMeans(operator_b)

# Step 5: Range of operator averages
X_diff <- abs(mean(avg_a) - mean(avg_b))

# d2 for 2 operators = 1.128
d2_operators <- 1.128
n_parts <- 5
n_trials <- 2

# Step 6: Reproducibility (AV)
AV_squared <- (X_diff / d2_operators)^2 - (EV^2 / (n_parts * n_trials))
AV <- sqrt(max(0, AV_squared))

# Step 7: Gauge R&R
GRR <- sqrt(EV^2 + AV^2)

# Step 8: Express as % of tolerance
tolerance <- 0.30  # Example tolerance of ±0.15 = 0.30 total

cat("=== Range Method Gauge R&R Results ===\n\n")
cat("Average Range (R-bar):", round(R_bar, 4), "\n")
cat("Repeatability (EV):", round(EV, 4), "\n")
cat("Reproducibility (AV):", round(AV, 4), "\n")
cat("Gauge R&R (GRR):", round(GRR, 4), "\n\n")
cat("%EV (of tolerance):", round(EV / tolerance * 100 * 5.15, 1), "%\n")
cat("%AV (of tolerance):", round(AV / tolerance * 100 * 5.15, 1), "%\n")
cat("%GRR (of tolerance):", round(GRR / tolerance * 100 * 5.15, 1), "%\n")
```

### ANOVA Method (Full Study)

The ANOVA method is more accurate and provides additional information.

```{r anova-method, echo=TRUE}
# Full Gauge R&R using ANOVA method
# 10 parts, 3 operators, 3 trials

set.seed(42)

# Generate realistic GRR data
n_parts <- 10
n_operators <- 3
n_trials <- 3

# Part true values (most of the variation)
part_effects <- rnorm(n_parts, 0, 0.05)

# Operator effects (some variation)
operator_effects <- c(-0.008, 0.003, 0.005)

# Create dataset
grr_data <- expand.grid(
  Part = 1:n_parts,
  Operator = paste0("Op", 1:n_operators),
  Trial = 1:n_trials
)

# Add measurements
grr_data$Measurement <- 10 +
  part_effects[grr_data$Part] +
  operator_effects[as.numeric(factor(grr_data$Operator))] +
  rnorm(nrow(grr_data), 0, 0.006)  # Repeatability error

# Convert to factors
grr_data$Part <- factor(grr_data$Part)
grr_data$Operator <- factor(grr_data$Operator)

# Fit ANOVA model
anova_model <- aov(Measurement ~ Part + Operator + Part:Operator, data = grr_data)

# Extract variance components
anova_table <- anova(anova_model)
print(anova_table)
```

```{r anova-variance-components, echo=TRUE}
# Extract Mean Squares from ANOVA
MS_part <- anova_table["Part", "Mean Sq"]
MS_operator <- anova_table["Operator", "Mean Sq"]
MS_interaction <- anova_table["Part:Operator", "Mean Sq"]
MS_error <- anova_table["Residuals", "Mean Sq"]

# Calculate variance components
n_p <- 10  # number of parts
n_o <- 3   # number of operators
n_r <- 3   # number of trials

# Repeatability variance
var_repeatability <- MS_error

# Interaction variance
var_interaction <- max(0, (MS_interaction - MS_error) / n_r)

# Operator variance
var_operator <- max(0, (MS_operator - MS_interaction) / (n_p * n_r))

# Part variance
var_part <- max(0, (MS_part - MS_interaction) / (n_o * n_r))

# Reproducibility = Operator + Interaction
var_reproducibility <- var_operator + var_interaction

# Total Gauge R&R
var_GRR <- var_repeatability + var_reproducibility

# Total variation
var_total <- var_part + var_GRR

# Convert to standard deviations
sigma_repeatability <- sqrt(var_repeatability)
sigma_reproducibility <- sqrt(var_reproducibility)
sigma_GRR <- sqrt(var_GRR)
sigma_part <- sqrt(var_part)
sigma_total <- sqrt(var_total)

# Calculate study variation (5.15 sigma for 99% of distribution)
SV_repeatability <- 5.15 * sigma_repeatability
SV_reproducibility <- 5.15 * sigma_reproducibility
SV_GRR <- 5.15 * sigma_GRR
SV_part <- 5.15 * sigma_part
SV_total <- 5.15 * sigma_total

cat("\n=== ANOVA Gauge R&R Results ===\n\n")
cat("Variance Components:\n")
cat("  Repeatability:", round(var_repeatability, 8), "\n")
cat("  Reproducibility:", round(var_reproducibility, 8), "\n")
cat("  Part-to-Part:", round(var_part, 8), "\n")
cat("  Total:", round(var_total, 8), "\n")

cat("\nStudy Variation (5.15σ):\n")
cat("  Repeatability:", round(SV_repeatability, 5), "\n")
cat("  Reproducibility:", round(SV_reproducibility, 5), "\n")
cat("  Gauge R&R:", round(SV_GRR, 5), "\n")
cat("  Part-to-Part:", round(SV_part, 5), "\n")
cat("  Total:", round(SV_total, 5), "\n")
```

### Calculating %GRR and Acceptance Criteria

```{r grr-acceptance, echo=TRUE}
# Calculate %GRR using both methods
tolerance <- 0.30  # Total tolerance

# Method 1: % of Tolerance (%GRR_Tolerance)
pct_GRR_tol <- (SV_GRR / tolerance) * 100

# Method 2: % of Total Variation (%GRR_TV)
pct_GRR_tv <- (sigma_GRR / sigma_total) * 100

# Number of Distinct Categories (ndc)
ndc <- 1.41 * (sigma_part / sigma_GRR)

cat("=== Gauge R&R Acceptance Criteria ===\n\n")
cat("%GRR (of Tolerance):", round(pct_GRR_tol, 1), "%\n")
cat("%GRR (of Total Variation):", round(pct_GRR_tv, 1), "%\n")
cat("Number of Distinct Categories (ndc):", round(ndc, 1), "\n\n")

# Acceptance criteria
cat("AIAG Acceptance Guidelines:\n")
cat("─────────────────────────────────────\n")
if(pct_GRR_tol < 10) {
  cat("%GRR < 10%: ACCEPTABLE - Measurement system is acceptable\n")
} else if(pct_GRR_tol < 30) {
  cat("%GRR 10-30%: MARGINAL - May be acceptable based on application\n")
} else {
  cat("%GRR > 30%: UNACCEPTABLE - Measurement system needs improvement\n")
}

if(ndc >= 5) {
  cat("ndc ≥ 5: ACCEPTABLE - Adequate discrimination\n")
} else if(ndc >= 2) {
  cat("ndc 2-4: MARGINAL - Limited discrimination ability\n")
} else {
  cat("ndc < 2: UNACCEPTABLE - Cannot distinguish between parts\n")
}
```

### Gauge R&R Acceptance Criteria Summary

```{r acceptance-table, echo=FALSE}
acceptance <- data.frame(
  Criterion = c("%GRR < 10%", "%GRR 10-30%", "%GRR > 30%",
                "ndc ≥ 5", "ndc = 2-4", "ndc < 2"),
  Status = c("Acceptable", "Marginal", "Unacceptable",
             "Acceptable", "Marginal", "Unacceptable"),
  Interpretation = c(
    "Measurement system is acceptable for process control and capability",
    "May be acceptable depending on importance, cost of gauge, repair costs",
    "Measurement system is not acceptable; action required",
    "Gauge can adequately distinguish between parts",
    "Limited ability to distinguish; may be OK for simple pass/fail",
    "Gauge cannot distinguish between parts; almost useless for control"
  )
)

kable(acceptance, caption = "AIAG Gauge R&R Acceptance Guidelines") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  row_spec(c(1, 4), background = "#d4edda") %>%
  row_spec(c(2, 5), background = "#fff3cd") %>%
  row_spec(c(3, 6), background = "#f8d7da") %>%
  column_spec(1, bold = TRUE, width = "15%")
```

### Visual Analysis of Gauge R&R

```{r grr-visuals, echo=FALSE, fig.width=12, fig.height=10}
# Create comprehensive GRR visualization
par(mfrow = c(2, 2))

# Plot 1: Components of Variation
components <- c(pct_GRR_tv,
                (sigma_repeatability/sigma_total)*100,
                (sigma_reproducibility/sigma_total)*100,
                (sigma_part/sigma_total)*100)
names(components) <- c("Gauge R&R", "Repeat", "Reprod", "Part-to-Part")

grr_components <- data.frame(
  Component = factor(c("Gauge R&R", "Repeatability", "Reproducibility", "Part-to-Part"),
                     levels = c("Gauge R&R", "Repeatability", "Reproducibility", "Part-to-Part")),
  Percent = c(pct_GRR_tv,
              (sigma_repeatability/sigma_total)*100,
              (sigma_reproducibility/sigma_total)*100,
              (sigma_part/sigma_total)*100)
)

p1 <- ggplot(grr_components, aes(x = Component, y = Percent, fill = Component)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_hline(yintercept = 30, linetype = "dashed", color = "red") +
  geom_text(aes(label = paste0(round(Percent, 1), "%")), vjust = -0.5) +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60", "#f39c12"), guide = "none") +
  scale_y_continuous(limits = c(0, 100)) +
  labs(title = "Components of Variation", y = "% of Total Variation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold"))

# Plot 2: Measurement by Part
p2 <- ggplot(grr_data, aes(x = Part, y = Measurement, color = Operator)) +
  geom_point(position = position_dodge(width = 0.5), size = 2) +
  stat_summary(fun = mean, geom = "line", aes(group = Operator),
               position = position_dodge(width = 0.5)) +
  labs(title = "Measurement by Part", y = "Measurement") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "bottom")

# Plot 3: Measurement by Operator
p3 <- ggplot(grr_data, aes(x = Operator, y = Measurement)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  labs(title = "Measurement by Operator", y = "Measurement") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"))

# Plot 4: Part × Operator Interaction
interaction_data <- grr_data %>%
  group_by(Part, Operator) %>%
  summarize(Mean = mean(Measurement), .groups = "drop")

p4 <- ggplot(interaction_data, aes(x = Part, y = Mean, color = Operator, group = Operator)) +
  geom_point(size = 3) +
  geom_line() +
  labs(title = "Part × Operator Interaction", y = "Mean Measurement") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "bottom")

# Combine plots
gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 2)
```

---

## Attribute Measurement Systems

For pass/fail or categorical measurements (visual inspection, go/no-go gauges), we use **Attribute MSA** or **Attribute Agreement Analysis**.

### Kappa Statistic

The **Kappa statistic** measures agreement beyond chance:

$$\kappa = \frac{P_o - P_e}{1 - P_e}$$

Where:
- $P_o$ = Observed proportion of agreement
- $P_e$ = Expected proportion of agreement by chance

```{r kappa-interpretation, echo=FALSE}
kappa_table <- data.frame(
  Kappa = c("< 0", "0.00 - 0.20", "0.21 - 0.40", "0.41 - 0.60",
            "0.61 - 0.80", "0.81 - 1.00"),
  Interpretation = c("Less than chance agreement", "Slight agreement",
                     "Fair agreement", "Moderate agreement",
                     "Substantial agreement", "Almost perfect agreement"),
  Action = c("Major issues - do not use", "Major improvement needed",
             "Significant improvement needed", "Some improvement needed",
             "Acceptable for most applications", "Excellent - acceptable")
)

kable(kappa_table, caption = "Kappa Statistic Interpretation Guide") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  row_spec(5:6, background = "#d4edda") %>%
  row_spec(3:4, background = "#fff3cd") %>%
  row_spec(1:2, background = "#f8d7da")
```

### Attribute Agreement Study Example

```{r attribute-msa, echo=TRUE}
# Attribute Agreement Analysis
# 3 operators inspect 30 samples, 2 trials each
# Reference standard (known good/bad) available

set.seed(123)
n_samples <- 30
n_operators <- 3
n_trials <- 2

# Reference classification (10 bad, 20 good)
reference <- c(rep("Reject", 10), rep("Accept", 20))

# Simulate operator decisions (some disagreement)
simulate_decision <- function(ref, accuracy) {
  sapply(ref, function(r) {
    if(runif(1) < accuracy) r else ifelse(r == "Accept", "Reject", "Accept")
  })
}

# Operators with different accuracy levels
op1_t1 <- simulate_decision(reference, 0.92)
op1_t2 <- simulate_decision(reference, 0.92)
op2_t1 <- simulate_decision(reference, 0.88)
op2_t2 <- simulate_decision(reference, 0.88)
op3_t1 <- simulate_decision(reference, 0.95)
op3_t2 <- simulate_decision(reference, 0.95)

# Calculate agreement metrics

# 1. Within-operator agreement (repeatability)
within_op1 <- mean(op1_t1 == op1_t2)
within_op2 <- mean(op2_t1 == op2_t2)
within_op3 <- mean(op3_t1 == op3_t2)

# 2. Each operator vs. reference
op1_vs_ref <- mean(op1_t1 == reference & op1_t2 == reference)
op2_vs_ref <- mean(op2_t1 == reference & op2_t2 == reference)
op3_vs_ref <- mean(op3_t1 == reference & op3_t2 == reference)

# 3. All operators agree (both trials)
all_agree_t1 <- mean(op1_t1 == op2_t1 & op2_t1 == op3_t1)
all_agree_both <- mean(op1_t1 == op1_t2 & op1_t1 == op2_t1 & op2_t1 == op2_t2 &
                        op2_t1 == op3_t1 & op3_t1 == op3_t2)

cat("=== Attribute Agreement Analysis ===\n\n")
cat("Within-Operator Agreement (Repeatability):\n")
cat("  Operator 1:", round(within_op1 * 100, 1), "%\n")
cat("  Operator 2:", round(within_op2 * 100, 1), "%\n")
cat("  Operator 3:", round(within_op3 * 100, 1), "%\n\n")

cat("Each Operator vs. Reference (both trials correct):\n")
cat("  Operator 1:", round(op1_vs_ref * 100, 1), "%\n")
cat("  Operator 2:", round(op2_vs_ref * 100, 1), "%\n")
cat("  Operator 3:", round(op3_vs_ref * 100, 1), "%\n\n")

cat("All Operators Agreement:\n")
cat("  All agree (one trial):", round(all_agree_t1 * 100, 1), "%\n")
cat("  All agree (both trials):", round(all_agree_both * 100, 1), "%\n")
```

### Calculating Kappa

```{r kappa-calculation, echo=TRUE}
# Calculate Kappa for Operator 1 vs Reference
# Create confusion matrix for trial 1
actual <- factor(reference, levels = c("Accept", "Reject"))
predicted <- factor(op1_t1, levels = c("Accept", "Reject"))

confusion <- table(Predicted = predicted, Actual = actual)
print(confusion)

# Calculate proportions
n <- sum(confusion)
p_o <- sum(diag(confusion)) / n  # Observed agreement

# Expected agreement by chance
p_accept <- sum(confusion[1,]) / n * sum(confusion[,1]) / n
p_reject <- sum(confusion[2,]) / n * sum(confusion[,2]) / n
p_e <- p_accept + p_reject

# Kappa
kappa <- (p_o - p_e) / (1 - p_e)

cat("\nKappa Calculation (Operator 1 vs Reference):\n")
cat("Observed agreement (Po):", round(p_o, 3), "\n")
cat("Expected agreement (Pe):", round(p_e, 3), "\n")
cat("Kappa:", round(kappa, 3), "\n")

# Interpretation
if(kappa >= 0.81) {
  cat("Interpretation: Almost perfect agreement\n")
} else if(kappa >= 0.61) {
  cat("Interpretation: Substantial agreement\n")
} else if(kappa >= 0.41) {
  cat("Interpretation: Moderate agreement\n")
} else {
  cat("Interpretation: Fair or less agreement - needs improvement\n")
}
```

### Attribute MSA Best Practices

```{r attribute-best-practices, echo=FALSE}
attr_practices <- data.frame(
  Practice = c("Use boundary samples", "Include clear accept/reject",
               "Blind testing", "Multiple trials", "Reference standard",
               "Adequate sample size"),
  Description = c(
    "Include samples at the accept/reject boundary where decisions are hardest",
    "Include obvious accept and obvious reject samples as controls",
    "Operators should not know which samples are repeated or reference",
    "Minimum 2-3 trials per operator to assess within-operator repeatability",
    "Must have known correct answers to assess accuracy, not just agreement",
    "Minimum 30-50 samples recommended for statistical validity"
  )
)

kable(attr_practices, caption = "Best Practices for Attribute MSA Studies") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "25%")
```

---

## Measurement System Resolution

**Resolution** (also called discrimination) is the smallest increment a measurement system can detect.

### Rule of Ten

The **Rule of Ten** states that measurement resolution should be at least 1/10 of:
- The tolerance, OR
- The process variation (6σ)

Whichever is smaller.

```{r resolution-check, echo=TRUE}
# Resolution adequacy check
tolerance <- 0.100  # mm total tolerance
process_6sigma <- 0.080  # 6 sigma of process
gauge_resolution <- 0.010  # mm (smallest increment)

# Check against tolerance
ratio_tolerance <- tolerance / gauge_resolution
# Check against process
ratio_process <- process_6sigma / gauge_resolution

cat("=== Resolution Adequacy Check ===\n\n")
cat("Tolerance:", tolerance, "mm\n")
cat("Process 6σ:", process_6sigma, "mm\n")
cat("Gauge Resolution:", gauge_resolution, "mm\n\n")

cat("Tolerance / Resolution:", ratio_tolerance, ":1")
if(ratio_tolerance >= 10) cat(" - ADEQUATE\n") else cat(" - INADEQUATE\n")

cat("Process 6σ / Resolution:", ratio_process, ":1")
if(ratio_process >= 10) cat(" - ADEQUATE\n") else cat(" - INADEQUATE\n")
```

### Resolution Impact on Gauge R&R

```{r resolution-grr-impact, echo=FALSE, fig.width=11, fig.height=6}
# Simulate effect of resolution on apparent GRR
set.seed(42)
true_values <- rnorm(100, 50, 0.03)

# Fine resolution (0.001)
fine_resolution <- round(true_values + rnorm(100, 0, 0.005), 3)

# Coarse resolution (0.01)
coarse_resolution <- round(true_values + rnorm(100, 0, 0.005), 2)

# Very coarse resolution (0.1)
very_coarse <- round(true_values + rnorm(100, 0, 0.005), 1)

resolution_data <- data.frame(
  Value = c(fine_resolution, coarse_resolution, very_coarse),
  Resolution = rep(c("0.001 mm (Fine)", "0.01 mm (Coarse)", "0.1 mm (Very Coarse)"),
                   each = 100)
)

resolution_data$Resolution <- factor(resolution_data$Resolution,
                                      levels = c("0.001 mm (Fine)",
                                                "0.01 mm (Coarse)",
                                                "0.1 mm (Very Coarse)"))

ggplot(resolution_data, aes(x = Value)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  facet_wrap(~Resolution, ncol = 1, scales = "free_y") +
  labs(title = "Effect of Gauge Resolution on Measurement Distribution",
       subtitle = "Same parts measured with different resolution gauges",
       x = "Measured Value (mm)", y = "Count") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  )
```

---

## Common Sources of Measurement Error

```{r error-sources, echo=FALSE, fig.width=12, fig.height=8}
error_sources <- data.frame(
  Category = c("Equipment", "Equipment", "Equipment", "Equipment",
               "Appraiser", "Appraiser", "Appraiser",
               "Method", "Method", "Method",
               "Environment", "Environment",
               "Part", "Part"),
  Source = c("Calibration drift", "Worn components", "Poor resolution", "Fixture issues",
             "Training gaps", "Technique variation", "Fatigue/attention",
             "Unclear procedures", "Inconsistent setup", "Wrong reference point",
             "Temperature effects", "Contamination/cleanliness",
             "Surface finish", "Part flexibility"),
  Impact = c("Bias", "Repeatability", "Resolution/ndc", "Repeatability",
             "Reproducibility", "Repeatability & Reproducibility", "Repeatability",
             "Reproducibility", "Repeatability", "Bias",
             "Bias & Repeatability", "Repeatability",
             "Repeatability", "Repeatability")
)

ggplot(error_sources, aes(x = Category, y = 1, fill = Impact)) + # Added y = 1
  geom_col() + # Changed from geom_bar to geom_col
  geom_text(aes(label = Source), 
            position = position_stack(vjust = 0.5), 
            size = 3, color = "white") +
  scale_fill_manual(values = c("Bias" = "#e74c3c",
                               "Repeatability" = "#3498db",
                               "Reproducibility" = "#27ae60",
                               "Resolution/ndc" = "#f39c12",
                               "Repeatability & Reproducibility" = "#9b59b6",
                               "Bias & Repeatability" = "#1abc9c")) +
  coord_flip() +
  labs(title = "Common Sources of Measurement Error by Category",
       subtitle = "Classified by primary impact on measurement system",
       x = "", y = "Number of Error Sources") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom"
  )
```

```{r error-table, echo=FALSE}
improvement_actions <- data.frame(
  Issue = c("High Repeatability (EV)", "High Reproducibility (AV)",
            "Significant Bias", "Poor Linearity", "Drift/Stability Issues",
            "Low ndc"),
  Likely_Causes = c(
    "Gauge condition, fixture, resolution, part variation during measurement",
    "Training, technique, procedure clarity",
    "Calibration, master accuracy, technique",
    "Gauge mechanism, calibration across range",
    "Environmental effects, gauge wear, master deterioration",
    "Resolution, excessive gauge variation relative to part variation"
  ),
  Improvement_Actions = c(
    "Maintain gauge, improve fixture, upgrade resolution, reduce part handling",
    "Standardize technique, retrain, improve written procedures",
    "Recalibrate, verify master, standardize technique",
    "Repair/replace gauge, multi-point calibration",
    "Environmental control, maintenance, replace masters",
    "Higher resolution gauge, reduce gauge variation"
  )
)

kable(improvement_actions,
      col.names = c("Issue Identified", "Likely Causes", "Improvement Actions"),
      caption = "MSA Issues and Improvement Actions") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

---

## MSA and SPC Relationship

Poor measurement systems directly impact SPC effectiveness.

### Effect on Control Charts

```{r msa-spc-effect, echo=FALSE, fig.width=12, fig.height=8}
set.seed(42)
n <- 50

# True process (stable, in control)
true_process <- rnorm(n, 100, 2)

# Good measurement system (low measurement error)
good_measurement <- true_process + rnorm(n, 0, 0.5)

# Poor measurement system (high measurement error)
poor_measurement <- true_process + rnorm(n, 0, 3)

# Control limits based on good data
mean_good <- mean(good_measurement[1:25])
sigma_good <- sd(good_measurement[1:25])
UCL_good <- mean_good + 3 * sigma_good
LCL_good <- mean_good - 3 * sigma_good

mean_poor <- mean(poor_measurement[1:25])
sigma_poor <- sd(poor_measurement[1:25])
UCL_poor <- mean_poor + 3 * sigma_poor
LCL_poor <- mean_poor - 3 * sigma_poor

chart_data <- data.frame(
  Sample = rep(1:n, 2),
  Value = c(good_measurement, poor_measurement),
  System = rep(c("Good MSA (%GRR = 10%)", "Poor MSA (%GRR = 60%)"), each = n)
)

limits_data <- data.frame(
  System = c("Good MSA (%GRR = 10%)", "Poor MSA (%GRR = 60%)"),
  Mean = c(mean_good, mean_poor),
  UCL = c(UCL_good, UCL_poor),
  LCL = c(LCL_good, LCL_poor)
)

ggplot(chart_data, aes(x = Sample, y = Value)) +
  geom_line(color = "steelblue") +
  geom_point(color = "steelblue", size = 2) +
  geom_hline(data = limits_data, aes(yintercept = Mean), color = "darkgreen") +
  geom_hline(data = limits_data, aes(yintercept = UCL), color = "red", linetype = "dashed") +
  geom_hline(data = limits_data, aes(yintercept = LCL), color = "red", linetype = "dashed") +
  facet_wrap(~System, ncol = 1, scales = "free_y") +
  labs(title = "Impact of Measurement System Quality on Control Charts",
       subtitle = "Same stable process measured with different gauge quality",
       x = "Sample Number", y = "Measured Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold", size = 11)
  )
```

### Effect on Capability Studies

```{r msa-capability-effect, echo=TRUE}
# True process parameters
true_mean <- 100
true_sigma <- 2.0
USL <- 106
LSL <- 94
tolerance <- USL - LSL

# True capability
true_Cp <- tolerance / (6 * true_sigma)
true_Cpk <- min((USL - true_mean), (true_mean - LSL)) / (3 * true_sigma)

cat("=== True Process Capability ===\n")
cat("True σ:", true_sigma, "\n")
cat("True Cp:", round(true_Cp, 2), "\n")
cat("True Cpk:", round(true_Cpk, 2), "\n\n")

# With good measurement system (10% GRR)
grr_good <- 0.10 * tolerance / 5.15
observed_sigma_good <- sqrt(true_sigma^2 + grr_good^2)
observed_Cp_good <- tolerance / (6 * observed_sigma_good)
observed_Cpk_good <- min((USL - true_mean), (true_mean - LSL)) / (3 * observed_sigma_good)

cat("=== With Good MSA (10% GRR) ===\n")
cat("Observed σ:", round(observed_sigma_good, 3), "\n")
cat("Observed Cp:", round(observed_Cp_good, 2), "\n")
cat("Observed Cpk:", round(observed_Cpk_good, 2), "\n\n")

# With poor measurement system (50% GRR)
grr_poor <- 0.50 * tolerance / 5.15
observed_sigma_poor <- sqrt(true_sigma^2 + grr_poor^2)
observed_Cp_poor <- tolerance / (6 * observed_sigma_poor)
observed_Cpk_poor <- min((USL - true_mean), (true_mean - LSL)) / (3 * observed_sigma_poor)

cat("=== With Poor MSA (50% GRR) ===\n")
cat("Observed σ:", round(observed_sigma_poor, 3), "\n")
cat("Observed Cp:", round(observed_Cp_poor, 2), "\n")
cat("Observed Cpk:", round(observed_Cpk_poor, 2), "\n\n")

cat("Poor MSA makes a capable process (Cpk=1.0) appear incapable (Cpk=",
    round(observed_Cpk_poor, 2), ")\n")
```

---

## Conducting an MSA Study: Step-by-Step

```{r msa-flowchart, echo=FALSE, fig.width=12, fig.height=10}
steps <- data.frame(
  step = 1:10,
  name = c("1. Plan Study", "2. Select Parts", "3. Identify Appraisers",
           "4. Calibrate Gauge", "5. Randomize Order", "6. Conduct Measurements",
           "7. Analyze Data", "8. Interpret Results", "9. Take Action", "10. Document"),
  description = c(
    "Define measurement, tolerance, study type (variable/attribute)",
    "Select 10 parts spanning process range",
    "Select 2-3 operators who normally use gauge",
    "Verify gauge is calibrated and in good condition",
    "Randomize measurement order to prevent bias",
    "Each operator measures each part 2-3 times (blind)",
    "Calculate EV, AV, GRR, %GRR, ndc",
    "Compare to acceptance criteria",
    "If unacceptable, identify root cause and improve",
    "Record results in quality system"
  ),
  x = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
  y = c(5, 4, 3, 2, 1, 5, 4, 3, 2, 1)
)

ggplot(steps, aes(x = x, y = y)) +
  geom_tile(aes(fill = step), width = 0.9, height = 0.8, color = "white", size = 1) +
  geom_text(aes(label = name), fontface = "bold", size = 3.5, color = "white",
            vjust = -0.3) +
  geom_text(aes(label = description), size = 2.8, color = "white",
            vjust = 1.2) +
  scale_fill_gradient(low = "#3498db", high = "#2c3e50", guide = "none") +
  # Add arrows between columns
  annotate("segment", x = 1.5, xend = 1.6, y = 3, yend = 3,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.5) +
  coord_cartesian(xlim = c(0.4, 2.6)) +
  labs(title = "Gauge R&R Study Process Flow",
       subtitle = "Steps for conducting a complete MSA study") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Data Collection Sheet Template

```{r data-collection-template, echo=FALSE}
template <- data.frame(
  Part = rep(1:5, each = 6),
  Operator = rep(c("A", "A", "B", "B", "C", "C"), 5),
  Trial = rep(c(1, 2), 15),
  Measurement = rep("___", 30)
)

# Show first 12 rows as example
kable(head(template, 12),
      caption = "Gauge R&R Data Collection Sheet (Partial Example)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  column_spec(1:4, width = "20%")
```

---

## Video Resources

### Understanding Gauge R&R

<iframe width="560" height="315" src="https://www.youtube.com/embed/CkLEmiKFnTw" title="Gauge R&R Explained" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### MSA in Practice

<iframe width="560" height="315" src="https://www.youtube.com/embed/N1mK_6Hxk48" title="Measurement System Analysis" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Summary

Measurement Systems Analysis ensures that your data can be trusted for process control and decision-making:

1. **Before SPC, do MSA** - Garbage in, garbage out; verify measurement quality first
2. **Accuracy components** - Bias, linearity, and stability affect location (average)
3. **Precision components** - Repeatability (within operator) and reproducibility (between operators)
4. **Key metrics** - %GRR < 30% and ndc ≥ 5 for acceptable systems
5. **Resolution matters** - 10:1 ratio vs. tolerance or process variation
6. **Attribute MSA** - Use Kappa for pass/fail decisions
7. **Continuous improvement** - Regular verification and recertification

> "The measurement system is part of the process. Fix the measurement system before trying to fix the process."

---

## Review Questions

<details><summary>**Question 1**: A gauge R&R study yields %GRR = 45% and ndc = 2. What does this mean and what should be done?</summary>

**Answer:**

This measurement system is **unacceptable**:

- **%GRR = 45%** exceeds the 30% maximum threshold, meaning 45% of the observed variation is due to the measurement system, not the parts
- **ndc = 2** indicates the gauge can only distinguish between 2 categories of parts, which is insufficient for process control (minimum 5 required)

**Actions required:**
1. Investigate root causes of high variation:
   - Check gauge calibration and condition
   - Evaluate operator technique and training
   - Review measurement procedure for ambiguity
   - Assess fixture and part positioning
   - Check gauge resolution adequacy

2. Prioritize improvement efforts:
   - If repeatability (EV) is high: Focus on gauge condition, fixture, technique consistency
   - If reproducibility (AV) is high: Focus on training, procedure clarity, technique standardization

3. Re-run study after improvements

4. If improvements insufficient, consider upgrading to a higher-capability gauge

5. Until resolved, this gauge should not be used for process control or capability studies
</details>

<details><summary>**Question 2**: What is the difference between repeatability and reproducibility? Give an example of each source of error.</summary>

**Answer:**

**Repeatability (Equipment Variation - EV)**:
- Variation when the **same operator** measures the **same part** multiple times with the **same gauge**
- Also called "within-operator" variation
- Represents the inherent precision of the gauge and measurement technique

*Examples of repeatability errors:*
- Gauge resolution limitations
- Gauge mechanism play/backlash
- Inconsistent part positioning in fixture
- Variations in technique even by same operator
- Environmental micro-changes during measurement

**Reproducibility (Appraiser Variation - AV)**:
- Variation when **different operators** measure the **same parts**
- Also called "between-operator" variation
- Represents differences in how operators apply the measurement method

*Examples of reproducibility errors:*
- Different technique between operators (pressure applied, angle, etc.)
- Different interpretation of measurement procedure
- Different reading of analog scales
- Training differences
- Physical differences (eyesight, hand steadiness)
</details>

<details><summary>**Question 3**: Calculate the bias and determine if it is acceptable. Reference value = 25.000 mm, Tolerance = ±0.050 mm, Measured values: 25.012, 25.015, 25.008, 25.011, 25.014, 25.009, 25.013, 25.010, 25.012, 25.011</summary>

**Answer:**

```{r q3-answer, echo=TRUE}
reference <- 25.000
tolerance_total <- 0.100  # ±0.050 = 0.100 total
measurements <- c(25.012, 25.015, 25.008, 25.011, 25.014,
                  25.009, 25.013, 25.010, 25.012, 25.011)

# Calculate bias
mean_measured <- mean(measurements)
bias <- mean_measured - reference

cat("Reference value:", reference, "mm\n")
cat("Mean measured:", round(mean_measured, 4), "mm\n")
cat("Bias:", round(bias, 4), "mm\n\n")

# Express as % of tolerance
bias_pct <- abs(bias) / tolerance_total * 100
cat("Bias as % of tolerance:", round(bias_pct, 1), "%\n")

# T-test for significance
t_result <- t.test(measurements, mu = reference)
cat("T-test p-value:", round(t_result$p.value, 6), "\n\n")

# Acceptability
cat("Acceptability Assessment:\n")
if(bias_pct < 10) {
  cat("- Bias < 10% of tolerance: ACCEPTABLE\n")
} else if(bias_pct < 25) {
  cat("- Bias 10-25% of tolerance: MARGINAL\n")
} else {
  cat("- Bias > 25% of tolerance: UNACCEPTABLE\n")
}

if(t_result$p.value < 0.05) {
  cat("- Bias is statistically significant (p < 0.05)\n")
  cat("- Consider recalibration or technique adjustment\n")
}
```

The bias of 0.0115 mm (11.5% of tolerance) is **marginally acceptable** and statistically significant. Recalibration should be considered.
</details>

<details><summary>**Question 4**: Why is it important to conduct MSA before capability studies (Cp, Cpk)?</summary>

**Answer:**

MSA must precede capability studies because measurement error directly inflates observed variation:

**Mathematical Relationship:**
$$\sigma^2_{observed} = \sigma^2_{process} + \sigma^2_{measurement}$$

**Impacts on Capability:**

1. **Understated Cp/Cpk**: Observed sigma is always larger than true process sigma, so calculated capability will be lower than actual capability

2. **False Alarms**: A capable process may appear incapable due to measurement noise, leading to unnecessary process adjustments or investment

3. **Missed Issues**: High measurement variation masks actual process variation; you can't see problems through the "fog" of gauge error

4. **Bad Decisions**: Incorrect capability data leads to:
   - Wrong process acceptance decisions
   - Inappropriate control limits
   - Misguided improvement investments
   - Customer quality issues

**Example:**
- True process: Cpk = 1.5 (very capable)
- With 50% GRR: Observed Cpk ≈ 0.9 (appears incapable)
- Result: Unnecessary process "improvement" efforts

**Rule of Thumb**: If %GRR > 30%, any capability study is essentially meaningless because too much of the observed variation is measurement noise, not real process variation.
</details>

<details><summary>**Question 5**: A visual inspection has the following results: Kappa vs. reference = 0.72, within-operator agreement = 88%, between-operator agreement = 75%. Evaluate this attribute measurement system.</summary>

**Answer:**

**Results Interpretation:**

1. **Kappa vs. Reference = 0.72**
   - Falls in "Substantial agreement" range (0.61-0.80)
   - Operators are correctly classifying parts most of the time
   - Acceptable for many applications, but improvement possible

2. **Within-Operator Agreement = 88%**
   - Operators are fairly consistent with themselves
   - 12% of the time, same operator gives different result on same part
   - Should target >90% for critical inspections

3. **Between-Operator Agreement = 75%**
   - Operators disagree on 25% of parts
   - This is a significant reproducibility issue
   - Major source of inconsistency in product quality

**Assessment: MARGINAL - Improvement Needed**

**Recommended Actions:**

1. **Standardize criteria**: Create clear visual standards with boundary samples
   - Photos of accept/reject borderline cases
   - Written descriptions of defect criteria

2. **Training**:
   - Calibration session with all operators and reference samples
   - Identify operators with lower agreement for targeted training

3. **Improve conditions**:
   - Check lighting adequacy and consistency
   - Ensure proper viewing distance and angle
   - Reduce fatigue with appropriate break schedules

4. **Consider automation**: For critical inspections, automated vision systems may provide better consistency

5. **Re-study after improvements** to verify effectiveness
</details>

<details><summary>**Question 6**: What is the "Rule of Ten" for gauge resolution, and how would you apply it?</summary>

**Answer:**

**The Rule of Ten:**
The gauge resolution should be at least **1/10 of the tolerance** or **1/10 of the process variation (6σ)**, whichever is smaller.

$$\text{Resolution} \leq \frac{\min(\text{Tolerance}, 6\sigma)}{10}$$

**Application Example:**

Given:
- Part tolerance: ±0.05 mm (total = 0.10 mm)
- Process 6σ: 0.08 mm
- Available gauges: 0.01 mm resolution, 0.001 mm resolution

**Calculation:**
```
Required resolution ≤ min(0.10, 0.08) / 10
Required resolution ≤ 0.08 / 10
Required resolution ≤ 0.008 mm
```

**Assessment:**
- 0.01 mm gauge: 0.01 > 0.008 → **INADEQUATE**
- 0.001 mm gauge: 0.001 < 0.008 → **ADEQUATE**

**Why It Matters:**
1. If resolution is too coarse, gauge cannot detect small part differences
2. Results in low ndc (number of distinct categories)
3. Control charts will show "stair-step" patterns
4. Capability studies will be inaccurate

**Practical Tips:**
- For SPC applications, 10:1 is minimum; 20:1 is preferred
- For capability studies, 10:1 is acceptable
- For simple pass/fail gauging, 5:1 may be acceptable
</details>

<details><summary>**Question 7**: Given the following ANOVA table from a Gauge R&R study, calculate the variance components and %GRR.</summary>

| Source | DF | SS | MS |
|--------|-----|------|-------|
| Part | 9 | 0.2850 | 0.03167 |
| Operator | 2 | 0.0025 | 0.00125 |
| Part×Operator | 18 | 0.0090 | 0.00050 |
| Repeatability | 60 | 0.0180 | 0.00030 |
| Total | 89 | 0.3145 | |

Study design: 10 parts, 3 operators, 3 trials

**Answer:**

```{r q7-answer, echo=TRUE}
# Given values from ANOVA table
MS_part <- 0.03167
MS_operator <- 0.00125
MS_interaction <- 0.00050
MS_error <- 0.00030

n_parts <- 10
n_operators <- 3
n_trials <- 3

# Variance components
var_repeatability <- MS_error
cat("Var(Repeatability) =", var_repeatability, "\n")

var_interaction <- max(0, (MS_interaction - MS_error) / n_trials)
cat("Var(Interaction) =", round(var_interaction, 6), "\n")

var_operator <- max(0, (MS_operator - MS_interaction) / (n_parts * n_trials))
cat("Var(Operator) =", round(var_operator, 6), "\n")

var_part <- max(0, (MS_part - MS_interaction) / (n_operators * n_trials))
cat("Var(Part) =", round(var_part, 6), "\n\n")

# Reproducibility = Operator + Interaction
var_reproducibility <- var_operator + var_interaction
cat("Var(Reproducibility) =", round(var_reproducibility, 6), "\n")

# Total Gauge R&R
var_GRR <- var_repeatability + var_reproducibility
cat("Var(GRR) =", round(var_GRR, 6), "\n")

# Total variation
var_total <- var_part + var_GRR
cat("Var(Total) =", round(var_total, 6), "\n\n")

# Calculate %GRR (of total variation)
sigma_GRR <- sqrt(var_GRR)
sigma_total <- sqrt(var_total)
pct_GRR <- (sigma_GRR / sigma_total) * 100

cat("%GRR (of Total Variation) =", round(pct_GRR, 1), "%\n\n")

# ndc
sigma_part <- sqrt(var_part)
ndc <- 1.41 * (sigma_part / sigma_GRR)
cat("ndc =", round(ndc, 1), "\n\n")

if(pct_GRR < 10) {
  cat("Assessment: ACCEPTABLE (< 10%)\n")
} else if(pct_GRR < 30) {
  cat("Assessment: MARGINAL (10-30%)\n")
} else {
  cat("Assessment: UNACCEPTABLE (> 30%)\n")
}
```
</details>

<details><summary>**Question 8**: What actions would you take if a Gauge R&R study showed high repeatability (EV) but low reproducibility (AV)?</summary>

**Answer:**

When **repeatability is high** (main contributor to GRR) but **reproducibility is low**, the measurement variation is coming from the gauge/equipment/technique rather than differences between operators.

**Root Cause Investigation - Focus Areas:**

1. **Gauge Condition**
   - Worn measuring surfaces or contacts
   - Loose components or mechanism play
   - Damaged or dirty probe/sensor

2. **Gauge Resolution**
   - Resolution may be inadequate for the tolerance
   - Check 10:1 rule compliance

3. **Fixture/Fixturing**
   - Part not held consistently
   - Fixture wear or damage
   - Part not seating properly

4. **Measurement Technique**
   - Inconsistent contact force
   - Varying measurement location on part
   - Speed of measurement varies

5. **Part Characteristics**
   - Part surface finish affecting readings
   - Part flexibility/deflection during measurement
   - Part temperature variation

6. **Environment**
   - Vibration affecting readings
   - Temperature instability
   - Contamination

**Improvement Actions:**

| Priority | Action |
|----------|--------|
| 1 | Verify gauge calibration and condition; repair/replace if needed |
| 2 | Check and improve fixture; ensure consistent part positioning |
| 3 | Evaluate and potentially upgrade gauge resolution |
| 4 | Standardize technique (force, speed, location) |
| 5 | Control environmental factors |
| 6 | Re-run study to verify improvement |

**Note:** Low AV in this case is actually good - it means operators are consistent with each other. The problem is the measurement equipment itself.
</details>

---

## References

1. AIAG. (2010). *Measurement Systems Analysis Reference Manual* (4th ed.). Automotive Industry Action Group.

2. Wheeler, D.J. (2006). *EMP III: Evaluating the Measurement Process* (3rd ed.). SPC Press.

3. Montgomery, D.C. (2019). *Introduction to Statistical Quality Control* (8th ed.). Wiley.

4. Burdick, R.K., Borror, C.M., & Montgomery, D.C. (2005). *Design and Analysis of Gauge R&R Studies*. SIAM.

5. ASTM E2782-17. *Standard Guide for Measurement Systems Analysis*.

6. ISO 22514-7:2021. *Statistical Methods in Process Management - Capability and Performance - Part 7: Capability of Measurement Processes*.

7. Wheeler, D.J., & Lyday, R.W. (1989). *Evaluating the Measurement Process* (2nd ed.). SPC Press.

8. Minitab. (2021). *Gage R&R Study (Crossed)*. Minitab Support Documentation.

9. JCGM 100:2008. *Evaluation of Measurement Data - Guide to the Expression of Uncertainty in Measurement* (GUM).

10. Dietrich, E., & Schulze, A. (2011). *Statistical Procedures for Machine and Process Qualification* (6th ed.). Hanser.

<!--chapter:end:12-MSA.Rmd-->

# Industrial Automation Fundamentals

```{r setup-ch13, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

After completing this chapter, you will be able to:

1. Define industrial automation and explain its role in modern manufacturing
2. Distinguish between fixed, programmable, and flexible automation
3. Describe the architecture and function of Programmable Logic Controllers (PLCs)
4. Identify common industrial sensors and their applications
5. Explain motor control fundamentals including VFDs and servo systems
6. Understand industrial communication protocols and networking
7. Describe the role of HMI and SCADA in process monitoring
8. Apply safety principles to automated systems
9. Explain Industry 4.0 concepts and the Industrial Internet of Things (IIoT)

---

## Introduction to Industrial Automation

**Industrial automation** is the use of control systems, machinery, and information technologies to handle processes and machinery in an industry, replacing human intervention where possible to increase efficiency, quality, and safety.

### Why Automate?

```{r automation-benefits, echo=FALSE, fig.width=12, fig.height=7}
benefits <- data.frame(
  Category = c("Productivity", "Quality", "Safety", "Cost", "Flexibility", "Data"),
  Benefit = c("Increased Output", "Consistent Quality", "Reduced Risk",
              "Lower Operating Cost", "Quick Changeover", "Real-time Information"),
  Description = c(
    "24/7 operation, faster cycle times, higher throughput",
    "Repeatable precision, reduced variation, fewer defects",
    "Remove workers from hazardous tasks, safety interlocks",
    "Reduced labor, less scrap, energy optimization",
    "Programmable systems adapt to product changes",
    "Process monitoring, data collection, analytics"
  ),
  Impact = c(85, 75, 90, 70, 65, 80)
)

ggplot(benefits, aes(x = reorder(Category, Impact), y = Impact, fill = Category)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = Benefit), hjust = -0.1, size = 3.5, fontface = "bold") +
  coord_flip() +
  scale_fill_manual(values = c("#3498db", "#27ae60", "#e74c3c",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  scale_y_continuous(limits = c(0, 120)) +
  labs(title = "Benefits of Industrial Automation",
       subtitle = "Key drivers for automation investment",
       x = "", y = "Relative Impact Score") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 11, face = "bold")
  )
```

### Automation in Key Industries

```{r industry-applications, echo=FALSE}
industry_apps <- data.frame(
  Industry = c("Automotive", "Automotive", "Automotive",
               "Food & Beverage", "Food & Beverage", "Food & Beverage",
               "Aerospace/Defense", "Aerospace/Defense", "Aerospace/Defense"),
  Application = c("Robotic welding and assembly", "Automated paint systems", "Vision inspection",
                  "Filling and packaging lines", "Pasteurization control", "Sorting and grading",
                  "CNC precision machining", "Automated testing systems", "Clean room automation"),
  Technology = c("6-axis robots, PLCs", "Conveyors, spray robots", "Machine vision, AI",
                 "Servo drives, sensors", "PLCs, temperature control", "Vision systems, conveyors",
                 "CNC, CMM integration", "Automated test equipment", "Robotics, HEPA systems"),
  Benefit = c("Consistent weld quality, high speed", "Uniform coating, reduced VOC",
              "100% inspection, defect detection",
              "High speed, accurate fill weights", "Food safety, traceability",
              "Quality sorting, reduced labor",
              "Tight tolerances, repeatability", "Comprehensive testing, documentation",
              "Contamination control, precision")
)

kable(industry_apps, caption = "Automation Applications by Industry") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%") %>%
  pack_rows("Automotive", 1, 3, background = "#ebf5fb") %>%
  pack_rows("Food & Beverage", 4, 6, background = "#eafaf1") %>%
  pack_rows("Aerospace/Defense", 7, 9, background = "#fef9e7")
```

---

## Types of Automation

Industrial automation systems can be classified based on their flexibility and programming capability.

### Automation Classification

```{r automation-types, echo=FALSE, fig.width=12, fig.height=8}
auto_types <- data.frame(
  Type = c("Fixed\nAutomation", "Programmable\nAutomation", "Flexible\nAutomation"),
  x = c(1, 2, 3),
  Volume = c(95, 60, 40),
  Flexibility = c(10, 50, 90),
  Investment = c(90, 60, 85)
)

auto_long <- auto_types %>%
  pivot_longer(cols = c(Volume, Flexibility, Investment),
               names_to = "Metric", values_to = "Value")

ggplot(auto_long, aes(x = Type, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_text(aes(label = Value), position = position_dodge(width = 0.7),
            vjust = -0.5, size = 3) +
  scale_fill_manual(values = c("#3498db", "#27ae60", "#e74c3c"),
                    labels = c("Flexibility", "Initial Investment", "Production Volume")) +
  labs(title = "Comparison of Automation Types",
       subtitle = "Trade-offs between volume, flexibility, and investment",
       x = "", y = "Relative Score (0-100)", fill = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    axis.text.x = element_text(size = 11, face = "bold")
  )
```

```{r automation-types-table, echo=FALSE}
types_table <- data.frame(
  Characteristic = c("Definition", "Product Variety", "Production Volume",
                     "Changeover", "Initial Investment", "Unit Cost",
                     "Typical Equipment", "Best For"),
  Fixed = c(
    "Hard-wired, dedicated equipment for single product",
    "Single product or very similar variants",
    "Very high (millions of units)",
    "Difficult, expensive, time-consuming",
    "Very high",
    "Very low per unit",
    "Transfer lines, dedicated assembly machines",
    "Automotive components, fasteners, bottles"
  ),
  Programmable = c(
    "Equipment can be reprogrammed for different products",
    "Batches of different products",
    "Medium to high",
    "Requires reprogramming and setup; hours to days",
    "High",
    "Medium",
    "CNC machines, PLCs, industrial robots",
    "Batch manufacturing, job shops"
  ),
  Flexible = c(
    "Rapid changeover with minimal downtime",
    "High variety, even mixed on same line",
    "Low to medium",
    "Quick, often automatic; minutes",
    "Very high",
    "Higher per unit, but flexible",
    "FMS, robotic cells, AGVs",
    "Aerospace, custom manufacturing"
  )
)

kable(types_table, col.names = c("", "Fixed Automation", "Programmable Automation", "Flexible Automation"),
      caption = "Comparison of Automation Types") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  column_spec(2, background = "#fadbd8") %>%
  column_spec(3, background = "#fcf3cf") %>%
  column_spec(4, background = "#d5f5e3")
```

### The Automation Pyramid

```{r automation-pyramid, echo=FALSE, fig.width=12, fig.height=8}
pyramid_levels <- data.frame(
  level = c("Level 4", "Level 3", "Level 2", "Level 1", "Level 0"),
  name = c("Enterprise", "Manufacturing Operations", "Control", "Field Devices", "Process"),
  description = c(
    "ERP, Business Planning, Supply Chain",
    "MES, SCADA, Production Scheduling",
    "PLCs, DCS, Motion Controllers",
    "Sensors, Actuators, Drives, I/O",
    "Physical Process, Machines, Equipment"
  ),
  width = c(3, 4, 5, 6, 7),
  y = c(5, 4, 3, 2, 1),
  color = c("#2c3e50", "#8e44ad", "#2980b9", "#27ae60", "#e67e22")
)

ggplot(pyramid_levels, aes(x = 0, y = y)) +
  geom_tile(aes(width = width, height = 0.8, fill = color), color = "white", size = 2) +
  geom_text(aes(x = -2.5, label = level), fontface = "bold", hjust = 1, size = 4) +
  geom_text(aes(label = name), fontface = "bold", size = 4.5, color = "white") +
  geom_text(aes(label = description, y = y - 0.25), size = 3, color = "white") +
  scale_fill_identity() +
  coord_cartesian(xlim = c(-4, 4)) +
  labs(title = "The Automation Pyramid (ISA-95)",
       subtitle = "Hierarchical levels of industrial automation and control") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, size = 11)
  )
```

<details><summary>**Understanding the Pyramid Levels**</summary>

**Level 0 - Process:** The actual physical equipment, machines, and processes being controlled. This includes conveyors, motors, valves, tanks, and the product being manufactured.

**Level 1 - Field Devices:** Sensors that measure process variables (temperature, pressure, flow, position) and actuators that affect the process (motors, valves, solenoids, drives).

**Level 2 - Control:** The "brain" of automation - PLCs, DCS, and motion controllers that execute control logic, process sensor inputs, and command actuators. Also includes HMI for operator interaction.

**Level 3 - Manufacturing Operations:** MES (Manufacturing Execution Systems), SCADA, production scheduling, quality management, and maintenance management. Bridges plant floor and business systems.

**Level 4 - Enterprise:** ERP systems, business intelligence, supply chain management, financial systems. Makes business decisions based on plant floor data.

**Key Principle:** Data flows up (process information), commands flow down (control directives).
</details>

---

## Programmable Logic Controllers (PLCs)

The **PLC (Programmable Logic Controller)** is the workhorse of industrial automation, providing reliable, real-time control of machines and processes.

### What is a PLC?

```{r plc-definition, echo=FALSE, fig.width=12, fig.height=6}
ggplot() +
  # PLC box
  annotate("rect", xmin = 3, xmax = 7, ymin = 1, ymax = 4,
           fill = "#34495e", color = "black", size = 1.5) +
  annotate("text", x = 5, y = 3.5, label = "PLC",
           color = "white", fontface = "bold", size = 8) +
  annotate("text", x = 5, y = 2.8, label = "Programmable Logic Controller",
           color = "white", size = 3.5) +
  annotate("text", x = 5, y = 2.2, label = "• Scan Inputs\n• Execute Program\n• Update Outputs",
           color = "#3498db", size = 3, lineheight = 0.9) +

  # Inputs
  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 1.5, ymax = 3.5,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 1.5, y = 3.2, label = "INPUTS",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 1.5, y = 2.5, label = "• Switches\n• Sensors\n• Push buttons\n• Encoders",
           color = "white", size = 2.8, lineheight = 0.9) +
  annotate("segment", x = 2.5, xend = 3, y = 2.5, yend = 2.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.5, color = "#27ae60") +

  # Outputs
  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 1.5, ymax = 3.5,
           fill = "#e74c3c", color = "black") +
  annotate("text", x = 8.5, y = 3.2, label = "OUTPUTS",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 8.5, y = 2.5, label = "• Motors\n• Valves\n• Lights\n• Alarms",
           color = "white", size = 2.8, lineheight = 0.9) +
  annotate("segment", x = 7, xend = 7.5, y = 2.5, yend = 2.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.5, color = "#e74c3c") +

  # Programming
  annotate("rect", xmin = 4, xmax = 6, ymin = 4.5, ymax = 5.5,
           fill = "#9b59b6", color = "black") +
  annotate("text", x = 5, y = 5, label = "Programming\n(Ladder, FBD, ST)",
           color = "white", size = 3, lineheight = 0.9) +
  annotate("segment", x = 5, xend = 5, y = 4.5, yend = 4,
           arrow = arrow(length = unit(0.3, "cm")), size = 1, color = "#9b59b6") +

  coord_cartesian(xlim = c(0, 10), ylim = c(0.5, 6)) +
  labs(title = "PLC: The Industrial Control Computer",
       subtitle = "Reads inputs, executes logic, controls outputs") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### PLC Hardware Components

```{r plc-components, echo=FALSE}
plc_parts <- data.frame(
  Component = c("CPU (Processor)", "Power Supply", "Input Modules",
                "Output Modules", "Communication Modules", "Programming Device"),
  Function = c(
    "Executes the control program, manages memory, coordinates all modules",
    "Converts AC power to DC voltages required by PLC components",
    "Interface field devices (sensors, switches) to CPU; converts signals to digital",
    "Interface CPU to field devices (motors, valves); converts digital to power signals",
    "Enable networking: Ethernet/IP, Profinet, Modbus, DeviceNet",
    "Laptop/PC with programming software for creating and downloading programs"
  ),
  Specifications = c(
    "Scan time (ms), memory size (KB/MB), I/O capacity",
    "Input voltage (120/240 VAC), output power (watts)",
    "Digital (24VDC, 120VAC) or Analog (4-20mA, 0-10V)",
    "Digital (relay, transistor) or Analog (4-20mA, 0-10V)",
    "Protocol, speed (Mbps), ports",
    "Software: RSLogix, TIA Portal, GX Works"
  )
)

kable(plc_parts, caption = "PLC Hardware Components") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### The PLC Scan Cycle

PLCs operate in a continuous scan cycle:

```{r plc-scan-cycle, echo=FALSE, fig.width=10, fig.height=8}
scan_steps <- data.frame(
  step = 1:4,
  name = c("1. Read Inputs", "2. Execute Program", "3. Update Outputs", "4. Housekeeping"),
  description = c(
    "Read all input module states into input image table",
    "Execute ladder logic/program using input image data",
    "Write output image table values to physical outputs",
    "Communications, diagnostics, self-testing"
  ),
  time = c("~1ms", "~5-20ms", "~1ms", "~1ms"),
  angle = c(90, 0, -90, 180),
  x = c(2, 4, 2, 0),
  y = c(4, 2, 0, 2)
)

ggplot() +
  # Circle for scan cycle
  annotate("path",
           x = 2 + 1.5 * cos(seq(0, 2*pi, length.out = 100)),
           y = 2 + 1.5 * sin(seq(0, 2*pi, length.out = 100)),
           color = "gray70", size = 2) +

  # Arrows indicating direction
  annotate("segment", x = 3.5, xend = 3.3, y = 2.5, yend = 3.2,
           arrow = arrow(length = unit(0.3, "cm")), color = "#3498db", size = 1.5) +
  annotate("segment", x = 2.5, xend = 1.5, y = 3.5, yend = 3.3,
           arrow = arrow(length = unit(0.3, "cm")), color = "#27ae60", size = 1.5) +
  annotate("segment", x = 0.5, xend = 0.7, y = 2.5, yend = 1.5,
           arrow = arrow(length = unit(0.3, "cm")), color = "#e74c3c", size = 1.5) +
  annotate("segment", x = 1.5, xend = 2.5, y = 0.5, yend = 0.7,
           arrow = arrow(length = unit(0.3, "cm")), color = "#f39c12", size = 1.5) +

  # Step boxes
  geom_label(data = scan_steps, aes(x = x, y = y, label = name),
             fill = c("#3498db", "#27ae60", "#e74c3c", "#f39c12"),
             color = "white", fontface = "bold", size = 3.5,
             label.padding = unit(0.4, "lines")) +

  # Center label
  annotate("text", x = 2, y = 2, label = "SCAN\nCYCLE\n(~10-50ms)",
           fontface = "bold", size = 4, lineheight = 0.9) +

  # Time annotations
  annotate("text", x = c(2, 4.5, 2, -0.5), y = c(4.7, 2, -0.7, 2),
           label = scan_steps$time, size = 3, color = "gray40") +

  coord_cartesian(xlim = c(-1, 5), ylim = c(-1, 5)) +
  labs(title = "PLC Scan Cycle",
       subtitle = "Continuous loop executing at predictable intervals") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

```{r scan-time-calc, echo=TRUE}
# Scan Time Calculation Example
input_scan_time <- 1.2    # ms
program_execution <- 15.5  # ms (depends on program size)
output_update <- 1.0       # ms
housekeeping <- 2.3        # ms

total_scan_time <- input_scan_time + program_execution + output_update + housekeeping

cat("PLC Scan Time Calculation:\n")
cat("─────────────────────────────\n")
cat("Input Scan:       ", input_scan_time, "ms\n")
cat("Program Execution:", program_execution, "ms\n")
cat("Output Update:    ", output_update, "ms\n")
cat("Housekeeping:     ", housekeeping, "ms\n")
cat("─────────────────────────────\n")
cat("Total Scan Time:  ", total_scan_time, "ms\n")
cat("\nScans per second: ", round(1000/total_scan_time, 0), "\n")
```

### PLC Programming Languages (IEC 61131-3)

```{r plc-languages, echo=FALSE}
languages <- data.frame(
  Language = c("Ladder Diagram (LD)", "Function Block Diagram (FBD)",
               "Structured Text (ST)", "Instruction List (IL)", "Sequential Function Chart (SFC)"),
  Type = c("Graphical", "Graphical", "Textual", "Textual", "Graphical"),
  Description = c(
    "Resembles electrical relay circuits; most common in discrete manufacturing",
    "Uses function blocks connected by lines; good for analog/process control",
    "High-level language similar to Pascal; powerful for complex calculations",
    "Low-level assembly-like language; rarely used today",
    "Sequence/state-based programming; excellent for batch processes"
  ),
  Best_For = c(
    "Boolean logic, interlocks, machine control",
    "PID loops, motion control, data manipulation",
    "Math operations, data handling, complex algorithms",
    "Legacy systems, compact code",
    "Sequential operations, batch control, recipes"
  )
)

kable(languages, col.names = c("Language", "Type", "Description", "Best For"),
      caption = "IEC 61131-3 PLC Programming Languages") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%") %>%
  row_spec(1, background = "#e8f6f3") %>%
  row_spec(2, background = "#ebf5fb")
```

### Ladder Logic Example

```{r ladder-example, echo=FALSE, fig.width=12, fig.height=6}
ggplot() +
  # Power rails
  annotate("segment", x = 0.5, xend = 0.5, y = 0.5, yend = 4.5, size = 2, color = "brown") +
  annotate("segment", x = 9.5, xend = 9.5, y = 0.5, yend = 4.5, size = 2, color = "brown") +
  annotate("text", x = 0.5, y = 4.8, label = "L1\n(Hot)", size = 3, fontface = "bold") +
  annotate("text", x = 9.5, y = 4.8, label = "L2\n(Neutral)", size = 3, fontface = "bold") +

  # Rung 1: Start/Stop circuit with seal-in
  annotate("segment", x = 0.5, xend = 1.5, y = 4, yend = 4, size = 1) +
  # Stop button (NC)
  annotate("segment", x = 1.5, xend = 1.8, y = 4, yend = 4, size = 1) +
  annotate("segment", x = 1.8, xend = 2.2, y = 4.15, yend = 3.85, size = 1.5, color = "#e74c3c") +
  annotate("segment", x = 2.2, xend = 2.5, y = 4, yend = 4, size = 1) +
  annotate("text", x = 2, y = 4.4, label = "STOP", size = 2.5) +
  # Start button (NO)
  annotate("segment", x = 2.5, xend = 3.5, y = 4, yend = 4, size = 1) +
  annotate("segment", x = 3.5, xend = 3.8, y = 4, yend = 4, size = 1) +
  annotate("segment", x = 3.8, xend = 4.2, y = 4.15, yend = 4.15, size = 1.5, color = "#27ae60") +
  annotate("segment", x = 4.2, xend = 4.5, y = 4, yend = 4, size = 1) +
  annotate("text", x = 4, y = 4.4, label = "START", size = 2.5) +
  # Branch for seal-in contact
  annotate("segment", x = 2.5, xend = 2.5, y = 4, yend = 3.3, size = 1) +
  annotate("segment", x = 2.5, xend = 3.5, y = 3.3, yend = 3.3, size = 1) +
  annotate("segment", x = 3.5, xend = 3.8, y = 3.3, yend = 3.3, size = 1) +
  annotate("segment", x = 3.8, xend = 4.2, y = 3.45, yend = 3.15, size = 1.5, color = "#3498db") +
  annotate("segment", x = 4.2, xend = 4.5, y = 3.3, yend = 3.3, size = 1) +
  annotate("text", x = 4, y = 3.7, label = "MOTOR", size = 2.5) +
  annotate("segment", x = 4.5, xend = 4.5, y = 4, yend = 3.3, size = 1) +
  # Continue to output
  annotate("segment", x = 4.5, xend = 8, y = 4, yend = 4, size = 1) +
  # Output coil (Motor)
  annotate("point", x = 8.5, y = 4, size = 15, shape = 21, fill = "white", color = "#3498db", stroke = 2) +
  annotate("text", x = 8.5, y = 4, label = "M", size = 4, fontface = "bold", color = "#3498db") +
  annotate("text", x = 8.5, y = 4.4, label = "MOTOR", size = 2.5) +
  annotate("segment", x = 9, xend = 9.5, y = 4, yend = 4, size = 1) +

  # Rung 2: Motor running indicator
  annotate("segment", x = 0.5, xend = 3.5, y = 2, yend = 2, size = 1) +
  annotate("segment", x = 3.5, xend = 3.8, y = 2, yend = 2, size = 1) +
  annotate("segment", x = 3.8, xend = 4.2, y = 2.15, yend = 1.85, size = 1.5, color = "#3498db") +
  annotate("segment", x = 4.2, xend = 8, y = 2, yend = 2, size = 1) +
  annotate("text", x = 4, y = 2.4, label = "MOTOR", size = 2.5) +
  annotate("point", x = 8.5, y = 2, size = 15, shape = 21, fill = "white", color = "#27ae60", stroke = 2) +
  annotate("text", x = 8.5, y = 2, label = "L", size = 4, fontface = "bold", color = "#27ae60") +
  annotate("text", x = 8.5, y = 2.4, label = "RUN LIGHT", size = 2.5) +
  annotate("segment", x = 9, xend = 9.5, y = 2, yend = 2, size = 1) +

  # Rung labels
  annotate("text", x = 0.2, y = 4, label = "1", fontface = "bold", size = 4) +
  annotate("text", x = 0.2, y = 2, label = "2", fontface = "bold", size = 4) +

  # Legend
  annotate("rect", xmin = 0.5, xmax = 4, ymin = 0.3, ymax = 1.3, fill = "#f8f9fa", color = "gray") +
  annotate("text", x = 0.7, y = 1.1, label = "Legend:", hjust = 0, fontface = "bold", size = 3) +
  annotate("segment", x = 0.7, xend = 1.1, y = 0.8, yend = 0.5, size = 1, color = "#27ae60") +
  annotate("text", x = 1.3, y = 0.65, label = "NO Contact", hjust = 0, size = 2.5) +
  annotate("segment", x = 2.2, xend = 2.6, y = 0.8, yend = 0.5, size = 1, color = "#e74c3c") +
  annotate("segment", x = 2.2, xend = 2.6, y = 0.65, yend = 0.65, size = 0.5, color = "#e74c3c") +
  annotate("text", x = 2.8, y = 0.65, label = "NC Contact", hjust = 0, size = 2.5) +

  coord_cartesian(xlim = c(0, 10), ylim = c(0, 5.2)) +
  labs(title = "Ladder Logic Example: Motor Start/Stop Circuit with Seal-In",
       subtitle = "Classic 3-wire control circuit implemented in PLC ladder logic") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 12, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
```

<details><summary>**How the Start/Stop Circuit Works**</summary>

**Rung 1 - Motor Control:**
1. Power flows from L1 through the NC (Normally Closed) STOP button
2. If STOP is pressed, the circuit breaks and motor stops
3. START is NO (Normally Open) - pressing it allows power to flow to the MOTOR coil
4. When MOTOR energizes, its NO contact in the parallel branch closes
5. This "seals in" the circuit - motor stays running even after START is released
6. To stop, press STOP which breaks the seal-in circuit

**Rung 2 - Run Indicator:**
1. When MOTOR coil is energized, the MOTOR contact closes
2. This allows power to flow to the RUN LIGHT output
3. Light is ON whenever motor is running

**This is called a "3-wire control" circuit** - it provides:
- Low voltage release protection (motor won't restart after power failure)
- Maintained contact operation (don't need to hold START button)
</details>

---

## Industrial Sensors

Sensors are the "eyes and ears" of automation systems, providing feedback about the process to the control system.

### Sensor Classification

```{r sensor-classification, echo=FALSE, fig.width=12, fig.height=8}
sensors <- data.frame(
  Category = c(rep("Discrete (On/Off)", 4), rep("Analog (Variable)", 4), rep("Smart/Digital", 3)),
  Type = c("Proximity (Inductive)", "Proximity (Capacitive)", "Photoelectric", "Limit Switch",
           "Temperature (RTD/TC)", "Pressure Transducer", "Flow Meter", "Level Sensor",
           "Encoder", "Vision System", "Vibration Sensor"),
  Application = c(
    "Metal detection, position sensing",
    "Liquid level, non-metal detection",
    "Part detection, counting, color",
    "End-of-travel, door position",
    "Process temperature monitoring",
    "Hydraulic, pneumatic, process pressure",
    "Liquid/gas flow measurement",
    "Tank level, hopper level",
    "Motor position, speed feedback",
    "Inspection, guidance, reading codes",
    "Machine health monitoring"
  ),
  Output = c("PNP/NPN (DC)", "PNP/NPN (DC)", "PNP/NPN or Analog", "Dry contact",
             "4-20mA, RTD resistance", "4-20mA, 0-10V", "4-20mA, pulse", "4-20mA, ultrasonic",
             "Pulse, quadrature, absolute", "Ethernet, digital I/O", "4-20mA, digital")
)

ggplot(sensors, aes(x = Category, y = 1, fill = Category)) + # Added y = 1 here
  geom_col(width = 0.7, color = "white") + # Changed to geom_col
  geom_text(aes(label = Type), 
            position = position_stack(vjust = 0.5),
            color = "white", 
            size = 3.5, 
            fontface = "bold") +
  scale_fill_manual(values = c("Discrete (On/Off)" = "#3498db", 
                               "Analog (Variable)" = "#27ae60", 
                               "Smart/Digital" = "#9b59b6"), 
                    guide = "none") +
  coord_flip() +
  labs(title = "Industrial Sensor Categories",
       subtitle = "Individual sensor types mapped by category",
       x = "", y = "Count") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 11, face = "bold"),
    panel.grid.major.y = element_blank() # Cleans up the look for flipped charts
  )
```

```{r sensor-table, echo=FALSE}
sensor_details <- data.frame(
  Sensor = c("Inductive Proximity", "Capacitive Proximity", "Photoelectric",
             "RTD (PT100)", "Thermocouple", "Pressure Transducer",
             "Incremental Encoder", "Absolute Encoder"),
  Principle = c(
    "Eddy current change in oscillating field",
    "Capacitance change with target approach",
    "Light beam interrupted or reflected",
    "Resistance changes with temperature",
    "Voltage generated at junction of dissimilar metals",
    "Diaphragm deflection converted to electrical signal",
    "Optical/magnetic pulses per revolution",
    "Unique code for each position"
  ),
  Range = c("2-40mm typical", "2-25mm typical", "0.1-30m",
            "-200 to 850°C", "-200 to 2300°C", "0-10000 psi",
            "100-10000 PPR", "12-25 bit"),
  Advantages = c(
    "Durable, no contact, metal detection",
    "Detects any material, through walls",
    "Long range, versatile",
    "Accurate, stable, linear",
    "Wide range, fast response",
    "Accurate, wide range",
    "Simple, low cost, high resolution",
    "Position known at power-up"
  )
)

kable(sensor_details, caption = "Common Industrial Sensor Specifications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Sensor Wiring: PNP vs NPN

```{r pnp-npn, echo=FALSE, fig.width=12, fig.height=6}
ggplot() +
  # PNP (Sourcing)
  annotate("rect", xmin = 0.5, xmax = 4.5, ymin = 0.5, ymax = 4.5,
           fill = "#ebf5fb", color = "#3498db", size = 1) +
  annotate("text", x = 2.5, y = 4.2, label = "PNP (Sourcing)",
           fontface = "bold", size = 5, color = "#3498db") +

  # PNP sensor symbol
  annotate("rect", xmin = 1.5, xmax = 3.5, ymin = 2, ymax = 3.5,
           fill = "#3498db", color = "black") +
  annotate("text", x = 2.5, y = 2.75, label = "Sensor", color = "white", fontface = "bold") +
  # +V connection
  annotate("segment", x = 2, xend = 2, y = 3.5, yend = 4, color = "red", size = 1) +
  annotate("text", x = 2, y = 4.1, label = "+24V", size = 3, color = "red") +
  # 0V connection
  annotate("segment", x = 3, xend = 3, y = 2, yend = 1.5, color = "blue", size = 1) +
  annotate("text", x = 3, y = 1.3, label = "0V", size = 3, color = "blue") +
  # Output to PLC (sources current)
  annotate("segment", x = 3.5, xend = 4.2, y = 2.75, yend = 2.75, color = "brown", size = 1) +
  annotate("text", x = 4.3, y = 2.75, label = "→ PLC Input", hjust = 0, size = 3) +
  annotate("text", x = 2.5, y = 1, label = "Current flows FROM sensor\nPLC input sinks to 0V",
           size = 2.8, lineheight = 0.9) +

  # NPN (Sinking)
  annotate("rect", xmin = 5.5, xmax = 9.5, ymin = 0.5, ymax = 4.5,
           fill = "#eafaf1", color = "#27ae60", size = 1) +
  annotate("text", x = 7.5, y = 4.2, label = "NPN (Sinking)",
           fontface = "bold", size = 5, color = "#27ae60") +

  # NPN sensor symbol
  annotate("rect", xmin = 6.5, xmax = 8.5, ymin = 2, ymax = 3.5,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 7.5, y = 2.75, label = "Sensor", color = "white", fontface = "bold") +
  # +V connection
  annotate("segment", x = 7, xend = 7, y = 3.5, yend = 4, color = "red", size = 1) +
  annotate("text", x = 7, y = 4.1, label = "+24V", size = 3, color = "red") +
  # 0V connection
  annotate("segment", x = 8, xend = 8, y = 2, yend = 1.5, color = "blue", size = 1) +
  annotate("text", x = 8, y = 1.3, label = "0V", size = 3, color = "blue") +
  # Output to PLC (sinks current)
  annotate("segment", x = 8.5, xend = 9.2, y = 2.75, yend = 2.75, color = "brown", size = 1) +
  annotate("text", x = 9.3, y = 2.75, label = "→ PLC Input", hjust = 0, size = 3) +
  annotate("text", x = 7.5, y = 1, label = "Current flows TO sensor\nPLC input sources from +V",
           size = 2.8, lineheight = 0.9) +

  coord_cartesian(xlim = c(0, 10.5), ylim = c(0.3, 4.8)) +
  labs(title = "PNP vs NPN Sensor Output Configuration",
       subtitle = "PNP common in North America/Europe; NPN common in Asia") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

---

## Actuators and Motor Control

Actuators convert control signals into physical motion or action.

### Types of Industrial Actuators

```{r actuator-types, echo=FALSE}
actuators <- data.frame(
  Category = c("Electric Motors", "Electric Motors", "Electric Motors", "Electric Motors",
               "Pneumatic", "Pneumatic", "Hydraulic", "Hydraulic"),
  Type = c("AC Induction Motor", "Servo Motor", "Stepper Motor", "DC Motor",
           "Cylinder", "Rotary Actuator", "Cylinder", "Motor"),
  Application = c(
    "Conveyors, pumps, fans, compressors",
    "Precise positioning, robotics, CNC",
    "Indexing, low-speed positioning",
    "Battery vehicles, legacy systems",
    "Clamping, pushing, lifting",
    "Rotating grippers, indexing",
    "Heavy lifting, presses",
    "Heavy machinery, mobile equipment"
  ),
  Control = c(
    "VFD for variable speed",
    "Servo drive with feedback",
    "Stepper drive (open or closed loop)",
    "PWM, SCR drive",
    "Solenoid valves, proportional valves",
    "Solenoid valves",
    "Proportional/servo valves",
    "Proportional/servo valves"
  ),
  Characteristics = c(
    "Robust, low cost, high power",
    "High precision, dynamic response",
    "Simple control, holds position",
    "Easy speed control",
    "Fast, clean, moderate force",
    "Compact, clean",
    "Very high force, smooth",
    "High power density"
  )
)

kable(actuators, caption = "Industrial Actuator Types and Applications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%") %>%
  pack_rows("Electric", 1, 4, background = "#fef9e7") %>%
  pack_rows("Pneumatic", 5, 6, background = "#e8f6f3") %>%
  pack_rows("Hydraulic", 7, 8, background = "#fdedec")
```

### Variable Frequency Drives (VFDs)

A **Variable Frequency Drive (VFD)** controls AC motor speed by varying the frequency and voltage of the power supplied to the motor.

```{r vfd-diagram, echo=FALSE, fig.width=12, fig.height=6}
ggplot() +
  # Input power
  annotate("rect", xmin = 0.5, xmax = 2, ymin = 2, ymax = 3.5,
           fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.25, y = 2.75, label = "AC Input\n(60Hz Fixed)",
           color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # VFD sections
  # Rectifier
  annotate("rect", xmin = 2.5, xmax = 4, ymin = 2, ymax = 3.5,
           fill = "#3498db", color = "black") +
  annotate("text", x = 3.25, y = 3.2, label = "Rectifier",
           fontface = "bold", size = 3.5, color = "white") +
  annotate("text", x = 3.25, y = 2.5, label = "AC → DC",
           size = 3, color = "white") +

  # DC Bus
  annotate("rect", xmin = 4.3, xmax = 5.8, ymin = 2, ymax = 3.5,
           fill = "#f39c12", color = "black") +
  annotate("text", x = 5.05, y = 3.2, label = "DC Bus",
           fontface = "bold", size = 3.5, color = "white") +
  annotate("text", x = 5.05, y = 2.5, label = "Filter &\nCapacitors",
           size = 3, color = "white", lineheight = 0.9) +

  # Inverter
  annotate("rect", xmin = 6.1, xmax = 7.6, ymin = 2, ymax = 3.5,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 6.85, y = 3.2, label = "Inverter",
           fontface = "bold", size = 3.5, color = "white") +
  annotate("text", x = 6.85, y = 2.5, label = "DC → AC\n(PWM)",
           size = 3, color = "white", lineheight = 0.9) +

  # Motor
  annotate("point", x = 9, y = 2.75, size = 25, shape = 21,
           fill = "#9b59b6", color = "black", stroke = 1.5) +
  annotate("text", x = 9, y = 2.75, label = "M",
           fontface = "bold", size = 6, color = "white") +
  annotate("text", x = 9, y = 1.8, label = "AC Motor\n(Variable Speed)",
           size = 3, lineheight = 0.9) +

  # Arrows
  annotate("segment", x = 2, xend = 2.5, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 4, xend = 4.3, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 5.8, xend = 6.1, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 7.6, xend = 8.3, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +

  # Control input
  annotate("rect", xmin = 4.5, xmax = 6.5, ymin = 4, ymax = 4.8,
           fill = "#34495e", color = "black") +
  annotate("text", x = 5.5, y = 4.4, label = "Control: Speed Reference, Start/Stop",
           color = "white", size = 2.8) +
  annotate("segment", x = 5.5, xend = 5.5, y = 4, yend = 3.5,
           arrow = arrow(length = unit(0.2, "cm")), size = 1, linetype = "dashed") +

  # Output annotation
  annotate("text", x = 5, y = 1.3, label = "VFD",
           fontface = "bold", size = 6, color = "gray30") +

  coord_cartesian(xlim = c(0, 10), ylim = c(1, 5)) +
  labs(title = "Variable Frequency Drive (VFD) Block Diagram",
       subtitle = "Converts fixed frequency AC to variable frequency AC for motor speed control") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

```{r vfd-calculations, echo=TRUE}
# VFD Speed and Torque Calculations

# Motor nameplate data
motor_hp <- 10
poles <- 4
rated_voltage <- 460  # V
rated_frequency <- 60  # Hz
rated_rpm <- 1750
slip_rpm <- (120 * rated_frequency / poles) - rated_rpm

# Synchronous speed at rated frequency
sync_speed_60 <- 120 * rated_frequency / poles
cat("Motor Data:\n")
cat("Synchronous speed at 60Hz:", sync_speed_60, "RPM\n")
cat("Rated speed:", rated_rpm, "RPM\n")
cat("Slip:", slip_rpm, "RPM (", round(slip_rpm/sync_speed_60*100, 1), "%)\n\n")

# Calculate speed at different frequencies
frequencies <- c(15, 30, 45, 60, 75)
speeds <- sapply(frequencies, function(f) {
  sync <- 120 * f / poles
  sync - slip_rpm  # Assuming constant slip (approximation)
})

cat("Speed vs Frequency (V/Hz mode):\n")
cat("─────────────────────────────\n")
for(i in 1:length(frequencies)) {
  cat(sprintf("%2d Hz: %4d RPM\n", frequencies[i], speeds[i]))
}

# V/Hz ratio
vhz_ratio <- rated_voltage / rated_frequency
cat("\nV/Hz Ratio:", round(vhz_ratio, 2), "V/Hz\n")
cat("At 30Hz, voltage should be:", 30 * vhz_ratio, "V\n")
```

### VFD Benefits

```{r vfd-benefits, echo=FALSE}
vfd_benefits <- data.frame(
  Benefit = c("Energy Savings", "Soft Start/Stop", "Speed Control",
              "Process Control", "Reduced Mechanical Stress", "Power Factor"),
  Description = c(
    "Match motor speed to load requirements; huge savings on fans/pumps",
    "Ramp up/down gradually; eliminates inrush current (6-8x normal)",
    "Precise speed control from 0-100%+ of base speed",
    "Maintain constant pressure, flow, or tension",
    "Reduced wear on belts, gears, couplings from smooth acceleration",
    "VFD presents near-unity power factor to supply"
  ),
  Typical_Savings = c("20-50% energy reduction", "Reduced electrical stress",
                      "N/A", "Improved quality", "Extended equipment life",
                      "Avoid PF penalties")
)

kable(vfd_benefits, col.names = c("Benefit", "Description", "Typical Impact"),
      caption = "Variable Frequency Drive Benefits") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

### Servo Systems

```{r servo-system, echo=FALSE, fig.width=12, fig.height=5}
ggplot() +
  # Controller/PLC
  annotate("rect", xmin = 0.5, xmax = 2, ymin = 2, ymax = 3.5,
           fill = "#34495e", color = "black") +
  annotate("text", x = 1.25, y = 2.75, label = "Motion\nController",
           color = "white", fontface = "bold", size = 3.5, lineheight = 0.9) +

  # Servo Drive
  annotate("rect", xmin = 3, xmax = 5, ymin = 2, ymax = 3.5,
           fill = "#3498db", color = "black") +
  annotate("text", x = 4, y = 2.75, label = "Servo\nDrive",
           color = "white", fontface = "bold", size = 4, lineheight = 0.9) +

  # Servo Motor
  annotate("point", x = 7, y = 2.75, size = 22, shape = 21,
           fill = "#27ae60", color = "black", stroke = 1.5) +
  annotate("text", x = 7, y = 2.75, label = "SM",
           fontface = "bold", size = 5, color = "white") +
  annotate("text", x = 7, y = 2, label = "Servo Motor", size = 3) +

  # Encoder (feedback)
  annotate("rect", xmin = 8, xmax = 9, ymin = 2.3, ymax = 3.2,
           fill = "#e74c3c", color = "black") +
  annotate("text", x = 8.5, y = 2.75, label = "ENC",
           color = "white", fontface = "bold", size = 3) +

  # Load
  annotate("rect", xmin = 9.5, xmax = 10.5, ymin = 2.3, ymax = 3.2,
           fill = "#95a5a6", color = "black") +
  annotate("text", x = 10, y = 2.75, label = "Load",
           fontface = "bold", size = 3.5) +

  # Forward connections
  annotate("segment", x = 2, xend = 3, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("text", x = 2.5, y = 3, label = "Command", size = 2.5) +
  annotate("segment", x = 5, xend = 6.3, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1.2, color = "#e67e22") +
  annotate("text", x = 5.6, y = 3, label = "Power", size = 2.5, color = "#e67e22") +
  annotate("segment", x = 7.7, xend = 8, y = 2.75, yend = 2.75, size = 1) +
  annotate("segment", x = 9, xend = 9.5, y = 2.75, yend = 2.75,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +

  # Feedback loop
  annotate("segment", x = 8.5, xend = 8.5, y = 2.3, yend = 1.5, size = 1, color = "#e74c3c") +
  annotate("segment", x = 8.5, xend = 4, y = 1.5, yend = 1.5, size = 1, color = "#e74c3c") +
  annotate("segment", x = 4, xend = 4, y = 1.5, yend = 2,
           arrow = arrow(length = unit(0.2, "cm")), size = 1, color = "#e74c3c") +
  annotate("text", x = 6, y = 1.3, label = "Position/Velocity Feedback",
           size = 3, color = "#e74c3c") +

  coord_cartesian(xlim = c(0, 11), ylim = c(1, 4)) +
  labs(title = "Servo System: Closed-Loop Motion Control",
       subtitle = "Precise positioning through continuous feedback") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

```{r servo-vs-vfd, echo=FALSE}
servo_vfd <- data.frame(
  Characteristic = c("Control Type", "Feedback", "Positioning Accuracy",
                     "Dynamic Response", "Torque at Zero Speed", "Cost",
                     "Typical Application"),
  VFD = c("Open loop (usually)", "Optional encoder", "±1-5% of speed",
          "Moderate (100-500ms)", "Limited (10-20%)", "Lower ($500-5000)",
          "Fans, pumps, conveyors"),
  Servo = c("Closed loop (always)", "High-resolution encoder required",
            "±0.01° or better", "Fast (1-10ms)", "100% continuous",
            "Higher ($2000-20000)", "Robotics, CNC, packaging")
)

kable(servo_vfd, col.names = c("Characteristic", "VFD + Induction Motor", "Servo System"),
      caption = "VFD vs. Servo System Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "22%") %>%
  column_spec(2, background = "#ebf5fb") %>%
  column_spec(3, background = "#e8f8f5")
```

---

## Industrial Communication Networks

Modern automation systems rely on communication networks to connect devices, share data, and enable coordinated control.

### Network Architecture

```{r network-architecture, echo=FALSE, fig.width=12, fig.height=8}
ggplot() +
  # Enterprise level
  annotate("rect", xmin = 1, xmax = 9, ymin = 7, ymax = 8, fill = "#2c3e50", color = "black") +
  annotate("text", x = 5, y = 7.5, label = "Enterprise Network (IT): ERP, MES, Business Systems",
           color = "white", fontface = "bold", size = 3.5) +

  # Plant backbone
  annotate("rect", xmin = 1, xmax = 9, ymin = 5.5, ymax = 6.5, fill = "#8e44ad", color = "black") +
  annotate("text", x = 5, y = 6, label = "Plant Network: Ethernet/IP, PROFINET (100Mbps-1Gbps)",
           color = "white", fontface = "bold", size = 3.5) +

  # Control level devices
  annotate("rect", xmin = 1.5, xmax = 3, ymin = 4, ymax = 5, fill = "#3498db", color = "black") +
  annotate("text", x = 2.25, y = 4.5, label = "PLC", color = "white", fontface = "bold", size = 4) +

  annotate("rect", xmin = 4, xmax = 6, ymin = 4, ymax = 5, fill = "#3498db", color = "black") +
  annotate("text", x = 5, y = 4.5, label = "HMI/SCADA", color = "white", fontface = "bold", size = 4) +

  annotate("rect", xmin = 7, xmax = 8.5, ymin = 4, ymax = 5, fill = "#3498db", color = "black") +
  annotate("text", x = 7.75, y = 4.5, label = "Robot\nController", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Device level bus
  annotate("rect", xmin = 1, xmax = 9, ymin = 2.5, ymax = 3.3, fill = "#27ae60", color = "black") +
  annotate("text", x = 5, y = 2.9, label = "Device Network: DeviceNet, PROFIBUS, IO-Link, AS-i",
           color = "white", fontface = "bold", size = 3.5) +

  # Field devices
  annotate("rect", xmin = 1.2, xmax = 2.2, ymin = 1, ymax = 2, fill = "#f39c12", color = "black") +
  annotate("text", x = 1.7, y = 1.5, label = "VFD", color = "white", fontface = "bold", size = 3.5) +

  annotate("rect", xmin = 2.8, xmax = 3.8, ymin = 1, ymax = 2, fill = "#f39c12", color = "black") +
  annotate("text", x = 3.3, y = 1.5, label = "I/O", color = "white", fontface = "bold", size = 3.5) +

  annotate("rect", xmin = 4.4, xmax = 5.4, ymin = 1, ymax = 2, fill = "#f39c12", color = "black") +
  annotate("text", x = 4.9, y = 1.5, label = "Sensors", color = "white", fontface = "bold", size = 3) +

  annotate("rect", xmin = 6, xmax = 7, ymin = 1, ymax = 2, fill = "#f39c12", color = "black") +
  annotate("text", x = 6.5, y = 1.5, label = "Valve\nBank", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 7.6, xmax = 8.6, ymin = 1, ymax = 2, fill = "#f39c12", color = "black") +
  annotate("text", x = 8.1, y = 1.5, label = "Safety\nI/O", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Vertical connections
  annotate("segment", x = 5, xend = 5, y = 7, yend = 6.5, size = 1) +
  annotate("segment", x = 2.25, xend = 2.25, y = 5.5, yend = 5, size = 1) +
  annotate("segment", x = 5, xend = 5, y = 5.5, yend = 5, size = 1) +
  annotate("segment", x = 7.75, xend = 7.75, y = 5.5, yend = 5, size = 1) +
  annotate("segment", x = 2.25, xend = 2.25, y = 4, yend = 3.3, size = 1) +

  # Device connections
  annotate("segment", x = 1.7, xend = 1.7, y = 2.5, yend = 2, size = 0.8) +
  annotate("segment", x = 3.3, xend = 3.3, y = 2.5, yend = 2, size = 0.8) +
  annotate("segment", x = 4.9, xend = 4.9, y = 2.5, yend = 2, size = 0.8) +
  annotate("segment", x = 6.5, xend = 6.5, y = 2.5, yend = 2, size = 0.8) +
  annotate("segment", x = 8.1, xend = 8.1, y = 2.5, yend = 2, size = 0.8) +

  coord_cartesian(xlim = c(0.5, 9.5), ylim = c(0.5, 8.5)) +
  labs(title = "Industrial Network Architecture",
       subtitle = "Hierarchical network structure from enterprise to field level") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Common Industrial Protocols

```{r protocols-table, echo=FALSE}
protocols <- data.frame(
  Protocol = c("Ethernet/IP", "PROFINET", "Modbus TCP", "EtherCAT",
               "DeviceNet", "PROFIBUS", "IO-Link", "OPC UA"),
  Developer = c("ODVA (Rockwell)", "PI (Siemens)", "Modicon/Schneider", "Beckhoff",
                "ODVA", "PI (Siemens)", "IO-Link Consortium", "OPC Foundation"),
  Medium = c("Ethernet", "Ethernet", "Ethernet", "Ethernet",
             "CAN-based", "RS-485", "Point-to-point", "Ethernet/Any"),
  Speed = c("100Mbps/1Gbps", "100Mbps/1Gbps", "100Mbps", "100Mbps",
            "500kbps", "12Mbps", "230.4kbps", "Varies"),
  Application = c("General automation, I/O, drives", "Siemens ecosystem, motion",
                  "Simple, open, legacy systems", "High-speed motion, precision",
                  "I/O, drives (legacy)", "I/O, drives (legacy)", "Smart sensors",
                  "IT/OT integration, IIoT")
)

kable(protocols, caption = "Common Industrial Communication Protocols") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "14%") %>%
  row_spec(c(1, 2, 4), background = "#e8f6f3")
```

<details><summary>**Protocol Selection Guide**</summary>

**Choose Ethernet/IP if:**
- Using Allen-Bradley/Rockwell equipment
- Need general-purpose industrial Ethernet
- Require seamless integration with IT networks

**Choose PROFINET if:**
- Using Siemens equipment
- Need deterministic communication for motion control
- Require IRT (Isochronous Real-Time) performance

**Choose EtherCAT if:**
- Need highest speed/lowest latency
- High-precision motion control
- Many axes of coordinated motion

**Choose Modbus TCP if:**
- Simple, low-cost solution needed
- Connecting legacy equipment
- Open protocol preference (no licensing)

**Choose OPC UA if:**
- Need IT/OT convergence
- IIoT/Industry 4.0 implementation
- Secure, platform-independent communication
</details>

---

## Human-Machine Interface (HMI) and SCADA

### HMI Overview

An **HMI (Human-Machine Interface)** provides operators with a visual interface to monitor and control automated processes.

```{r hmi-elements, echo=FALSE, fig.width=12, fig.height=7}
ggplot() +
  # HMI screen outline
  annotate("rect", xmin = 1, xmax = 9, ymin = 1, ymax = 7,
           fill = "#ecf0f1", color = "#2c3e50", size = 2) +

  # Header bar
  annotate("rect", xmin = 1, xmax = 9, ymin = 6.2, ymax = 7, fill = "#3498db") +
  annotate("text", x = 5, y = 6.6, label = "PRODUCTION LINE 1 - OVERVIEW",
           color = "white", fontface = "bold", size = 4) +

  # Navigation buttons
  annotate("rect", xmin = 1.2, xmax = 2.2, ymin = 5.5, ymax = 6, fill = "#27ae60") +
  annotate("text", x = 1.7, y = 5.75, label = "Overview", color = "white", size = 2.5) +
  annotate("rect", xmin = 2.4, xmax = 3.4, ymin = 5.5, ymax = 6, fill = "#95a5a6") +
  annotate("text", x = 2.9, y = 5.75, label = "Alarms", color = "white", size = 2.5) +
  annotate("rect", xmin = 3.6, xmax = 4.6, ymin = 5.5, ymax = 6, fill = "#95a5a6") +
  annotate("text", x = 4.1, y = 5.75, label = "Trends", color = "white", size = 2.5) +
  annotate("rect", xmin = 4.8, xmax = 5.8, ymin = 5.5, ymax = 6, fill = "#95a5a6") +
  annotate("text", x = 5.3, y = 5.75, label = "Settings", color = "white", size = 2.5) +

  # Process graphic - Tank
  annotate("rect", xmin = 1.5, xmax = 3, ymin = 2.5, ymax = 5, fill = "#bdc3c7", color = "black") +
  annotate("rect", xmin = 1.6, xmax = 2.9, ymin = 2.6, ymax = 4.2, fill = "#3498db", alpha = 0.7) +
  annotate("text", x = 2.25, y = 4.7, label = "TANK 1", fontface = "bold", size = 3) +
  annotate("text", x = 2.25, y = 3.4, label = "75%", color = "white", fontface = "bold", size = 4) +

  # Pump symbol
  annotate("point", x = 4, y = 3, size = 12, shape = 21, fill = "#27ae60", color = "black") +
  annotate("text", x = 4, y = 3, label = "P1", fontface = "bold", size = 3) +
  annotate("text", x = 4, y = 2.4, label = "RUNNING", color = "#27ae60", size = 2.5) +

  # Flow indicator
  annotate("rect", xmin = 5.2, xmax = 6.5, ymin = 2.7, ymax = 3.6, fill = "white", color = "black") +
  annotate("text", x = 5.85, y = 3.35, label = "FLOW", size = 2.5) +
  annotate("text", x = 5.85, y = 3, label = "125.5", fontface = "bold", size = 4, color = "#2c3e50") +
  annotate("text", x = 5.85, y = 2.75, label = "GPM", size = 2.5) +

  # Temperature indicator
  annotate("rect", xmin = 7, xmax = 8.3, ymin = 2.7, ymax = 3.6, fill = "white", color = "black") +
  annotate("text", x = 7.65, y = 3.35, label = "TEMP", size = 2.5) +
  annotate("text", x = 7.65, y = 3, label = "185.2", fontface = "bold", size = 4, color = "#e74c3c") +
  annotate("text", x = 7.65, y = 2.75, label = "°F", size = 2.5) +

  # Pipes
  annotate("segment", x = 3, xend = 3.5, y = 3, yend = 3, size = 3, color = "#3498db") +
  annotate("segment", x = 4.5, xend = 5.2, y = 3, yend = 3, size = 3, color = "#3498db") +
  annotate("segment", x = 6.5, xend = 7, y = 3.15, yend = 3.15, size = 3, color = "#3498db") +

  # Status bar
  annotate("rect", xmin = 1, xmax = 9, ymin = 1, ymax = 1.8, fill = "#2c3e50") +
  annotate("text", x = 1.5, y = 1.4, label = "Status: AUTO", color = "#27ae60",
           hjust = 0, size = 3, fontface = "bold") +
  annotate("text", x = 4.5, y = 1.4, label = "Active Alarms: 0", color = "#27ae60",
           hjust = 0, size = 3) +
  annotate("text", x = 7.5, y = 1.4, label = "14:35:22", color = "white", size = 3) +

  # Control buttons
  annotate("rect", xmin = 7, xmax = 8.5, ymin = 4.5, ymax = 5.2, fill = "#27ae60", color = "black") +
  annotate("text", x = 7.75, y = 4.85, label = "START", color = "white", fontface = "bold", size = 3) +
  annotate("rect", xmin = 7, xmax = 8.5, ymin = 3.8, ymax = 4.4, fill = "#e74c3c", color = "black") +
  annotate("text", x = 7.75, y = 4.1, label = "STOP", color = "white", fontface = "bold", size = 3) +

  coord_cartesian(xlim = c(0.5, 9.5), ylim = c(0.5, 7.5)) +
  labs(title = "HMI Screen Example",
       subtitle = "Typical operator interface showing process status and controls") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### HMI Design Best Practices

```{r hmi-practices, echo=FALSE}
hmi_practices <- data.frame(
  Principle = c("Situational Awareness", "Alarm Management", "Navigation",
                "Color Usage", "Data Display", "Controls"),
  Guideline = c(
    "Show abnormal conditions prominently; operator should know status at a glance",
    "Prioritize alarms (critical/warning/info); avoid alarm floods; require acknowledgment",
    "Consistent layout; max 3 clicks to any screen; clear hierarchy",
    "Use color sparingly for meaning; gray for normal; avoid red/green for critical info (colorblind)",
    "Show trends, not just values; use appropriate precision; include units",
    "Confirm destructive actions; use interlocks; provide feedback"
  ),
  Bad_Practice = c(
    "Everything same color; too much detail",
    "Hundreds of unacknowledged alarms",
    "Inconsistent button placement",
    "Rainbow colors everywhere",
    "Too many decimal places; no context",
    "No confirmation for critical commands"
  )
)

kable(hmi_practices, col.names = c("Principle", "Best Practice", "Avoid"),
      caption = "HMI Design Best Practices") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  column_spec(3, background = "#fadbd8")
```

### SCADA Systems

**SCADA (Supervisory Control and Data Acquisition)** systems provide centralized monitoring and control across multiple locations or processes.

```{r scada-architecture, echo=FALSE}
scada_components <- data.frame(
  Component = c("MTU (Master Terminal Unit)", "RTU (Remote Terminal Unit)",
                "Communication Network", "HMI/Workstations", "Historian Database",
                "Alarm Server"),
  Function = c(
    "Central server running SCADA software; processes data, executes logic",
    "Field device that collects data from sensors and sends to MTU",
    "Links MTU to RTUs; can be radio, cellular, satellite, fiber",
    "Operator interface for monitoring and control",
    "Stores historical process data for trending and analysis",
    "Manages alarm generation, notification, and logging"
  ),
  Example = c("Wonderware, Ignition, FactoryTalk", "PLC, dedicated RTU hardware",
              "Modbus, DNP3, IEC 61850", "PC workstations, web clients",
              "SQL database, OSIsoft PI", "Built into SCADA or separate")
)

kable(scada_components, caption = "SCADA System Components") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "22%")
```

---

## Safety in Automation

Safety is paramount in automated systems. Safety systems protect personnel and equipment from harm.

### Safety System Architecture

```{r safety-architecture, echo=FALSE, fig.width=12, fig.height=7}
ggplot() +
  # Safety PLC
  annotate("rect", xmin = 4, xmax = 6, ymin = 3, ymax = 5, fill = "#f1c40f", color = "black", size = 1.5) +
  annotate("text", x = 5, y = 4.5, label = "SAFETY", fontface = "bold", size = 4) +
  annotate("text", x = 5, y = 4, label = "PLC", fontface = "bold", size = 4) +
  annotate("text", x = 5, y = 3.4, label = "(SIL 3 / PLe)", size = 3) +

  # Safety inputs
  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 4.5, ymax = 5.5, fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.5, y = 5, label = "E-Stop", color = "white", fontface = "bold", size = 3.5) +

  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 3.3, ymax = 4.3, fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.5, y = 3.8, label = "Light Curtain", color = "white", fontface = "bold", size = 3.5) +

  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 2.1, ymax = 3.1, fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.5, y = 2.6, label = "Safety Gate", color = "white", fontface = "bold", size = 3.5) +

  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = 0.9, ymax = 1.9, fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.5, y = 1.4, label = "Two-Hand Ctrl", color = "white", fontface = "bold", size = 3.5) +

  # Safety outputs
  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 4.5, ymax = 5.5, fill = "#27ae60", color = "black") +
  annotate("text", x = 8.5, y = 5, label = "Safety Relay\n(Motor)", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 3.3, ymax = 4.3, fill = "#27ae60", color = "black") +
  annotate("text", x = 8.5, y = 3.8, label = "Safety Valve\n(Pneumatic)", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  annotate("rect", xmin = 7.5, xmax = 9.5, ymin = 2.1, ymax = 3.1, fill = "#27ae60", color = "black") +
  annotate("text", x = 8.5, y = 2.6, label = "Safe Torque Off\n(Drive)", color = "white",
           fontface = "bold", size = 3, lineheight = 0.9) +

  # Connections
  annotate("segment", x = 2.5, xend = 4, y = 5, yend = 4.5, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 4, y = 3.8, yend = 4.2, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 4, y = 2.6, yend = 3.5, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 4, y = 1.4, yend = 3.3, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +

  annotate("segment", x = 6, xend = 7.5, y = 4.5, yend = 5, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 6, xend = 7.5, y = 4.2, yend = 3.8, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 6, xend = 7.5, y = 3.5, yend = 2.6, size = 1,
           arrow = arrow(length = unit(0.2, "cm"))) +

  # Standard PLC communication
  annotate("rect", xmin = 4, xmax = 6, ymin = 0.5, ymax = 2, fill = "#3498db", color = "black") +
  annotate("text", x = 5, y = 1.5, label = "Standard", fontface = "bold", size = 3.5, color = "white") +
  annotate("text", x = 5, y = 1, label = "PLC", fontface = "bold", size = 3.5, color = "white") +
  annotate("segment", x = 5, xend = 5, y = 2, yend = 3, size = 1, linetype = "dashed",
           arrow = arrow(length = unit(0.15, "cm"), ends = "both")) +
  annotate("text", x = 5.7, y = 2.5, label = "Status\nExchange", size = 2.5, lineheight = 0.9) +

  coord_cartesian(xlim = c(0, 10), ylim = c(0, 6)) +
  labs(title = "Safety System Architecture",
       subtitle = "Dedicated safety controller with safety-rated inputs and outputs") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Safety Integrity Levels (SIL)

```{r sil-levels-automation, echo=FALSE}
sil_table <- data.frame(
  SIL = c("SIL 1", "SIL 2", "SIL 3", "SIL 4"),
  PFD = c("≥10⁻² to <10⁻¹", "≥10⁻³ to <10⁻²", "≥10⁻⁴ to <10⁻³", "≥10⁻⁵ to <10⁻⁴"),
  RRF = c("10-100", "100-1,000", "1,000-10,000", "10,000-100,000"),
  Application = c(
    "Minor injury possible; first line of defense",
    "Serious injury possible; general industrial",
    "Death or severe injury; process industry standard",
    "Catastrophic; nuclear, aviation"
  ),
  Example = c(
    "Warning systems, non-critical interlocks",
    "Machine guarding, general process safety",
    "Emergency shutdown, burner management",
    "Nuclear reactor protection (rarely used in manufacturing)"
  )
)

kable(sil_table, col.names = c("SIL Level", "PFD (avg)", "Risk Reduction Factor",
                               "Risk Level", "Example Application"),
      caption = "Safety Integrity Levels (IEC 61508)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(3, background = "#fcf3cf")
```

---

## Industry 4.0 and IIoT

**Industry 4.0** represents the fourth industrial revolution, characterized by the integration of digital technologies into manufacturing.

### Industry 4.0 Technologies

```{r industry4-tech, echo=FALSE, fig.width=12, fig.height=8}
i4_tech <- data.frame(
  Technology = c("IIoT", "Cloud Computing", "Big Data Analytics",
                 "Digital Twin", "AI/Machine Learning", "Cybersecurity",
                 "Additive Manufacturing", "AR/VR"),
  x = c(1, 2, 3, 4, 1, 2, 3, 4),
  y = c(2, 2, 2, 2, 1, 1, 1, 1),
  Description = c(
    "Connected sensors\nand devices",
    "Scalable computing\nand storage",
    "Insight from\nprocess data",
    "Virtual model\nof physical assets",
    "Predictive and\nprescriptive analytics",
    "Protecting OT\ninfrastructure",
    "3D printing for\nspare parts",
    "Training and\nmaintenance support"
  )
)

ggplot(i4_tech, aes(x = x, y = y)) +
  geom_tile(aes(fill = Technology), width = 0.9, height = 0.8, color = "white", size = 1.5) +
  geom_text(aes(label = Technology), fontface = "bold", size = 3.5, color = "white", vjust = -0.5) +
  geom_text(aes(label = Description), size = 2.8, color = "white", vjust = 1.5, lineheight = 0.9) +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60", "#f39c12",
                               "#9b59b6", "#1abc9c", "#e67e22", "#34495e"), guide = "none") +
  labs(title = "Industry 4.0 Key Technologies",
       subtitle = "Technologies enabling the smart factory") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### IIoT Architecture

```{r iiot-architecture, echo=FALSE}
iiot_layers <- data.frame(
  Layer = c("Edge/Device Layer", "Network Layer", "Platform Layer", "Application Layer"),
  Components = c(
    "Sensors, actuators, PLCs, gateways, edge devices",
    "Industrial Ethernet, Wi-Fi, 5G, LoRaWAN, MQTT",
    "Cloud/on-premise servers, databases, data lakes",
    "Analytics dashboards, AI/ML models, business applications"
  ),
  Function = c(
    "Collect data, local processing, protocol conversion",
    "Secure data transport, connectivity",
    "Store, process, and manage data at scale",
    "Derive insights, optimize operations, enable decisions"
  ),
  Examples = c(
    "Vibration sensor, smart valve, edge computer",
    "Cisco switches, AWS IoT Core, Kepware",
    "Azure IoT Hub, AWS, Ignition",
    "Power BI, TensorFlow, custom apps"
  )
)

kable(iiot_layers, caption = "IIoT Architecture Layers") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Predictive Maintenance Example

```{r predictive-maintenance, echo=TRUE}
# Simulating predictive maintenance with vibration data
set.seed(42)

# Generate 30 days of vibration readings
days <- 1:30
baseline_vibration <- 2.5  # mm/s RMS (normal)

# Simulate gradual bearing degradation
vibration <- baseline_vibration +
  0.05 * days +           # Gradual increase
  0.5 * exp((days - 25)/5) * (days > 20) +  # Accelerating failure
  rnorm(30, 0, 0.2)       # Normal variation

# Alert thresholds
warning_threshold <- 4.0
alarm_threshold <- 6.0

# Find when thresholds crossed
warning_day <- min(which(vibration > warning_threshold))
alarm_day <- min(which(vibration > alarm_threshold))

cat("Predictive Maintenance Analysis:\n")
cat("─────────────────────────────────\n")
cat("Baseline vibration:", baseline_vibration, "mm/s RMS\n")
cat("Warning threshold:", warning_threshold, "mm/s RMS\n")
cat("Alarm threshold:", alarm_threshold, "mm/s RMS\n\n")
cat("Warning triggered on day:", warning_day, "\n")
cat("Alarm triggered on day:", alarm_day, "\n")
cat("Days of warning before alarm:", alarm_day - warning_day, "\n")
cat("\nRecommendation: Schedule bearing replacement before day", alarm_day, "\n")
```

```{r predictive-plot, echo=FALSE, fig.width=11, fig.height=6}
vib_data <- data.frame(Day = days, Vibration = vibration)

ggplot(vib_data, aes(x = Day, y = Vibration)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(color = "steelblue", size = 2) +
  geom_hline(yintercept = warning_threshold, linetype = "dashed", color = "orange", size = 1) +
  geom_hline(yintercept = alarm_threshold, linetype = "dashed", color = "red", size = 1) +
  geom_hline(yintercept = baseline_vibration, linetype = "dotted", color = "green", size = 1) +
  annotate("text", x = 30, y = baseline_vibration + 0.2, label = "Baseline",
           hjust = 1, color = "green", fontface = "bold") +
  annotate("text", x = 30, y = warning_threshold + 0.2, label = "Warning",
           hjust = 1, color = "orange", fontface = "bold") +
  annotate("text", x = 30, y = alarm_threshold + 0.2, label = "Alarm",
           hjust = 1, color = "red", fontface = "bold") +
  annotate("rect", xmin = warning_day, xmax = alarm_day, ymin = 0, ymax = 8,
           fill = "orange", alpha = 0.1) +
  annotate("text", x = (warning_day + alarm_day)/2, y = 7.5,
           label = "Maintenance\nWindow", fontface = "bold", size = 3) +
  labs(title = "Predictive Maintenance: Bearing Vibration Monitoring",
       subtitle = "IIoT-enabled condition monitoring detects degradation before failure",
       x = "Day", y = "Vibration (mm/s RMS)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
```

---

## Video Resources

### Introduction to PLCs

<iframe width="560" height="315" src="https://www.youtube.com/embed/uOtdWHMKhnw&t" title="Introduction to PLCs" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Industrial Networks Explained

<iframe width="560" height="315" src="https://www.youtube.com/embed/tAqtHsiJGg8&list=PLt50BEIirCOMY8qrcGBdoJIAUHWXfJM6H" title="Industrial Networks" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Summary

Industrial automation integrates multiple technologies to improve manufacturing efficiency, quality, and safety:

1. **Automation types** range from fixed (high-volume, single product) to flexible (low-volume, high variety)
2. **PLCs** are the workhorses of industrial control, using scan cycles to process inputs and control outputs
3. **Sensors** provide feedback on process conditions (discrete, analog, and smart)
4. **Motor control** through VFDs and servo systems enables precise speed and position control
5. **Industrial networks** connect devices using protocols like Ethernet/IP, PROFINET, and Modbus
6. **HMI and SCADA** provide operator interface for monitoring and control
7. **Safety systems** use dedicated controllers and devices to protect personnel
8. **Industry 4.0** brings IIoT, cloud computing, and AI to enable smart manufacturing

---

## Review Questions

<details><summary>**Question 1**: Compare and contrast fixed, programmable, and flexible automation. Give an example application for each.</summary>

**Answer:**

| Aspect | Fixed | Programmable | Flexible |
|--------|-------|--------------|----------|
| Product variety | Single product | Batches of different products | High variety, mixed production |
| Volume | Very high | Medium-high | Low-medium |
| Changeover | Difficult, expensive | Hours to days | Minutes |
| Investment | Very high | High | Very high |
| Flexibility | None | Limited | High |

**Examples:**

1. **Fixed Automation**: Automotive transfer line producing engine blocks
   - Same machining operations repeated millions of times
   - Dedicated stations optimized for specific operations
   - Changing product would require complete retooling

2. **Programmable Automation**: CNC machining job shop
   - Different parts programmed and run in batches
   - Significant setup time between batches
   - Equipment reprogrammable but not instantaneous

3. **Flexible Automation**: Robotic welding cell in aerospace
   - Different assemblies run with quick changeover
   - Robot program changes automatically based on part ID
   - Same cell handles multiple product variants
</details>

<details><summary>**Question 2**: Explain the PLC scan cycle and why scan time is important.</summary>

**Answer:**

**The PLC Scan Cycle** consists of four main phases executed continuously:

1. **Input Scan** (~1ms): Read all physical inputs and store values in the input image table
2. **Program Execution** (~5-20ms): Execute the user program (ladder logic, etc.) using input image data
3. **Output Update** (~1ms): Write output image table values to physical outputs
4. **Housekeeping** (~1-3ms): Communications, diagnostics, self-testing

**Total scan time** = Sum of all phases, typically 10-50ms

**Why Scan Time Matters:**

1. **Response Time**: An input change isn't acted upon until the next scan completes. If scan time is 50ms, worst-case response time is 50ms.

2. **Safety**: Fast-moving machinery requires short scan times for safety functions. A 100ms scan time with a motor at 1800 RPM means 3 shaft revolutions between scans.

3. **Application Limits**:
   - Motion control may need <1ms scan times (special motion PLCs)
   - High-speed counting needs special modules
   - Safety PLCs have guaranteed maximum scan times

4. **Program Size Impact**: Larger programs take longer to execute, increasing scan time. Optimization may be needed for time-critical applications.

5. **Communication Delays**: Network updates typically happen once per scan, affecting data freshness.
</details>

<details><summary>**Question 3**: What are the key differences between PNP and NPN sensor outputs? When would you use each?</summary>

**Answer:**

**PNP (Sourcing):**
- Sensor output sources current TO the load
- When activated, output connects to +V
- Load is connected between sensor output and 0V
- Current flows: +V → Sensor → Output → Load → 0V
- Common in North America and Europe

**NPN (Sinking):**
- Sensor output sinks current FROM the load
- When activated, output connects to 0V (ground)
- Load is connected between sensor output and +V
- Current flows: +V → Load → Output → Sensor → 0V
- Common in Asia (Japan)

**Selection Criteria:**

1. **PLC Input Type**:
   - Sinking PLC inputs work with PNP (sourcing) sensors
   - Sourcing PLC inputs work with NPN (sinking) sensors

2. **Regional Standards**:
   - North America: PNP is standard
   - Europe: PNP is standard
   - Japan/Asia: NPN is common

3. **Safety Considerations**:
   - PNP: A ground fault can cause false ON signal
   - NPN: A ground fault typically causes safe-off condition
   - For safety applications, consider sensor design carefully

4. **Existing Infrastructure**:
   - Match new sensors to existing system type
   - Converting between types requires different PLC input cards
</details>

<details><summary>**Question 4**: A VFD is controlling a 10 HP, 4-pole motor rated at 1750 RPM and 460V at 60Hz. Calculate the motor speed at 30Hz and 45Hz. What voltage should the VFD supply at these frequencies?</summary>

**Answer:**

```{r q4-answer, echo=TRUE}
# Motor parameters
poles <- 4
rated_voltage <- 460  # V
rated_frequency <- 60  # Hz
rated_rpm <- 1750

# Calculate synchronous speed and slip at rated conditions
sync_speed_60 <- 120 * rated_frequency / poles
slip_rpm <- sync_speed_60 - rated_rpm
slip_percent <- (slip_rpm / sync_speed_60) * 100

cat("Motor Analysis:\n")
cat("Synchronous speed at 60Hz:", sync_speed_60, "RPM\n")
cat("Rated speed:", rated_rpm, "RPM\n")
cat("Slip:", slip_rpm, "RPM (", round(slip_percent, 1), "%)\n\n")

# V/Hz ratio
vhz_ratio <- rated_voltage / rated_frequency
cat("V/Hz Ratio:", round(vhz_ratio, 2), "V/Hz\n\n")

# Calculate at 30Hz
freq_30 <- 30
sync_30 <- 120 * freq_30 / poles
speed_30 <- sync_30 - slip_rpm  # Assuming constant slip in RPM
voltage_30 <- freq_30 * vhz_ratio

cat("At 30Hz:\n")
cat("  Synchronous speed:", sync_30, "RPM\n")
cat("  Motor speed (approx):", speed_30, "RPM\n")
cat("  VFD output voltage:", voltage_30, "V\n\n")

# Calculate at 45Hz
freq_45 <- 45
sync_45 <- 120 * freq_45 / poles
speed_45 <- sync_45 - slip_rpm
voltage_45 <- freq_45 * vhz_ratio

cat("At 45Hz:\n")
cat("  Synchronous speed:", sync_45, "RPM\n")
cat("  Motor speed (approx):", speed_45, "RPM\n")
cat("  VFD output voltage:", voltage_45, "V\n")
```

**Note:** The calculation assumes constant slip in RPM, which is an approximation. Actual slip varies somewhat with load and frequency. The V/Hz ratio is maintained constant to provide constant torque capability below base speed.
</details>

<details><summary>**Question 5**: Compare Ethernet/IP and PROFINET. When would you choose each?</summary>

**Answer:**

| Feature | Ethernet/IP | PROFINET |
|---------|-------------|----------|
| **Developer** | ODVA (Rockwell Automation) | PROFIBUS International (Siemens) |
| **Base Protocol** | CIP over TCP/UDP | Based on standard Ethernet |
| **Real-time** | CIP Motion for motion control | IRT (Isochronous Real-Time) |
| **Determinism** | Standard: non-deterministic; CIP Sync: deterministic | RT: soft real-time; IRT: hard real-time |
| **Typical Cycle** | 2-10ms (standard); <1ms (CIP Motion) | 1-10ms (RT); <1ms (IRT) |
| **Ecosystem** | Allen-Bradley, DeviceNet-heritage | Siemens, PROFIBUS-heritage |

**Choose Ethernet/IP when:**
- Using Allen-Bradley/Rockwell PLCs
- Integrating with DeviceNet legacy systems
- Standard industrial Ethernet needs
- North American installations (common)
- Need CIP protocol compatibility

**Choose PROFINET when:**
- Using Siemens PLCs (S7-1200, S7-1500)
- Migrating from PROFIBUS installations
- Need IRT for high-performance motion
- European installations (common)
- Require I-Device functionality

**General Guidance:**
- Match the protocol to your PLC vendor's ecosystem
- Both are capable industrial Ethernet solutions
- Consider existing infrastructure and expertise
- For motion, evaluate specific timing requirements
</details>

<details><summary>**Question 6**: What is the difference between HMI and SCADA? Where would each be used?</summary>

**Answer:**

**HMI (Human-Machine Interface):**
- Local operator interface for a single machine or process
- Typically a touchscreen panel mounted on or near equipment
- Communicates directly with one or few PLCs
- Provides real-time control and monitoring
- Limited data storage (trends, alarms)
- Examples: Allen-Bradley PanelView, Siemens Comfort Panel

**SCADA (Supervisory Control and Data Acquisition):**
- Centralized system monitoring multiple processes/locations
- Server-based architecture with multiple client workstations
- Communicates with many PLCs/RTUs across large distances
- Supervisory control - high-level commands, not direct control
- Extensive historical data collection and analysis
- Examples: Wonderware, Ignition, FactoryTalk View SE

**Where Each is Used:**

| Application | HMI | SCADA |
|-------------|-----|-------|
| Single CNC machine | ✓ | |
| Packaging line | ✓ | |
| Entire factory floor | | ✓ |
| Water treatment plant | ✓ (local) | ✓ (central) |
| Oil pipeline network | | ✓ |
| Building automation | ✓ (per zone) | ✓ (campus-wide) |
| Power grid | | ✓ |

**Key Distinction:** HMI is typically embedded/local for one process; SCADA is a system supervising many processes across the enterprise.
</details>

<details><summary>**Question 7**: Explain what SIL 3 means and give an example of a SIL 3 application.</summary>

**Answer:**

**SIL 3 (Safety Integrity Level 3)** is defined in IEC 61508 and represents:

- **PFD (Probability of Failure on Demand):** 10⁻⁴ to 10⁻³ (0.01% to 0.1%)
- **Risk Reduction Factor:** 1,000 to 10,000
- **Availability:** 99.9% to 99.99%

**What SIL 3 Means:**
- The safety function will fail to operate when needed less than 1 in 1,000 demands
- Requires redundant architecture (typically 2oo3 or 1oo2D)
- Requires certified safety-rated components
- Requires rigorous design, testing, and validation processes
- Requires regular proof testing and maintenance

**SIL 3 Requirements:**
- Hardware fault tolerance ≥ 1 (single fault won't cause dangerous failure)
- Safe Failure Fraction > 90% (for Type A components)
- Systematic capability rating of SC3
- Extensive documentation and lifecycle management

**SIL 3 Application Examples:**

1. **Emergency Shutdown System (ESD)** in oil refinery
   - Detects dangerous conditions (high pressure, fire)
   - Shuts down process and isolates fuel sources
   - Failure could result in explosion and fatalities

2. **Burner Management System (BMS)**
   - Controls furnace/boiler ignition sequence
   - Monitors flame presence and fuel/air ratio
   - Prevents furnace explosions

3. **High Integrity Pressure Protection System (HIPPS)**
   - Prevents overpressure in pipelines
   - Isolates high-pressure source before relief valve capacity exceeded
   - Protects against catastrophic pipeline rupture
</details>

<details><summary>**Question 8**: Describe three benefits of implementing IIoT in a manufacturing facility and give a specific example of each.</summary>

**Answer:**

**1. Predictive Maintenance**

*Benefit:* Detect equipment degradation before failure, enabling planned maintenance during scheduled downtime rather than emergency repairs.

*Example:* Vibration sensors on a conveyor gearbox transmit data to cloud analytics. Machine learning algorithms detect bearing wear signature 3 weeks before expected failure. Maintenance schedules replacement during next planned shutdown, avoiding $50,000 in lost production from unplanned downtime.

**2. Real-Time Production Visibility**

*Benefit:* Instant access to production metrics, OEE, and quality data from anywhere, enabling faster decision-making.

*Example:* Dashboard shows real-time OEE for all production lines on plant manager's tablet. Sudden drop in Line 3 performance triggers alert. Investigation reveals material feed issue; corrected within 30 minutes instead of waiting for end-of-shift report.

**3. Energy Optimization**

*Benefit:* Monitor energy consumption at machine level, identify waste, and optimize based on production schedule.

*Example:* Power meters on each machine report to central system. Analysis reveals HVAC in unused areas runs at full capacity during weekends. Automated scheduling reduces weekend HVAC operation, saving 15% on energy bills ($30,000/year).

**Additional Benefits:**

4. **Quality Traceability** - Every part traced through production with complete process data
5. **Remote Monitoring** - Engineers can diagnose issues without traveling to site
6. **Supply Chain Integration** - Real-time inventory and production data shared with suppliers
</details>

---

## References

1. Bolton, W. (2015). *Programmable Logic Controllers* (6th ed.). Newnes.

2. Petruzella, F.D. (2017). *Programmable Logic Controllers* (5th ed.). McGraw-Hill Education.

3. Rehg, J.A., & Sartori, G.J. (2013). *Industrial Electronics*. Pearson.

4. IEC 61131-3:2013. *Programmable Controllers - Part 3: Programming Languages*.

5. IEC 61508:2010. *Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems*.

6. ODVA. (2020). *The CIP Networks Library*. ODVA, Inc.

7. Siemens AG. (2019). *PROFINET System Description*. Siemens.

8. Gilchrist, A. (2016). *Industry 4.0: The Industrial Internet of Things*. Apress.

9. ISA-95/IEC 62264. *Enterprise-Control System Integration*.

10. Groover, M.P. (2016). *Automation, Production Systems, and Computer-Integrated Manufacturing* (4th ed.). Pearson.

<!--chapter:end:13-Industrial-Automation.Rmd-->

# Quality Management Systems

```{r setup-ch14, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
```

## Learning Objectives

After completing this chapter, you will be able to:

1. Define quality management systems and explain their purpose in manufacturing
2. Describe the structure and requirements of ISO 9001:2015
3. Identify industry-specific quality standards (IATF 16949, AS9100, ISO 22000)
4. Explain the documentation hierarchy and control requirements
5. Conduct internal audits using systematic methodologies
6. Implement effective corrective and preventive action (CAPA) processes
7. Understand management review and continuous improvement requirements
8. Integrate quality tools (SPC, PFMEA, MSA) within a QMS framework

---

## Introduction to Quality Management Systems

A **Quality Management System (QMS)** is a formalized system that documents processes, procedures, and responsibilities for achieving quality policies and objectives. It coordinates and directs an organization's activities to meet customer and regulatory requirements while continuously improving effectiveness.

### Why Implement a QMS?

```{r qms-benefits, echo=FALSE, fig.width=12, fig.height=7}
benefits <- data.frame(
  Category = c("Customer", "Operational", "Financial", "Strategic", "Regulatory", "Cultural"),
  Benefit = c("Customer Satisfaction", "Process Consistency", "Cost Reduction",
              "Market Access", "Compliance", "Employee Engagement"),
  Description = c(
    "Meet customer requirements consistently; reduce complaints",
    "Standardized processes; reduced variation; repeatable results",
    "Less scrap, rework, warranty; improved efficiency",
    "Required for many contracts; competitive advantage",
    "Meet regulatory requirements; reduce liability",
    "Clear expectations; empowerment; pride in quality"
  ),
  Impact = c(90, 85, 80, 88, 75, 70)
)

ggplot(benefits, aes(x = reorder(Category, Impact), y = Impact, fill = Category)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = Benefit), hjust = -0.1, size = 3.5, fontface = "bold") +
  coord_flip() +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  scale_y_continuous(limits = c(0, 120)) +
  labs(title = "Benefits of Implementing a Quality Management System",
       subtitle = "Key drivers for QMS adoption",
       x = "", y = "Relative Impact Score") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 11, face = "bold")
  )
```

### The Evolution of Quality Management

```{r quality-evolution, echo=FALSE}
evolution <- data.frame(
  Era = c("Pre-1900s", "1900-1940s", "1940-1960s", "1960-1980s", "1980-2000s", "2000s-Present"),
  Approach = c("Craftsmanship", "Inspection", "Statistical Quality Control",
               "Quality Assurance", "Total Quality Management", "Integrated Management"),
  Focus = c(
    "Individual skill; master craftsmen",
    "Sort good from bad; end-of-line inspection",
    "Control charts; sampling; Shewhart, Deming",
    "Prevention; systems approach; documented procedures",
    "Company-wide quality; customer focus; continuous improvement",
    "Risk-based thinking; integration with business strategy; digital quality"
  ),
  Key_Figure = c("Guilds", "Taylor", "Shewhart, Deming", "Juran, Feigenbaum",
                 "Crosby, ISO 9000", "ISO 9001:2015, Industry 4.0")
)

kable(evolution, col.names = c("Era", "Approach", "Focus", "Key Figures/Standards"),
      caption = "Evolution of Quality Management") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%") %>%
  row_spec(6, background = "#d5f5e3")
```

### Quality Management Principles

ISO 9000 defines seven quality management principles that form the foundation of all QMS standards:

```{r qm-principles, echo=FALSE, fig.width=12, fig.height=8}
principles <- data.frame(
  principle = c("Customer Focus", "Leadership", "Engagement of People",
                "Process Approach", "Improvement", "Evidence-based\nDecision Making",
                "Relationship\nManagement"),
  number = 1:7,
  description = c(
    "Understand and meet customer needs",
    "Create unity of purpose and direction",
    "Competent, empowered people at all levels",
    "Manage activities as interconnected processes",
    "Ongoing focus on improvement",
    "Decisions based on data analysis",
    "Manage relationships with interested parties"
  ),
  x = c(4, 1, 7, 2.5, 5.5, 2.5, 5.5),
  y = c(4, 2.5, 2.5, 1, 1, -0.5, -0.5)
)

ggplot(principles, aes(x = x, y = y)) +
  geom_point(size = 22, color = "#3498db") +
  geom_text(aes(label = number), color = "white", size = 8, fontface = "bold") +
  geom_text(aes(label = principle, y = y - 0.7), size = 3, fontface = "bold", lineheight = 0.9) +
  # Customer focus at top
  annotate("segment", x = 4, xend = 1, y = 3.5, yend = 2.8,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  annotate("segment", x = 4, xend = 7, y = 3.5, yend = 2.8,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  annotate("segment", x = 4, xend = 2.5, y = 3.5, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  annotate("segment", x = 4, xend = 5.5, y = 3.5, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  coord_cartesian(xlim = c(0, 8), ylim = c(-1.5, 5)) +
  labs(title = "Seven Quality Management Principles (ISO 9000:2015)",
       subtitle = "Customer Focus is the primary principle; others support it") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

---

## ISO 9001:2015 Structure

**ISO 9001:2015** is the international standard for quality management systems. It uses the High-Level Structure (HLS) common to all ISO management system standards.

### The Ten Clauses

```{r iso-clauses, echo=FALSE, fig.width=12, fig.height=9}
clauses <- data.frame(
  clause = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"),
  title = c("Scope", "Normative References", "Terms and Definitions",
            "Context of the Organization", "Leadership", "Planning",
            "Support", "Operation", "Performance Evaluation", "Improvement"),
  description = c(
    "Defines applicability of the standard",
    "References to ISO 9000:2015",
    "Definitions used in the standard",
    "Understanding the organization and its context",
    "Top management commitment and policy",
    "Actions to address risks and opportunities",
    "Resources, competence, awareness, communication",
    "Operational planning and control",
    "Monitoring, measurement, analysis, evaluation",
    "Nonconformity, corrective action, continual improvement"
  ),
  type = c("Intro", "Intro", "Intro", "Core", "Core", "Core",
           "Core", "Core", "Core", "Core"),
  y = c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
)

ggplot(clauses, aes(x = 1, y = y)) +
  geom_tile(aes(fill = type), width = 4, height = 0.8, color = "white", size = 1) +
  geom_text(aes(x = -0.3, label = clause), fontface = "bold", size = 5, color = "#2c3e50") +
  geom_text(aes(x = 0.3, label = title), fontface = "bold", size = 3.5, hjust = 0, color = "white") +
  geom_text(aes(x = 2.8, label = description), size = 2.8, hjust = 1, color = "white") +
  scale_fill_manual(values = c("Intro" = "#95a5a6", "Core" = "#3498db"), guide = "none") +
  coord_cartesian(xlim = c(-1, 3.5)) +
  labs(title = "ISO 9001:2015 Structure - The Ten Clauses",
       subtitle = "Clauses 4-10 contain the auditable requirements") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### The Process Approach and PDCA

ISO 9001:2015 emphasizes the **process approach** combined with the **Plan-Do-Check-Act (PDCA)** cycle:

```{r pdca-cycle, echo=FALSE, fig.width=11, fig.height=8}
ggplot() +
  # PDCA circle

  annotate("path",
           x = 5 + 3 * cos(seq(0, 2*pi, length.out = 100)),
           y = 5 + 3 * sin(seq(0, 2*pi, length.out = 100)),
           color = "gray70", size = 2) +

  # Plan quadrant
  annotate("path",
           x = 5 + 3 * cos(seq(pi/2, pi, length.out = 50)),
           y = 5 + 3 * sin(seq(pi/2, pi, length.out = 50)),
           color = "#3498db", size = 4) +
  annotate("point", x = 5 - 2.1, y = 5 + 2.1, size = 20, color = "#3498db") +
  annotate("text", x = 5 - 2.1, y = 5 + 2.1, label = "PLAN", color = "white",
           fontface = "bold", size = 5) +
  annotate("text", x = 2.2, y = 7.5, label = "Clause 4: Context\nClause 5: Leadership\nClause 6: Planning",
           size = 3, hjust = 0, lineheight = 0.9) +

  # Do quadrant
  annotate("path",
           x = 5 + 3 * cos(seq(0, pi/2, length.out = 50)),
           y = 5 + 3 * sin(seq(0, pi/2, length.out = 50)),
           color = "#27ae60", size = 4) +
  annotate("point", x = 5 + 2.1, y = 5 + 2.1, size = 20, color = "#27ae60") +
  annotate("text", x = 5 + 2.1, y = 5 + 2.1, label = "DO", color = "white",
           fontface = "bold", size = 5) +
  annotate("text", x = 7.8, y = 7.5, label = "Clause 7: Support\nClause 8: Operation",
           size = 3, hjust = 1, lineheight = 0.9) +

  # Check quadrant
  annotate("path",
           x = 5 + 3 * cos(seq(-pi/2, 0, length.out = 50)),
           y = 5 + 3 * sin(seq(-pi/2, 0, length.out = 50)),
           color = "#f39c12", size = 4) +
  annotate("point", x = 5 + 2.1, y = 5 - 2.1, size = 20, color = "#f39c12") +
  annotate("text", x = 5 + 2.1, y = 5 - 2.1, label = "CHECK", color = "white",
           fontface = "bold", size = 4.5) +
  annotate("text", x = 7.8, y = 2.5, label = "Clause 9: Performance\nEvaluation",
           size = 3, hjust = 1, lineheight = 0.9) +

  # Act quadrant
  annotate("path",
           x = 5 + 3 * cos(seq(pi, 3*pi/2, length.out = 50)),
           y = 5 + 3 * sin(seq(pi, 3*pi/2, length.out = 50)),
           color = "#e74c3c", size = 4) +
  annotate("point", x = 5 - 2.1, y = 5 - 2.1, size = 20, color = "#e74c3c") +
  annotate("text", x = 5 - 2.1, y = 5 - 2.1, label = "ACT", color = "white",
           fontface = "bold", size = 5) +
  annotate("text", x = 2.2, y = 2.5, label = "Clause 10: Improvement",
           size = 3, hjust = 0, lineheight = 0.9) +

  # Center
  annotate("text", x = 5, y = 5, label = "QMS", fontface = "bold", size = 6) +

  # Arrows showing cycle direction
  annotate("segment", x = 3, xend = 2.5, y = 6.5, yend = 5.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.2, color = "gray40") +
  annotate("segment", x = 7, xend = 7.5, y = 6.5, yend = 5.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.2, color = "gray40") +
  annotate("segment", x = 7.5, xend = 7, y = 4.5, yend = 3.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.2, color = "gray40") +
  annotate("segment", x = 2.5, xend = 3, y = 4.5, yend = 3.5,
           arrow = arrow(length = unit(0.3, "cm")), size = 1.2, color = "gray40") +

  coord_cartesian(xlim = c(1, 9), ylim = c(1, 9)) +
  labs(title = "PDCA Cycle and ISO 9001:2015 Clauses",
       subtitle = "The continuous improvement cycle embedded in the standard") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Risk-Based Thinking

ISO 9001:2015 introduced **risk-based thinking** throughout the QMS:

```{r risk-based, echo=FALSE}
risk_table <- data.frame(
  Clause = c("4.1", "4.2", "6.1", "8.1", "9.1", "10.2"),
  Requirement = c(
    "Context of the Organization",
    "Interested Parties",
    "Actions to Address Risks and Opportunities",
    "Operational Planning and Control",
    "Monitoring and Measurement",
    "Nonconformity and Corrective Action"
  ),
  Risk_Application = c(
    "Identify internal/external issues that could affect QMS outcomes",
    "Understand needs/expectations that could impact quality",
    "Plan actions to address risks and opportunities; integrate into processes",
    "Control processes considering risks identified in planning",
    "Monitor effectiveness of actions taken to address risks",
    "Analyze nonconformities; update risks/opportunities as needed"
  )
)

kable(risk_table, caption = "Risk-Based Thinking in ISO 9001:2015") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "10%") %>%
  column_spec(2, width = "25%")
```

<details><summary>**Understanding Risk-Based Thinking**</summary>

**Risk-based thinking** doesn't require formal risk management (like FMEA for every process), but rather:

1. **Consider risks** when designing and implementing the QMS
2. **Preventive action** is built into the system, not a separate activity
3. **Proportional response** - more rigorous controls for higher-risk processes
4. **Opportunities** are also considered (not just negative risks)

**Example:** A food manufacturer identifies "allergen cross-contamination" as a significant risk. Risk-based thinking leads them to:
- Dedicated production lines for allergen-containing products
- Enhanced cleaning verification procedures
- Staff training on allergen awareness
- Increased inspection frequency after changeovers

The extent of controls is proportional to the risk level.
</details>

---

## Industry-Specific Quality Standards

Different industries have developed standards that build upon ISO 9001 with additional sector-specific requirements.

### Comparison of Major Standards

```{r standards-comparison, echo=FALSE, fig.width=12, fig.height=7}
standards <- data.frame(
  Standard = c("ISO 9001:2015", "IATF 16949:2016", "AS9100D", "ISO 22000:2018"),
  Industry = c("General", "Automotive", "Aerospace/Defense", "Food Safety"),
  Base = c("Standalone", "ISO 9001 + Automotive", "ISO 9001 + Aerospace", "ISO 9001 + HACCP"),
  x = c(1, 2, 3, 4),
  y = c(1, 1, 1, 1)
)

ggplot(standards, aes(x = x, y = y)) +
  geom_tile(aes(fill = Standard), width = 0.9, height = 1.5, color = "white", size = 2) +
  geom_text(aes(label = Standard), fontface = "bold", size = 4, color = "white", vjust = -1) +
  geom_text(aes(label = Industry), size = 3.5, color = "white") +
  geom_text(aes(label = Base), size = 2.8, color = "white", vjust = 2, lineheight = 0.9) +
  scale_fill_manual(values = c("#3498db", "#e74c3c", "#2c3e50", "#27ae60"), guide = "none") +
  labs(title = "Major Quality Management System Standards",
       subtitle = "Industry-specific standards build upon ISO 9001") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### IATF 16949:2016 (Automotive)

**IATF 16949** is the automotive quality standard, required by most major OEMs (Ford, GM, Toyota, VW, etc.).

```{r iatf-additions, echo=FALSE}
iatf_requirements <- data.frame(
  Area = c("Product Safety", "APQP/PPAP", "Control Plans", "MSA", "SPC",
           "Supplier Quality", "Warranty Management", "Manufacturing Feasibility"),
  ISO_9001 = c("Implied", "Not specified", "Not specified", "General requirement",
               "General requirement", "Basic purchasing", "Complaint handling", "Review of requirements"),
  IATF_16949 = c(
    "Explicit requirements for product safety processes",
    "APQP phases required; PPAP submission mandatory",
    "Control plans required for all parts; specific format",
    "MSA studies required per AIAG MSA manual",
    "SPC for all special characteristics",
    "Supplier development; second-party audits; IATF certification flow-down",
    "NTF analysis; warranty data analysis; field return analysis",
    "Documented manufacturing feasibility review"
  )
)

kable(iatf_requirements, col.names = c("Requirement Area", "ISO 9001", "IATF 16949 Addition"),
      caption = "IATF 16949 Additional Requirements Beyond ISO 9001") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  column_spec(2, background = "#fadbd8") %>%
  column_spec(3, background = "#d5f5e3")
```

### Automotive Core Tools

IATF 16949 requires the use of **five core tools**:

```{r core-tools, echo=FALSE, fig.width=12, fig.height=6}
core_tools <- data.frame(
  tool = c("APQP", "PPAP", "FMEA", "MSA", "SPC"),
  name = c("Advanced Product\nQuality Planning",
           "Production Part\nApproval Process",
           "Failure Mode &\nEffects Analysis",
           "Measurement\nSystems Analysis",
           "Statistical\nProcess Control"),
  purpose = c("Plan and define quality program",
              "Demonstrate production capability",
              "Identify and mitigate risks",
              "Ensure measurement validity",
              "Monitor and control processes"),
  x = 1:5
)

ggplot(core_tools, aes(x = x, y = 1)) +
  geom_tile(aes(fill = tool), width = 0.85, height = 1.5, color = "white", size = 1.5) +
  geom_text(aes(label = tool), fontface = "bold", size = 5, color = "white", vjust = -1) +
  geom_text(aes(label = name), size = 3, color = "white", lineheight = 0.9) +
  geom_text(aes(label = purpose, y = 0.3), size = 2.5, color = "white", lineheight = 0.9) +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60", "#f39c12", "#9b59b6"),
                    guide = "none") +
  labs(title = "AIAG Automotive Core Tools",
       subtitle = "Five essential tools required by IATF 16949") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### AS9100D (Aerospace/Defense)

**AS9100D** adds aerospace-specific requirements to ISO 9001:

```{r as9100-additions, echo=FALSE}
as9100_req <- data.frame(
  Area = c("Configuration Management", "First Article Inspection",
           "Counterfeit Parts Prevention", "Special Processes",
           "Product Safety", "Risk Management", "Human Factors"),
  Requirement = c(
    "Control product configuration throughout lifecycle; change management",
    "FAI per AS9102; documented verification of first production parts",
    "Controls to prevent counterfeit parts entering supply chain",
    "NADCAP accreditation for special processes (welding, heat treat, NDT)",
    "Product safety requirements; reporting of unsafe conditions",
    "Explicit risk management process (often using AS/NZS 4360 or similar)",
    "Consideration of human factors in process design"
  )
)

kable(as9100_req, caption = "AS9100D Key Additional Requirements") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "25%")
```

### ISO 22000:2018 (Food Safety)

**ISO 22000** integrates quality management with **HACCP** (Hazard Analysis Critical Control Points):

```{r iso22000-structure, echo=FALSE}
iso22000_elements <- data.frame(
  Element = c("Prerequisite Programs (PRPs)", "Operational PRPs (OPRPs)",
              "HACCP Plan", "Traceability", "Emergency Preparedness",
              "Validation and Verification"),
  Description = c(
    "Basic hygiene conditions: cleaning, pest control, personnel hygiene, facility design",
    "PRPs essential to control specific identified hazards",
    "Critical Control Points (CCPs) for significant hazards; critical limits; monitoring",
    "One-step-back, one-step-forward traceability; recall procedures",
    "Procedures for food safety emergencies; recall/withdrawal",
    "Validate control measures; verify HACCP plan effectiveness"
  ),
  Example = c(
    "Sanitation schedule, hand washing stations, pest control contract",
    "Metal detector for physical hazard control",
    "Pasteurization temperature ≥72°C for 15 seconds",
    "Lot coding, supplier records, distribution records",
    "Product recall procedure, mock recall exercises",
    "Challenge studies, environmental monitoring, internal audits"
  )
)

kable(iso22000_elements, caption = "ISO 22000 Food Safety Management Elements") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "22%")
```

---

## Documentation Requirements

A QMS requires documented information to ensure consistency, provide evidence, and enable improvement.

### Documentation Hierarchy

```{r doc-hierarchy, echo=FALSE, fig.width=11, fig.height=8}
ggplot() +
  # Level 1 - Policy
  annotate("polygon", x = c(5, 3, 7), y = c(7, 5.5, 5.5),
           fill = "#e74c3c", color = "black") +
  annotate("text", x = 5, y = 6.2, label = "Level 1\nQuality Policy\n& Objectives",
           color = "white", fontface = "bold", size = 3.5, lineheight = 0.9) +

  # Level 2 - Manual/Procedures
  annotate("polygon", x = c(5, 2, 8), y = c(5.3, 3.5, 3.5),
           fill = "#f39c12", color = "black") +
  annotate("text", x = 5, y = 4.3, label = "Level 2\nQuality Manual & Procedures\nWhat we do and who is responsible",
           color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Level 3 - Work Instructions
  annotate("polygon", x = c(5, 1, 9), y = c(3.3, 1.5, 1.5),
           fill = "#3498db", color = "black") +
  annotate("text", x = 5, y = 2.3, label = "Level 3\nWork Instructions, SOPs, Specifications\nHow we do it - step by step details",
           color = "white", fontface = "bold", size = 3, lineheight = 0.9) +

  # Level 4 - Records
  annotate("rect", xmin = 0.5, xmax = 9.5, ymin = 0.3, ymax = 1.3,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 5, y = 0.8, label = "Level 4: Records & Forms - Evidence that we did it",
           color = "white", fontface = "bold", size = 3.5) +

  # Examples on the right
  annotate("text", x = 9, y = 6.2, label = "• Quality Policy statement\n• Quality objectives",
           hjust = 0, size = 2.8, lineheight = 0.9) +
  annotate("text", x = 9, y = 4.3, label = "• Document control procedure\n• Corrective action procedure\n• Internal audit procedure",
           hjust = 0, size = 2.8, lineheight = 0.9) +
  annotate("text", x = 9, y = 2.3, label = "• Setup instructions\n• Inspection checklists\n• Calibration procedures",
           hjust = 0, size = 2.8, lineheight = 0.9) +
  annotate("text", x = 9, y = 0.8, label = "• Inspection records • Training records • Audit reports",
           hjust = 0, size = 2.8) +

  coord_cartesian(xlim = c(0, 13), ylim = c(0, 7.5)) +
  labs(title = "Quality Documentation Hierarchy",
       subtitle = "From policy (strategic) to records (evidence)") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Document Control Requirements

```{r doc-control, echo=FALSE}
doc_control <- data.frame(
  Requirement = c("Approval", "Review & Update", "Identification",
                  "Availability", "Protection", "Obsolete Control",
                  "External Documents", "Record Retention"),
  Description = c(
    "Documents reviewed and approved for adequacy before issue",
    "Reviewed, updated as necessary, and re-approved",
    "Identified with title, date, revision, author",
    "Relevant versions available at points of use",
    "Protected from loss, damage, unauthorized changes",
    "Obsolete documents identified and prevented from unintended use",
    "External documents identified and distribution controlled",
    "Records retained for specified periods; protected; retrievable"
  ),
  Implementation = c(
    "Approval signatures or electronic workflow",
    "Periodic review schedule; change request process",
    "Document numbering system; revision control",
    "Controlled copies at workstations; electronic access",
    "Backup systems; access controls; original storage",
    "Stamp 'OBSOLETE'; remove from use; archive",
    "List of external documents; master copy control",
    "Retention matrix; secure storage; indexing"
  )
)

kable(doc_control, caption = "Document Control Requirements (ISO 9001 Clause 7.5)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Documented Information Required by ISO 9001:2015

```{r mandatory-docs, echo=FALSE}
mandatory <- data.frame(
  Type = c(rep("Documents (shall be maintained)", 7),
           rep("Records (shall be retained)", 10)),
  Clause = c("4.3", "5.2", "6.2", "7.1.5", "7.2", "8.1", "8.5.1",
             "7.1.5.1", "7.2", "8.2.3.2", "8.3.3", "8.3.4", "8.3.5", "8.3.6",
             "8.5.2", "8.6", "9.1.1"),
  Requirement = c(
    "Scope of the QMS",
    "Quality policy",
    "Quality objectives",
    "Monitoring and measuring resources (calibration)",
    "Evidence of competence",
    "Evidence of conformity to processes",
    "Controlled conditions for production",
    "Calibration/verification results",
    "Training records",
    "Results of review of requirements",
    "Design and development inputs",
    "Design and development controls",
    "Design and development outputs",
    "Design and development changes",
    "Traceability requirements",
    "Release of products/services",
    "Results of monitoring and measurement"
  )
)

kable(mandatory, caption = "Documented Information Required by ISO 9001:2015") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "25%") %>%
  pack_rows("Documents (shall be maintained)", 1, 7, background = "#ebf5fb") %>%
  pack_rows("Records (shall be retained)", 8, 17, background = "#eafaf1")
```

---

## Internal Auditing

**Internal audits** are systematic, independent evaluations of the QMS to determine if it conforms to requirements and is effectively implemented.

### The Audit Process

```{r audit-process, echo=FALSE, fig.width=12, fig.height=6}
audit_steps <- data.frame(
  step = 1:7,
  name = c("Planning", "Preparation", "Opening Meeting",
           "Audit Execution", "Closing Meeting", "Reporting", "Follow-up"),
  description = c(
    "Schedule audits; assign auditors",
    "Review documents; prepare checklist",
    "Explain purpose, scope, methods",
    "Collect evidence; interview; observe",
    "Present findings; discuss",
    "Issue audit report",
    "Verify corrective actions"
  ),
  x = 1:7
)

ggplot(audit_steps, aes(x = x, y = 1)) +
  geom_point(size = 15, color = "#3498db") +
  geom_text(aes(label = step), color = "white", fontface = "bold", size = 5) +
  geom_text(aes(label = name, y = 0.5), size = 3, fontface = "bold", angle = 45, hjust = 1) +
  geom_text(aes(label = description, y = 1.5), size = 2.5, lineheight = 0.9) +
  geom_segment(aes(x = x + 0.3, xend = x + 0.7, y = 1, yend = 1),
               data = audit_steps[1:6,],
               arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  scale_x_continuous(limits = c(0.5, 7.5)) +
  scale_y_continuous(limits = c(0, 2)) +
  labs(title = "Internal Audit Process Flow",
       subtitle = "Systematic approach to evaluating QMS effectiveness") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Audit Checklist Example

```{r audit-checklist, echo=FALSE}
checklist <- data.frame(
  Clause = c("7.1.5", "7.1.5", "7.1.5", "7.1.5", "7.1.5.2"),
  Requirement = c(
    "Monitoring and measuring resources suitable for the type of activities",
    "Resources maintained to ensure continued fitness for purpose",
    "Documented information on fitness for purpose retained",
    "Measuring equipment identified to determine status",
    "Measurement traceability when required"
  ),
  Question = c(
    "How do you determine what measuring equipment is needed?",
    "What maintenance is performed on measuring equipment?",
    "Can you show me calibration records for this micrometer?",
    "How can I tell if this gauge is currently calibrated?",
    "What standards are these gauges calibrated against?"
  ),
  Evidence = c("Gauge selection procedure", "PM records", "Calibration certificate",
               "Calibration stickers/tags", "Traceability certificates")
)

kable(checklist, caption = "Sample Audit Checklist: Clause 7.1.5 Monitoring and Measuring Resources") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "8%")
```

### Types of Audit Findings

```{r finding-types, echo=FALSE}
findings <- data.frame(
  Type = c("Major Nonconformity", "Minor Nonconformity", "Observation",
           "Opportunity for Improvement"),
  Definition = c(
    "Absence or total breakdown of a system; significant risk to product/customer",
    "Single lapse or isolated incident; system exists but not fully effective",
    "Weakness that could lead to nonconformity if not addressed",
    "Suggestion for enhancement; not a nonconformity"
  ),
  Example = c(
    "No calibration program exists; all gauges are uncontrolled",
    "3 of 50 gauges found past due for calibration",
    "Calibration procedure doesn't specify what to do if gauge fails",
    "Consider using electronic calibration records for faster retrieval"
  ),
  Action_Required = c(
    "Immediate corrective action; root cause analysis; may affect certification",
    "Corrective action required; typically 30-90 days",
    "No formal corrective action; monitor situation",
    "Consider for improvement; no requirement"
  )
)

kable(findings, col.names = c("Finding Type", "Definition", "Example", "Action Required"),
      caption = "Types of Audit Findings") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  row_spec(1, background = "#f8d7da") %>%
  row_spec(2, background = "#fff3cd") %>%
  row_spec(3, background = "#d1ecf1") %>%
  row_spec(4, background = "#d4edda")
```

### Auditor Competence

```{r auditor-competence, echo=FALSE}
auditor_skills <- data.frame(
  Competency = c("Knowledge of Standards", "Audit Techniques", "Industry Knowledge",
                 "Communication Skills", "Objectivity", "Professional Judgment"),
  Description = c(
    "Understanding of ISO 9001 and applicable industry standards",
    "Planning, interviewing, evidence collection, reporting",
    "Understanding of processes, products, and industry practices",
    "Active listening, clear questioning, professional writing",
    "Independence from area being audited; impartial",
    "Ability to evaluate significance of findings"
  ),
  How_Developed = c(
    "Training courses; self-study; certification (CQA, Lead Auditor)",
    "Auditor training; shadowing experienced auditors",
    "Work experience; process knowledge; technical training",
    "Practice; feedback; soft skills training",
    "Audit program design; rotation of assignments",
    "Experience; mentoring; calibration with other auditors"
  )
)

kable(auditor_skills, caption = "Internal Auditor Competency Requirements") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

---

## Corrective and Preventive Action (CAPA)

**Corrective action** eliminates the cause of a detected nonconformity to prevent recurrence. **Preventive action** eliminates the cause of a potential nonconformity to prevent occurrence.

### The CAPA Process

```{r capa-process, echo=FALSE, fig.width=12, fig.height=8}
capa_steps <- data.frame(
  step = 1:8,
  name = c("Identification", "Evaluation", "Investigation",
           "Root Cause", "Action Plan", "Implementation",
           "Verification", "Closure"),
  description = c(
    "Identify the nonconformity\nor potential issue",
    "Assess significance;\ncontainment if needed",
    "Gather data and\nevidence",
    "Determine root cause(s)\nusing RCA tools",
    "Define corrective/\npreventive actions",
    "Execute action plan;\nassign responsibility",
    "Verify actions completed\nand effective",
    "Document and close;\nshare lessons learned"
  ),
  y = c(4, 4, 4, 4, 2, 2, 2, 2),
  x = c(1, 2, 3, 4, 4, 3, 2, 1)
)

ggplot(capa_steps, aes(x = x, y = y)) +
  geom_tile(aes(fill = step), width = 0.9, height = 1.5, color = "white", size = 1) +
  geom_text(aes(label = paste0(step, ". ", name)), fontface = "bold",
            size = 3, color = "white", vjust = -0.5) +
  geom_text(aes(label = description), size = 2.5, color = "white",
            vjust = 1, lineheight = 0.85) +
  # Arrows showing flow
  annotate("segment", x = 1.5, xend = 1.9, y = 4, yend = 4,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 2.9, y = 4, yend = 4,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 3.5, xend = 3.9, y = 4, yend = 4,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 4, xend = 4, y = 3.2, yend = 2.8,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 3.5, xend = 3.1, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 2.5, xend = 2.1, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("segment", x = 1.5, xend = 1.1, y = 2, yend = 2,
           arrow = arrow(length = unit(0.2, "cm"))) +
  scale_fill_gradient(low = "#27ae60", high = "#3498db", guide = "none") +
  coord_cartesian(xlim = c(0.3, 4.7), ylim = c(1, 5)) +
  labs(title = "CAPA Process Flow",
       subtitle = "Eight-step process for effective corrective and preventive action") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### CAPA Effectiveness Criteria

```{r capa-effectiveness, echo=TRUE}
# CAPA Effectiveness Tracking
set.seed(42)

# Simulate CAPA data for a year
months <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

capa_data <- data.frame(
  Month = factor(months, levels = months),
  Total_CAPAs = c(12, 15, 18, 14, 11, 13, 10, 9, 8, 7, 9, 6),
  Closed_On_Time = c(8, 10, 12, 11, 9, 11, 9, 8, 7, 6, 8, 5),
  Effective = c(7, 9, 10, 10, 8, 10, 8, 8, 7, 6, 8, 5),
  Recurrence = c(2, 1, 3, 1, 0, 1, 0, 0, 1, 0, 0, 0)
)

# Calculate metrics
capa_data$On_Time_Rate <- round(capa_data$Closed_On_Time / capa_data$Total_CAPAs * 100, 1)
capa_data$Effectiveness_Rate <- round(capa_data$Effective / capa_data$Closed_On_Time * 100, 1)

cat("CAPA Performance Metrics Summary:\n")
cat("─────────────────────────────────\n")
cat("Total CAPAs initiated:", sum(capa_data$Total_CAPAs), "\n")
cat("Closed on time:", sum(capa_data$Closed_On_Time), "(",
    round(sum(capa_data$Closed_On_Time)/sum(capa_data$Total_CAPAs)*100, 1), "%)\n")
cat("Verified effective:", sum(capa_data$Effective), "(",
    round(sum(capa_data$Effective)/sum(capa_data$Closed_On_Time)*100, 1), "%)\n")
cat("Recurrences:", sum(capa_data$Recurrence), "\n")
```

```{r capa-chart, echo=FALSE, fig.width=11, fig.height=6}
capa_long <- capa_data %>%
  select(Month, Total_CAPAs, Closed_On_Time, Effective) %>%
  pivot_longer(cols = -Month, names_to = "Metric", values_to = "Count")

ggplot(capa_long, aes(x = Month, y = Count, fill = Metric)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_line(data = capa_data, aes(x = Month, y = Recurrence * 5, group = 1),
            color = "red", size = 1.2, inherit.aes = FALSE) +
  geom_point(data = capa_data, aes(x = Month, y = Recurrence * 5),
             color = "red", size = 3, inherit.aes = FALSE) +
  scale_fill_manual(values = c("#e74c3c", "#f39c12", "#27ae60"),
                    labels = c("Closed On Time", "Verified Effective", "Total CAPAs")) +
  scale_y_continuous(sec.axis = sec_axis(~./5, name = "Recurrences")) +
  labs(title = "CAPA Performance Tracking",
       subtitle = "Monthly CAPA metrics with recurrence trend (red line)",
       x = "", y = "Number of CAPAs", fill = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom"
  )
```

---

## Management Review

**Management review** is a formal evaluation of the QMS by top management to ensure its continuing suitability, adequacy, and effectiveness.

### Management Review Inputs

```{r mgmt-review-inputs, echo=FALSE}
review_inputs <- data.frame(
  Input = c("Previous Review Actions", "Changes in Issues/Context",
            "Quality Performance", "Resource Adequacy",
            "Risk/Opportunity Actions", "Improvement Opportunities"),
  Details = c(
    "Status of actions from previous management reviews",
    "Changes in external/internal issues; interested party requirements",
    "Customer satisfaction; quality objectives achievement; process performance; nonconformities; audits; supplier performance",
    "Adequacy of resources for QMS maintenance and improvement",
    "Effectiveness of actions taken to address risks and opportunities",
    "Opportunities for improvement identified from various sources"
  ),
  Data_Sources = c(
    "Previous meeting minutes; action log",
    "SWOT analysis; customer feedback; regulatory changes",
    "KPI dashboards; audit reports; CAPA data; customer complaints",
    "Budget status; staffing levels; equipment condition",
    "Risk register updates; opportunity tracking",
    "Employee suggestions; benchmarking; industry developments"
  )
)

kable(review_inputs, col.names = c("Required Input", "Details to Review", "Typical Data Sources"),
      caption = "Management Review Inputs (ISO 9001 Clause 9.3.2)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

### Management Review Outputs

```{r mgmt-review-outputs, echo=FALSE}
review_outputs <- data.frame(
  Output = c("Improvement Decisions", "QMS Changes", "Resource Needs"),
  Requirement = c(
    "Decisions and actions related to improvement opportunities",
    "Any need for changes to the QMS",
    "Any resource needs"
  ),
  Examples = c(
    "Launch kaizen project for top 3 customer complaints; implement new quality training program",
    "Revise control plan based on PFMEA update; modify inspection frequency",
    "Hire additional quality technician; purchase new CMM; upgrade software"
  )
)

kable(review_outputs, col.names = c("Required Output", "ISO Requirement", "Examples"),
      caption = "Management Review Outputs (ISO 9001 Clause 9.3.3)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

### Sample Management Review Dashboard

```{r mgmt-dashboard, echo=FALSE, fig.width=12, fig.height=10}
# Create a sample management review dashboard
par(mfrow = c(2, 2))

# Data for dashboard
set.seed(123)

# Quality Objectives
objectives <- data.frame(
  Objective = c("Customer\nComplaints", "On-Time\nDelivery", "First Pass\nYield", "Scrap\nRate"),
  Target = c(5, 98, 95, 2),
  Actual = c(3, 97.5, 96.2, 1.8),
  x = 1:4
)

p1 <- ggplot(objectives, aes(x = x)) +
  geom_bar(aes(y = Target), stat = "identity", fill = "gray80", width = 0.4, position = position_nudge(x = -0.2)) +
  geom_bar(aes(y = Actual), stat = "identity", fill = "#27ae60", width = 0.4, position = position_nudge(x = 0.2)) +
  geom_text(aes(y = 0, label = Objective), vjust = 1.5, size = 3, lineheight = 0.8) +
  labs(title = "Quality Objectives: Target vs Actual", x = "", y = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), plot.title = element_text(face = "bold", size = 11))

# Customer Satisfaction Trend
satisfaction <- data.frame(
  Quarter = c("Q1", "Q2", "Q3", "Q4"),
  Score = c(4.2, 4.3, 4.5, 4.6)
)

p2 <- ggplot(satisfaction, aes(x = Quarter, y = Score, group = 1)) +
  geom_line(color = "#3498db", size = 1.5) +
  geom_point(color = "#3498db", size = 4) +
  geom_hline(yintercept = 4.0, linetype = "dashed", color = "red") +
  annotate("text", x = 4.2, y = 4.0, label = "Target", color = "red", size = 3) +
  scale_y_continuous(limits = c(3.5, 5)) +
  labs(title = "Customer Satisfaction Trend", x = "", y = "Score (1-5)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 11))

# Audit Findings
audit_data <- data.frame(
  Type = c("Major NC", "Minor NC", "Observations", "OFIs"),
  Count = c(0, 3, 5, 8)
)

p3 <- ggplot(audit_data, aes(x = Type, y = Count, fill = Type)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_text(aes(label = Count), vjust = -0.5, size = 4) +
  scale_fill_manual(values = c("Major NC" = "#e74c3c", "Minor NC" = "#f39c12",
                               "Observations" = "#3498db", "OFIs" = "#27ae60"),
                    guide = "none") +
  labs(title = "Internal Audit Findings (YTD)", x = "", y = "Count") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 11))

# CAPA Status
capa_status <- data.frame(
  Status = c("Open", "In Progress", "Verification", "Closed"),
  Count = c(5, 12, 8, 45)
)

p4 <- ggplot(capa_status, aes(x = "", y = Count, fill = Status)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = paste0(Count, "\n(", round(Count/sum(Count)*100), "%)")),
            position = position_stack(vjust = 0.5), color = "white", size = 3) +
  scale_fill_manual(values = c("#e74c3c", "#f39c12", "#3498db", "#27ae60")) +
  labs(title = "CAPA Status Distribution", fill = "") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 11, hjust = 0.5))

gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 2,
                        top = grid::textGrob("Management Review Dashboard",
                                             gp = grid::gpar(fontface = "bold", fontsize = 14)))
```

---

## Continuous Improvement

**Continuous improvement** is a fundamental principle of quality management - the ongoing effort to improve products, services, and processes.

### Improvement Methodologies

```{r improvement-methods, echo=FALSE}
methods <- data.frame(
  Methodology = c("PDCA", "DMAIC", "Kaizen", "A3 Problem Solving", "8D"),
  Origin = c("Deming/Shewhart", "Six Sigma", "Toyota/Lean", "Toyota", "Ford"),
  Best_For = c(
    "General improvement cycle; process changes",
    "Data-driven problem solving; reducing variation",
    "Small, incremental improvements; team-based",
    "Visual problem solving; root cause analysis",
    "Customer complaints; complex problems"
  ),
  Steps = c(
    "Plan-Do-Check-Act",
    "Define-Measure-Analyze-Improve-Control",
    "Identify waste → Improve → Standardize",
    "Background → Goals → Analysis → Countermeasures → Follow-up",
    "D0-D8 (Team, Problem, Containment, Root Cause, Actions, Verify, Prevent, Close)"
  )
)

kable(methods, caption = "Continuous Improvement Methodologies") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%")
```

### Key Performance Indicators (KPIs)

```{r kpi-examples, echo=FALSE}
kpis <- data.frame(
  Category = c(rep("Quality", 4), rep("Delivery", 3), rep("Cost", 3), rep("Safety", 2)),
  KPI = c("First Pass Yield (FPY)", "Customer Complaints (PPM)", "Internal Reject Rate", "Cost of Quality",
          "On-Time Delivery (OTD)", "Lead Time", "Order Fulfillment Rate",
          "Scrap Rate", "Rework Cost", "Warranty Cost",
          "Recordable Incident Rate", "Near Miss Reports"),
  Formula = c(
    "(Good units first time / Total units) × 100%",
    "(Complaints / Units shipped) × 1,000,000",
    "(Rejected units / Total inspected) × 100%",
    "Prevention + Appraisal + Internal Failure + External Failure",
    "(Orders delivered on time / Total orders) × 100%",
    "Order date to delivery date",
    "(Complete orders shipped / Total orders) × 100%",
    "(Scrap value / Total production value) × 100%",
    "Labor + Material for rework",
    "Warranty claims cost / Revenue",
    "(Recordable incidents × 200,000) / Hours worked",
    "Count of near miss reports"
  ),
  Target = c("≥98%", "<100", "<1%", "<3% of sales",
             "≥98%", "Industry benchmark", "≥99%",
             "<2%", "Minimize", "<0.5% of sales",
             "<1.0", "Encourage reporting")
)

kable(kpis, caption = "Common Quality Management KPIs") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "10%") %>%
  pack_rows("Quality Metrics", 1, 4, background = "#ebf5fb") %>%
  pack_rows("Delivery Metrics", 5, 7, background = "#eafaf1") %>%
  pack_rows("Cost Metrics", 8, 10, background = "#fef9e7") %>%
  pack_rows("Safety Metrics", 11, 12, background = "#fdedec")
```

### Cost of Quality (COQ)

```{r coq-analysis, echo=TRUE}
# Cost of Quality Analysis
coq_data <- data.frame(
  Category = c("Prevention", "Appraisal", "Internal Failure", "External Failure"),
  Description = c("Quality planning, training, process control",
                  "Inspection, testing, audits, calibration",
                  "Scrap, rework, reinspection, downtime",
                  "Warranty, returns, complaints, recalls"),
  Cost = c(50000, 75000, 120000, 180000)
)

total_coq <- sum(coq_data$Cost)
revenue <- 10000000  # $10M revenue

coq_data$Percent_of_COQ <- round(coq_data$Cost / total_coq * 100, 1)
coq_data$Percent_of_Revenue <- round(coq_data$Cost / revenue * 100, 2)

cat("Cost of Quality Analysis:\n")
cat("─────────────────────────────\n")
print(coq_data[, c("Category", "Cost", "Percent_of_COQ")])
cat("─────────────────────────────\n")
cat("Total Cost of Quality: $", format(total_coq, big.mark = ","), "\n")
cat("COQ as % of Revenue:", round(total_coq/revenue*100, 1), "%\n\n")

# Analysis
conformance <- coq_data$Cost[1] + coq_data$Cost[2]
nonconformance <- coq_data$Cost[3] + coq_data$Cost[4]

cat("Conformance Costs (Prevention + Appraisal): $", format(conformance, big.mark = ","),
    "(", round(conformance/total_coq*100, 1), "%)\n")
cat("Nonconformance Costs (Failures): $", format(nonconformance, big.mark = ","),
    "(", round(nonconformance/total_coq*100, 1), "%)\n")
cat("\nRecommendation: Increase prevention spending to reduce failure costs\n")
```

```{r coq-chart, echo=FALSE, fig.width=10, fig.height=6}
coq_data$Category <- factor(coq_data$Category,
                            levels = c("Prevention", "Appraisal", "Internal Failure", "External Failure"))

ggplot(coq_data, aes(x = Category, y = Cost/1000, fill = Category)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = paste0("$", Cost/1000, "K\n(", Percent_of_COQ, "%)")),
            vjust = -0.2, size = 3.5) +
  scale_fill_manual(values = c("#27ae60", "#3498db", "#f39c12", "#e74c3c"), guide = "none") +
  scale_y_continuous(limits = c(0, 220), labels = scales::dollar_format(suffix = "K")) +
  annotate("rect", xmin = 0.5, xmax = 2.5, ymin = -10, ymax = -5, fill = "#27ae60", alpha = 0.3) +
  annotate("text", x = 1.5, y = -7.5, label = "Conformance Costs", size = 3) +
  annotate("rect", xmin = 2.5, xmax = 4.5, ymin = -10, ymax = -5, fill = "#e74c3c", alpha = 0.3) +
  annotate("text", x = 3.5, y = -7.5, label = "Nonconformance Costs", size = 3) +
  labs(title = "Cost of Quality Analysis",
       subtitle = paste0("Total COQ: $", format(total_coq, big.mark = ","),
                        " (", round(total_coq/revenue*100, 1), "% of revenue)"),
       x = "", y = "Cost") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.x = element_text(size = 11)
  )
```

---

## Integration with Quality Tools

A mature QMS integrates various quality tools throughout the organization.

### Quality Tools Integration Map

```{r tools-integration, echo=FALSE, fig.width=14, fig.height=9}
tools_map <- data.frame(
  Phase = c("Design", "Design", "Launch", "Launch", "Production", "Production", "Production", "Improvement"),
  Tool = c("DFMEA", "DFM/DFA", "PFMEA", "Control Plan", "SPC", "MSA", "Audit", "CAPA"),
  QMS_Link = c("Risk assessment (6.1)", "Design controls (8.3)", "Risk assessment (6.1)",
               "Operational control (8.1)", "Monitoring (9.1)", "Resources (7.1.5)",
               "Internal audit (9.2)", "Nonconformity (10.2)"),
  x = c(1, 1.5, 2.5, 3, 4, 4.5, 5.5, 6.5),
  y = c(2, 1, 2, 1, 2, 1, 2, 1.5)
)

ggplot(tools_map, aes(x = x, y = y)) +
  # Phase boxes
  annotate("rect", xmin = 0.5, xmax = 1.8, ymin = 0.3, ymax = 2.7,
           fill = "#3498db", alpha = 0.2, color = "#3498db") +
  annotate("text", x = 1.15, y = 2.5, label = "DESIGN", fontface = "bold", color = "#3498db") +

  annotate("rect", xmin = 2, xmax = 3.5, ymin = 0.3, ymax = 2.7,
           fill = "#27ae60", alpha = 0.2, color = "#27ae60") +
  annotate("text", x = 2.75, y = 2.5, label = "LAUNCH", fontface = "bold", color = "#27ae60") +

  annotate("rect", xmin = 3.7, xmax = 6, ymin = 0.3, ymax = 2.7,
           fill = "#f39c12", alpha = 0.2, color = "#f39c12") +
  annotate("text", x = 4.85, y = 2.5, label = "PRODUCTION", fontface = "bold", color = "#f39c12") +

  annotate("rect", xmin = 6.2, xmax = 7, ymin = 0.3, ymax = 2.7,
           fill = "#9b59b6", alpha = 0.2, color = "#9b59b6") +
  annotate("text", x = 6.6, y = 2.5, label = "IMPROVE", fontface = "bold", color = "#9b59b6") +

  # Tool boxes
  geom_label(aes(label = Tool), fill = "white", fontface = "bold", size = 3.5) +
  geom_text(aes(label = QMS_Link, y = y - 0.35), size = 2.5, color = "gray40") +

  # Flow arrows
  annotate("segment", x = 1.8, xend = 2.3, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  annotate("segment", x = 3.3, xend = 3.8, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +
  annotate("segment", x = 5.8, xend = 6.2, y = 1.5, yend = 1.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "gray50") +

  # Feedback loop
  annotate("curve", x = 6.6, xend = 1.15, y = 0.5, yend = 0.5,
           curvature = 0.3, arrow = arrow(length = unit(0.2, "cm")),
           color = "#e74c3c", linetype = "dashed") +
  annotate("text", x = 4, y = 0.15, label = "Lessons Learned / Continuous Improvement",
           color = "#e74c3c", fontface = "italic", size = 3) +

  coord_cartesian(xlim = c(0, 7.5), ylim = c(-0.2, 3)) +
  labs(title = "Quality Tools Integration Throughout Product Lifecycle",
       subtitle = "Each tool connects to specific ISO 9001 requirements") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Linking Tools to QMS Requirements

```{r tools-qms-link, echo=FALSE}
tool_links <- data.frame(
  Tool = c("PFMEA", "Control Plan", "SPC", "MSA", "Internal Audit", "CAPA", "Management Review"),
  ISO_Clause = c("6.1, 8.1", "8.1, 8.5.1", "9.1.1", "7.1.5", "9.2", "10.2", "9.3"),
  Purpose = c(
    "Identify and mitigate process risks before production",
    "Define controls for special characteristics",
    "Monitor process performance; detect special causes",
    "Ensure measurement system is adequate",
    "Verify QMS conformance and effectiveness",
    "Eliminate causes of nonconformities",
    "Evaluate QMS suitability and effectiveness"
  ),
  Output_Used_By = c(
    "Control Plan, Work Instructions",
    "Work Instructions, SPC requirements",
    "CAPA triggers, Management Review",
    "SPC validity, Control Plan",
    "CAPA triggers, Management Review",
    "Process improvements, Lessons learned",
    "Strategic decisions, Resource allocation"
  )
)

kable(tool_links, col.names = c("Quality Tool", "ISO 9001 Clause", "Purpose", "Output Feeds Into"),
      caption = "Quality Tools and QMS Integration") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%")
```

---

## Certification Process

Organizations can seek **third-party certification** to demonstrate QMS conformance to customers and stakeholders.

### The Certification Journey

```{r certification-process, echo=FALSE, fig.width=12, fig.height=6}
cert_steps <- data.frame(
  step = 1:8,
  name = c("Gap Analysis", "Implementation", "Internal Audit",
           "Management Review", "Registrar Selection", "Stage 1 Audit",
           "Stage 2 Audit", "Certification"),
  duration = c("1-2 months", "3-9 months", "1 month", "Ongoing",
               "1 month", "1 day", "2-4 days", "3 years"),
  x = 1:8
)

ggplot(cert_steps, aes(x = x, y = 1)) +
  geom_segment(aes(x = 1, xend = 8, y = 1, yend = 1), color = "gray70", size = 2) +
  geom_point(size = 12, color = "#3498db") +
  geom_text(aes(label = step), color = "white", fontface = "bold", size = 4) +
  geom_text(aes(label = name, y = 1.4), size = 3, fontface = "bold", angle = 45, hjust = 0) +
  geom_text(aes(label = duration, y = 0.6), size = 2.5, color = "gray50") +
  scale_y_continuous(limits = c(0.3, 2)) +
  labs(title = "Path to ISO 9001 Certification",
       subtitle = "Typical timeline: 6-18 months depending on organization readiness") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Certification Audit Types

```{r audit-types, echo=FALSE}
audit_types <- data.frame(
  Audit = c("Stage 1 (Documentation)", "Stage 2 (Certification)",
            "Surveillance", "Recertification"),
  Purpose = c(
    "Review QMS documentation; verify readiness for Stage 2",
    "Evaluate implementation and effectiveness of QMS",
    "Verify continued conformance (annual)",
    "Full re-audit at end of 3-year cycle"
  ),
  Focus = c(
    "Quality manual, procedures, scope, internal audits, management review",
    "All clauses; process effectiveness; records; interviews",
    "Selected processes; previous findings; changes",
    "Complete review similar to Stage 2"
  ),
  Typical_Duration = c(
    "0.5-1 day (remote or on-site)",
    "2-5 days depending on size",
    "1-2 days annually",
    "2-4 days"
  )
)

kable(audit_types, col.names = c("Audit Type", "Purpose", "Focus Areas", "Duration"),
      caption = "Third-Party Certification Audit Types") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

---

## Video Resources

### ISO 9001:2015 Overview

<iframe width="560" height="315" src="https://www.youtube.com/embed/O5T4H8K_rwQ" title="ISO 9001:2015 Overview" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Internal Auditing Best Practices

<iframe width="560" height="315" src="https://www.youtube.com/embed/deRqslBeMrE" title="Internal Auditing" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Summary

A Quality Management System provides the framework for consistently meeting customer requirements and improving organizational performance:

1. **ISO 9001:2015** provides the foundational requirements using risk-based thinking and PDCA
2. **Industry standards** (IATF 16949, AS9100, ISO 22000) add sector-specific requirements
3. **Documentation** establishes the hierarchy from policy to procedures to records
4. **Internal audits** verify conformance and identify improvement opportunities
5. **CAPA** eliminates root causes of nonconformities and prevents recurrence
6. **Management review** ensures QMS suitability and drives strategic improvement
7. **Continuous improvement** is embedded through KPIs, COQ analysis, and improvement methodologies
8. **Quality tools** (PFMEA, SPC, MSA) integrate throughout the product lifecycle

> "Quality is not an act, it is a habit." — Aristotle

---

## Review Questions

<details><summary>**Question 1**: Explain the seven quality management principles and how they relate to each other.</summary>

**Answer:**

The seven quality management principles form an interconnected foundation:

1. **Customer Focus** (Central principle)
   - Understanding and meeting customer needs is the primary purpose
   - All other principles support this goal

2. **Leadership**
   - Leaders establish unity of purpose and direction
   - Create conditions for people to achieve quality objectives
   - Enables all other principles

3. **Engagement of People**
   - Competent, empowered people at all levels
   - Essential for effective processes and customer focus

4. **Process Approach**
   - Activities managed as interrelated processes
   - Enables consistent, predictable results

5. **Improvement**
   - Ongoing focus on enhancing performance
   - Essential for maintaining customer satisfaction

6. **Evidence-based Decision Making**
   - Decisions based on analysis of data
   - Reduces uncertainty; improves decision quality

7. **Relationship Management**
   - Managing relationships with interested parties (suppliers, partners)
   - Optimizes their impact on performance

**Relationships:**
- Customer Focus drives the need for all others
- Leadership enables and supports all principles
- Engagement of People is essential for Process Approach and Improvement
- Evidence-based Decision Making supports Improvement
- Relationship Management extends quality beyond the organization
</details>

<details><summary>**Question 2**: Compare ISO 9001, IATF 16949, and AS9100. When would each be required?</summary>

**Answer:**

| Standard | Base | Industry | Additional Focus |
|----------|------|----------|------------------|
| **ISO 9001:2015** | Standalone | General | Quality fundamentals |
| **IATF 16949:2016** | ISO 9001 + automotive | Automotive | PPAP, APQP, Core Tools |
| **AS9100D** | ISO 9001 + aerospace | Aerospace/Defense | Configuration mgmt, FAI, counterfeit prevention |

**When Required:**

**ISO 9001:**
- Any organization wanting to demonstrate quality capability
- Customer or contract requirement for QMS certification
- Basis for all other standards
- Suitable for service, manufacturing, any industry

**IATF 16949:**
- Suppliers to automotive OEMs (Ford, GM, Toyota, VW, etc.)
- Required for production parts/materials
- Required throughout automotive supply chain
- Includes Customer-Specific Requirements (CSRs)

**AS9100:**
- Suppliers to aerospace/defense contractors
- Boeing, Airbus, Lockheed Martin, military programs
- Required for flight-critical components
- OASIS database registration required

**Key Differences:**
- IATF 16949: Emphasizes PPAP, APQP, manufacturing process control
- AS9100: Emphasizes traceability, configuration control, first article inspection
- Both build on ISO 9001 with sector-specific additions
</details>

<details><summary>**Question 3**: Describe the documentation hierarchy in a QMS. Give an example of each level.</summary>

**Answer:**

**Level 1: Quality Policy and Objectives**
- Strategic direction for quality
- Signed by top management
- Communicated to all employees
- *Example:* "ABC Company is committed to delivering defect-free products that meet customer requirements through continuous improvement of our processes and people."

**Level 2: Quality Manual and Procedures**
- Describes WHAT is done and WHO is responsible
- System-level documents
- *Example:* Document Control Procedure (QP-001)
  - Purpose: Control creation, approval, distribution of documents
  - Scope: All QMS documents
  - Responsibilities: Document Control Coordinator, Department Managers
  - Process flow for document changes

**Level 3: Work Instructions and Specifications**
- Describes HOW tasks are performed
- Detailed step-by-step instructions
- *Example:* Work Instruction for CNC Lathe Setup (WI-MAC-015)
  - Step 1: Verify program number matches work order
  - Step 2: Install correct tooling per setup sheet
  - Step 3: Set tool offsets using touch-off procedure
  - Step 4: Run first piece and verify dimensions

**Level 4: Records and Forms**
- Evidence that activities were performed
- Completed forms, inspection results, logs
- *Example:* First Article Inspection Report (FM-QC-008)
  - Part number, revision, date
  - Dimensional measurements vs. specifications
  - Inspector signature
  - Disposition (Accept/Reject)
</details>

<details><summary>**Question 4**: What are the key elements of an effective internal audit program?</summary>

**Answer:**

**1. Audit Program Planning**
- Annual audit schedule covering all QMS processes
- Risk-based frequency (higher risk = more frequent)
- Documented audit program procedure
- Resource allocation (trained auditors, time)

**2. Auditor Competence**
- Trained in audit techniques
- Knowledge of standards (ISO 9001, industry-specific)
- Understanding of processes being audited
- Independence from area being audited

**3. Audit Preparation**
- Review of relevant documents (procedures, previous audits)
- Prepared checklist linked to requirements
- Notification to auditee
- Defined scope and objectives

**4. Audit Execution**
- Opening meeting (purpose, scope, schedule)
- Evidence collection (documents, records, interviews, observation)
- Objective evaluation against criteria
- Note taking and evidence documentation

**5. Reporting**
- Clear finding statements (nonconformities, observations)
- Reference to requirement violated
- Objective evidence cited
- Closing meeting to present findings

**6. Follow-up**
- Corrective action requests issued
- Root cause analysis required
- Verification of corrective action implementation
- Verification of effectiveness

**7. Continuous Improvement of Audit Program**
- Evaluate audit program effectiveness
- Update based on organizational changes
- Calibrate auditors periodically
- Incorporate lessons learned
</details>

<details><summary>**Question 5**: Explain the difference between corrective action and preventive action. Provide an example of each.</summary>

**Answer:**

**Corrective Action:**
- Eliminates the cause of a *detected* nonconformity
- Reactive - responds to something that has already happened
- Goal: Prevent recurrence of the specific problem

*Example:*
- **Nonconformity:** Customer received shipment with wrong part numbers (3 incidents in past month)
- **Root Cause:** Shipping labels printed from outdated part number list
- **Corrective Action:**
  1. Update master part number list
  2. Link shipping system directly to ERP for current data
  3. Add verification step comparing label to packing list
- **Verification:** No recurrence after 3 months

**Preventive Action:**
- Eliminates the cause of a *potential* nonconformity
- Proactive - addresses something that hasn't happened yet
- Goal: Prevent occurrence before it happens

*Example:*
- **Potential Nonconformity:** New CNC machine may produce out-of-spec parts due to operator unfamiliarity
- **Risk Identified Through:** PFMEA analysis during new equipment installation
- **Preventive Action:**
  1. Develop comprehensive training program before machine goes live
  2. Create detailed setup procedures with photos
  3. Implement first-article inspection for first 30 days
  4. Assign experienced mentor to new operators
- **Verification:** Track first-pass yield during initial production period

**Key Difference:**
- Corrective = Fix what went wrong
- Preventive = Stop what might go wrong

**Note:** ISO 9001:2015 doesn't explicitly require "preventive action" as a separate process. Instead, risk-based thinking throughout the QMS serves the preventive function.
</details>

<details><summary>**Question 6**: Calculate and analyze the Cost of Quality for the following data. What recommendations would you make?</summary>

| Category | Cost |
|----------|------|
| Quality planning | $35,000 |
| Training | $25,000 |
| Incoming inspection | $40,000 |
| In-process inspection | $55,000 |
| Final inspection | $30,000 |
| Scrap | $85,000 |
| Rework | $65,000 |
| Warranty claims | $120,000 |
| Customer returns | $45,000 |

Annual revenue: $8,000,000

**Answer:**

```{r q6-answer, echo=TRUE}
# Cost of Quality Analysis
prevention <- 35000 + 25000  # Planning + Training
appraisal <- 40000 + 55000 + 30000  # Inspections
internal_failure <- 85000 + 65000  # Scrap + Rework
external_failure <- 120000 + 45000  # Warranty + Returns

total_coq <- prevention + appraisal + internal_failure + external_failure
revenue <- 8000000

cat("Cost of Quality Breakdown:\n")
cat("─────────────────────────────\n")
cat("Prevention:       $", format(prevention, big.mark = ","),
    "(", round(prevention/total_coq*100, 1), "%)\n")
cat("Appraisal:        $", format(appraisal, big.mark = ","),
    "(", round(appraisal/total_coq*100, 1), "%)\n")
cat("Internal Failure: $", format(internal_failure, big.mark = ","),
    "(", round(internal_failure/total_coq*100, 1), "%)\n")
cat("External Failure: $", format(external_failure, big.mark = ","),
    "(", round(external_failure/total_coq*100, 1), "%)\n")
cat("─────────────────────────────\n")
cat("Total COQ:        $", format(total_coq, big.mark = ","), "\n")
cat("COQ % of Revenue:", round(total_coq/revenue*100, 1), "%\n\n")

conformance <- prevention + appraisal
nonconformance <- internal_failure + external_failure

cat("Conformance Costs:    $", format(conformance, big.mark = ","),
    "(", round(conformance/total_coq*100, 1), "%)\n")
cat("Nonconformance Costs: $", format(nonconformance, big.mark = ","),
    "(", round(nonconformance/total_coq*100, 1), "%)\n")
```

**Analysis:**
- COQ at 7.5% of revenue is HIGH (target <3%)
- External failure costs are the largest category (27.5%)
- Nonconformance costs (60.8%) greatly exceed conformance (39.2%)
- Prevention is only 10% of COQ - very low

**Recommendations:**
1. **Increase Prevention Investment:**
   - Implement SPC on critical processes to reduce defects
   - Enhance operator training on quality standards
   - Apply PFMEA to identify and control failure modes

2. **Reduce External Failures:**
   - Analyze warranty data for root causes
   - Improve final inspection effectiveness
   - Implement containment for known issues

3. **Optimize Appraisal:**
   - Use SPC to reduce inspection where processes are capable
   - Implement risk-based inspection (more for critical, less for proven)

4. **Target COQ Reduction:**
   - Short-term: Reduce external failures by 50% ($82,500 savings)
   - Medium-term: Reduce internal failures by 30% ($45,000 savings)
   - Long-term: Achieve COQ <3% of revenue ($240,000)
</details>

<details><summary>**Question 7**: What is risk-based thinking in ISO 9001:2015? How is it different from formal risk management?</summary>

**Answer:**

**Risk-Based Thinking in ISO 9001:2015:**

Risk-based thinking is a way of considering risks and opportunities when designing, implementing, and operating the QMS. It:

- Applies throughout the standard (not a separate clause)
- Is proportional to potential impact on conformity
- Makes preventive action part of routine planning
- Considers both risks (negative) and opportunities (positive)

**Where Risk-Based Thinking Applies:**

| Clause | Application |
|--------|-------------|
| 4.1 Context | Identify external/internal issues affecting QMS |
| 4.2 Interested Parties | Understand requirements that could impact quality |
| 6.1 Planning | Plan actions to address risks and opportunities |
| 8.1 Operations | Consider risks in operational planning |
| 9.1 Performance | Monitor effectiveness of risk actions |
| 10.2 Corrective Action | Update risks/opportunities based on nonconformities |

**How It Differs from Formal Risk Management:**

| Aspect | Risk-Based Thinking | Formal Risk Management |
|--------|---------------------|------------------------|
| Requirement | Implicit throughout ISO 9001 | Explicit (ISO 31000) |
| Documentation | No formal risk register required | Documented risk register |
| Methodology | No specific method required | Defined methodology (FMEA, etc.) |
| Quantification | Not required | Often quantitative |
| Scope | QMS processes | Enterprise-wide |

**Practical Implementation:**

Organizations should:
1. Consider risks when designing processes
2. Build controls proportional to risk level
3. Monitor and review effectiveness
4. Update as context changes

ISO 9001 does NOT require:
- Formal risk management process
- Risk register
- Specific risk assessment methodology
- Documented risk assessments (unless organization decides to)

However, many organizations do use tools like PFMEA to fulfill risk-based thinking requirements, especially in automotive (IATF 16949 requires it).
</details>

<details><summary>**Question 8**: Describe what management review is and what should be included in the inputs and outputs.</summary>

**Answer:**

**What is Management Review?**

Management review is a formal, periodic evaluation of the QMS by top management to:
- Ensure continuing suitability (appropriate for the organization)
- Ensure adequacy (sufficient to meet requirements)
- Ensure effectiveness (achieving intended results)
- Ensure alignment with strategic direction
- Identify improvement opportunities

**Frequency:** At least annually; many organizations conduct quarterly reviews

**Required Inputs (ISO 9001 Clause 9.3.2):**

| Input | What to Review |
|-------|----------------|
| Status of previous actions | Actions from prior reviews - completed? effective? |
| Changes in external/internal issues | Market changes, regulations, technology, organizational changes |
| QMS performance and effectiveness | Customer satisfaction, quality objectives, process performance, nonconformities, audit results, supplier performance |
| Resource adequacy | People, infrastructure, environment, knowledge |
| Effectiveness of risk actions | Did actions address risks/opportunities? |
| Improvement opportunities | Suggestions, benchmarking, new technologies |

**Required Outputs (ISO 9001 Clause 9.3.3):**

| Output | Examples |
|--------|----------|
| Improvement decisions | Launch specific improvement projects, address recurring issues |
| QMS changes | Revise quality objectives, update processes, modify documentation |
| Resource needs | Budget approvals, hiring, equipment purchases, training |

**Best Practices:**
- Use a standard agenda aligned with required inputs
- Prepare data in advance (dashboards, trend charts)
- Document decisions and action items with owners and due dates
- Follow up on action completion
- Keep minutes as quality records

**Evidence Required:**
- Meeting minutes or management review report
- Attendance record (top management participation)
- Action items with status tracking
- Data/reports presented
</details>

---

## References

1. ISO 9001:2015. *Quality Management Systems - Requirements*. International Organization for Standardization.

2. ISO 9000:2015. *Quality Management Systems - Fundamentals and Vocabulary*. International Organization for Standardization.

3. IATF 16949:2016. *Quality Management System Requirements for Automotive Production and Relevant Service Parts Organizations*. International Automotive Task Force.

4. AS9100D:2016. *Quality Management Systems - Requirements for Aviation, Space and Defense Organizations*. SAE International.

5. ISO 22000:2018. *Food Safety Management Systems - Requirements for Any Organization in the Food Chain*. International Organization for Standardization.

6. ISO 19011:2018. *Guidelines for Auditing Management Systems*. International Organization for Standardization.

7. Hoyle, D. (2017). *ISO 9000 Quality Systems Handbook* (7th ed.). Routledge.

8. AIAG. (2010). *Advanced Product Quality Planning and Control Plan (APQP)* (2nd ed.). Automotive Industry Action Group.

9. ASQ. (2019). *The Certified Quality Auditor Handbook* (4th ed.). ASQ Quality Press.

10. Juran, J.M., & De Feo, J.A. (2010). *Juran's Quality Handbook* (6th ed.). McGraw-Hill.

<!--chapter:end:14-Quality-Systems.Rmd-->

# Industrial Robotics

```{r setup-ch15, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyr)
library(ggforce)
```

## Learning Objectives

After completing this chapter, you will be able to:

1. Define industrial robots and explain their role in modern manufacturing
2. Identify the main types of robot configurations and their applications
3. Describe robot specifications including payload, reach, repeatability, and speed
4. Explain the components of a robotic system (manipulator, controller, teach pendant, end effector)
5. Understand robot coordinate systems and motion types
6. Identify common robot applications in automotive, food, and defense industries
7. Apply robot safety standards and safeguarding methods
8. Describe collaborative robot (cobot) technology and applications
9. Understand basic robot programming concepts

---

## Introduction to Industrial Robotics

An **industrial robot** is defined by ISO 8373 as "an automatically controlled, reprogrammable, multipurpose manipulator, programmable in three or more axes, which can be either fixed in place or mobile for use in industrial automation applications."

### Why Use Robots?

```{r robot-benefits, echo=FALSE, fig.width=12, fig.height=7}
benefits <- data.frame(
  Benefit = c("Consistency", "Productivity", "Quality", "Safety",
              "Flexibility", "Cost Reduction"),
  Description = c(
    "Identical motion every cycle; no fatigue",
    "24/7 operation; faster cycle times",
    "Precision and repeatability reduce defects",
    "Remove humans from hazardous tasks",
    "Reprogrammable for different products",
    "Lower labor costs; reduced scrap"
  ),
  Impact = c(95, 90, 88, 92, 75, 85)
)

ggplot(benefits, aes(x = reorder(Benefit, Impact), y = Impact, fill = Benefit)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = Description), hjust = -0.05, size = 3) +
  coord_flip() +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  scale_y_continuous(limits = c(0, 160)) +
  labs(title = "Benefits of Industrial Robots",
       subtitle = "Key drivers for robot adoption in manufacturing",
       x = "", y = "Impact Score") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 11, face = "bold")
  )
```

### Robot Market Growth

```{r robot-market, echo=FALSE, fig.width=11, fig.height=6}
# Global robot installations data (approximate)
market_data <- data.frame(
  Year = 2018:2024,
  Installations = c(422, 381, 384, 517, 553, 590, 620),
  Region = "Global"
)

ggplot(market_data, aes(x = Year, y = Installations)) +
  geom_bar(stat = "identity", fill = "#3498db", width = 0.7) +
  geom_text(aes(label = paste0(Installations, "K")), vjust = -0.5, size = 4) +
  geom_smooth(method = "lm", se = FALSE, color = "#e74c3c", linetype = "dashed") +
  scale_y_continuous(limits = c(0, 700)) +
  labs(title = "Global Industrial Robot Installations",
       subtitle = "Annual installations in thousands of units (IFR data)",
       x = "Year", y = "Units Installed (thousands)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
```

### Industries Using Robots

```{r robot-industries, echo=FALSE}
industries <- data.frame(
  Industry = c("Automotive", "Electrical/Electronics", "Metal & Machinery",
               "Food & Beverage", "Plastics & Chemicals", "Aerospace/Defense"),
  Share = c(30, 25, 12, 8, 5, 4),
  Applications = c(
    "Welding, painting, assembly, material handling",
    "Assembly, testing, packaging, dispensing",
    "Machine tending, welding, cutting",
    "Palletizing, packaging, pick-and-place",
    "Injection molding, packaging, assembly",
    "Drilling, fastening, inspection, composite layup"
  ),
  Growth = c("Stable", "High", "Moderate", "High", "Moderate", "High")
)

kable(industries, col.names = c("Industry", "Market Share (%)", "Key Applications", "Growth Trend"),
      caption = "Industrial Robot Usage by Industry Sector") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

---

## Robot Configurations

Industrial robots come in various mechanical configurations, each suited to different applications.

### Common Robot Types

```{r robot-types, echo=FALSE, fig.width=14, fig.height=10}
robot_types <- data.frame(
  Type = c("Articulated\n(6-axis)", "SCARA", "Delta\n(Parallel)", "Cartesian\n(Gantry)",
           "Cylindrical", "Collaborative\n(Cobot)"),
  Characteristics = c(
    "Most versatile\nHuman-like motion\n6 degrees of freedom",
    "Fast horizontal motion\nRigid vertical axis\n4 axes typical",
    "Very high speed\nLimited payload\nParallel linkage",
    "Linear motion\nLarge work envelope\n3-4 axes",
    "Rotary base\nLinear reach\n4 axes typical",
    "Force limited\nSafe around humans\nEasy programming"
  ),
  Applications = c(
    "Welding, painting\nassembly, handling",
    "Assembly, pick-place\npackaging",
    "High-speed picking\npackaging, assembly",
    "CNC loading, palletizing\nlarge part handling",
    "Machine tending\nmaterial handling",
    "Human collaboration\nassembly assist"
  ),
  x = c(1, 2, 3, 1, 2, 3),
  y = c(2, 2, 2, 1, 1, 1)
)

ggplot(robot_types, aes(x = x, y = y)) +
  geom_tile(aes(fill = Type), width = 0.95, height = 0.9, color = "white", size = 2) +
  geom_text(aes(label = Type), fontface = "bold", vjust = -2, size = 4, color = "white") +
  geom_text(aes(label = Characteristics), vjust = 0, size = 2.8, color = "white", lineheight = 0.85) +
  geom_text(aes(label = Applications), vjust = 3.5, size = 2.5, color = "white",
            fontface = "italic", lineheight = 0.85) +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  labs(title = "Industrial Robot Configurations",
       subtitle = "Different types optimized for specific applications") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Detailed Configuration Comparison

```{r config-comparison, echo=FALSE}
config_table <- data.frame(
  Configuration = c("6-Axis Articulated", "SCARA", "Delta/Parallel", "Cartesian/Gantry"),
  Axes = c("6", "4", "3-4", "3-6"),
  Payload = c("3-2300 kg", "1-20 kg", "0.5-12 kg", "5-1000+ kg"),
  Reach = c("0.5-4 m", "0.2-1.2 m", "0.5-1.5 m", "Custom (meters)"),
  Repeatability = c("±0.02-0.1 mm", "±0.01-0.05 mm", "±0.05-0.1 mm", "±0.05-0.5 mm"),
  Speed = c("Moderate-Fast", "Very Fast", "Extremely Fast", "Moderate"),
  Cost = c("$$-$$$$", "$$", "$$$", "$-$$$$"),
  Best_For = c(
    "Complex 3D tasks, maximum flexibility",
    "Fast assembly, pick-place, screw driving",
    "High-speed picking, packaging lines",
    "Large work areas, heavy loads, simple paths"
  )
)

kable(config_table, col.names = c("Configuration", "Axes", "Payload Range", "Reach",
                                   "Repeatability", "Speed", "Cost", "Best Applications"),
      caption = "Robot Configuration Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "14%")
```

### Degrees of Freedom

```{r degrees-freedom, echo=FALSE, fig.width=12, fig.height=6}
ggplot() +
  # Robot arm representation
  annotate("segment", x = 1, xend = 1, y = 0, yend = 1.5, size = 8, color = "#34495e") +
  annotate("segment", x = 1, xend = 2.5, y = 1.5, yend = 2.5, size = 6, color = "#3498db") +
  annotate("segment", x = 2.5, xend = 4, y = 2.5, yend = 2, size = 5, color = "#27ae60") +
  annotate("segment", x = 4, xend = 5, y = 2, yend = 2.2, size = 4, color = "#e74c3c") +

  # Joint circles
  annotate("point", x = 1, y = 0, size = 12, color = "#f39c12") +
  annotate("point", x = 1, y = 1.5, size = 10, color = "#f39c12") +
  annotate("point", x = 2.5, y = 2.5, size = 8, color = "#f39c12") +
  annotate("point", x = 4, y = 2, size = 6, color = "#f39c12") +
  annotate("point", x = 5, y = 2.2, size = 5, color = "#9b59b6") +

  # Axis labels
  annotate("text", x = 0.5, y = 0, label = "J1\n(Base)", size = 3, fontface = "bold") +
  annotate("text", x = 0.5, y = 1.5, label = "J2\n(Shoulder)", size = 3, fontface = "bold") +
  annotate("text", x = 2.5, y = 3, label = "J3\n(Elbow)", size = 3, fontface = "bold") +
  annotate("text", x = 4, y = 1.4, label = "J4\n(Wrist 1)", size = 3, fontface = "bold") +
  annotate("text", x = 5.5, y = 2.2, label = "J5, J6\n(Wrist 2,3)", size = 3, fontface = "bold") +

  # Motion arrows
  annotate("curve", x = 0.7, xend = 1.3, y = 0.3, yend = 0.3,
           curvature = -0.5, arrow = arrow(length = unit(0.2, "cm")), color = "#e74c3c") +
  annotate("curve", x = 0.7, xend = 1.3, y = 1.8, yend = 1.8,
           curvature = 0.5, arrow = arrow(length = unit(0.2, "cm")), color = "#e74c3c") +

  # Legend
  annotate("rect", xmin = 6, xmax = 9, ymin = 0, ymax = 3, fill = "#f8f9fa", color = "gray") +
  annotate("text", x = 6.2, y = 2.7, label = "6-Axis Robot Joints:", hjust = 0,
           fontface = "bold", size = 3.5) +
  annotate("text", x = 6.2, y = 2.3, label = "J1: Base rotation", hjust = 0, size = 3) +
  annotate("text", x = 6.2, y = 2.0, label = "J2: Shoulder pivot", hjust = 0, size = 3) +
  annotate("text", x = 6.2, y = 1.7, label = "J3: Elbow pivot", hjust = 0, size = 3) +
  annotate("text", x = 6.2, y = 1.4, label = "J4: Wrist rotation", hjust = 0, size = 3) +
  annotate("text", x = 6.2, y = 1.1, label = "J5: Wrist bend", hjust = 0, size = 3) +
  annotate("text", x = 6.2, y = 0.8, label = "J6: Tool rotation", hjust = 0, size = 3) +

  coord_cartesian(xlim = c(0, 9.5), ylim = c(-0.5, 3.5)) +
  labs(title = "6-Axis Articulated Robot - Joint Nomenclature",
       subtitle = "Each joint provides one degree of freedom") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

---

## Robot Specifications

Understanding robot specifications is essential for proper selection and application.

### Key Specifications

```{r robot-specs, echo=FALSE}
specs <- data.frame(
  Specification = c("Payload", "Reach", "Repeatability", "Accuracy",
                    "Maximum Speed", "Degrees of Freedom", "Mounting", "IP Rating"),
  Definition = c(
    "Maximum mass the robot can handle at full speed",
    "Maximum distance from base to tool center point",
    "Ability to return to same position repeatedly",
    "Ability to reach a commanded position exactly",
    "Maximum velocity at tool center point or joint speeds",
    "Number of independent axes of motion",
    "How robot is installed (floor, ceiling, wall, angle)",
    "Ingress Protection rating for dust/water resistance"
  ),
  Typical_Values = c(
    "3-2300 kg (varies widely by type)",
    "500-4000 mm for articulated robots",
    "±0.01 to ±0.1 mm",
    "±0.1 to ±1.0 mm",
    "1-12 m/s TCP; 100-500°/s joint",
    "4-7 axes",
    "Floor (most common), ceiling, wall, shelf",
    "IP40 (standard) to IP67 (harsh environments)"
  ),
  Importance = c(
    "Must exceed part + gripper + safety factor",
    "Must cover all required work positions",
    "Critical for precision assembly; welding",
    "Important for offline programming",
    "Affects cycle time; may be derated with payload",
    "More axes = more flexibility",
    "Affects work envelope and floor space",
    "Required for foundry, food, wash-down applications"
  )
)

kable(specs, caption = "Key Robot Specifications Explained") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "15%")
```

### Work Envelope

The **work envelope** (or workspace) is the three-dimensional space the robot can reach.

```{r work-envelope, echo=FALSE, fig.width=11, fig.height=7}
# Simulate 6-axis robot work envelope (simplified 2D view)
theta <- seq(0, 2*pi, length.out = 100)
r_max <- 1800  # mm reach
r_min <- 400   # mm minimum reach

envelope <- data.frame(
  x_outer = r_max * cos(theta),
  y_outer = r_max * sin(theta),
  x_inner = r_min * cos(theta),
  y_inner = r_min * sin(theta)
)

ggplot() +
  # Outer envelope
  geom_polygon(data = data.frame(x = envelope$x_outer, y = envelope$y_outer),
               aes(x = x, y = y), fill = "#3498db", alpha = 0.3, color = "#3498db") +
  # Inner dead zone
  geom_polygon(data = data.frame(x = envelope$x_inner, y = envelope$y_inner),
               aes(x = x, y = y), fill = "white", color = "#e74c3c", linetype = "dashed") +
  # Robot base
  annotate("point", x = 0, y = 0, size = 8, color = "#34495e") +
  annotate("text", x = 0, y = -200, label = "Robot Base", fontface = "bold") +
  # Annotations
  annotate("segment", x = 0, xend = 1800, y = 0, yend = 0,
           arrow = arrow(ends = "both", length = unit(0.2, "cm")), color = "black") +
  annotate("text", x = 900, y = 100, label = "Max Reach: 1800mm", size = 3.5) +
  annotate("segment", x = 0, xend = 400, y = 300, yend = 300,
           arrow = arrow(ends = "both", length = unit(0.15, "cm")), color = "#e74c3c") +
  annotate("text", x = 200, y = 450, label = "Dead Zone\n(Min Reach: 400mm)",
           size = 3, color = "#e74c3c", lineheight = 0.9) +
  # Work area example
  annotate("rect", xmin = 800, xmax = 1400, ymin = -300, ymax = 300,
           fill = "#27ae60", alpha = 0.4, color = "#27ae60") +
  annotate("text", x = 1100, y = 0, label = "Typical\nWork Area", size = 3,
           color = "#27ae60", fontface = "bold", lineheight = 0.9) +
  coord_fixed(xlim = c(-2200, 2200), ylim = c(-2200, 2200)) +
  labs(title = "Robot Work Envelope (Top View)",
       subtitle = "Horizontal reach shown; vertical reach forms spherical envelope",
       x = "X Position (mm)", y = "Y Position (mm)") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    panel.grid.minor = element_blank()
  )
```

### Payload Considerations

```{r payload-calc, echo=TRUE}
# Payload Calculation Example
robot_max_payload <- 10  # kg
gripper_weight <- 2.5    # kg
part_weight <- 5.0       # kg
safety_factor <- 1.2     # 20% safety margin

total_load <- gripper_weight + part_weight
required_capacity <- total_load * safety_factor
available_capacity <- robot_max_payload - gripper_weight

cat("Payload Analysis:\n")
cat("─────────────────────────────\n")
cat("Robot maximum payload:", robot_max_payload, "kg\n")
cat("Gripper weight:", gripper_weight, "kg\n")
cat("Part weight:", part_weight, "kg\n")
cat("Total load:", total_load, "kg\n")
cat("With safety factor (", safety_factor, "x):", required_capacity, "kg\n")
cat("─────────────────────────────\n")
cat("Available capacity for part:", available_capacity, "kg\n")

if(required_capacity <= robot_max_payload) {
  cat("Result: ACCEPTABLE - Robot can handle this load\n")
} else {
  cat("Result: EXCEEDED - Select larger robot or lighter gripper\n")
}

# Note about moment load
cat("\nNote: Also verify moment load (payload × distance from flange)\n")
cat("Moment at wrist:", part_weight, "kg ×", 0.3, "m =", part_weight * 0.3, "kg·m\n")
```

### Repeatability vs Accuracy

```{r repeat-vs-accuracy, echo=FALSE, fig.width=12, fig.height=5}
set.seed(42)
n <- 30
target <- c(0, 0)

# High repeatability, high accuracy
scenario1 <- data.frame(
  x = rnorm(n, 0, 0.02),
  y = rnorm(n, 0, 0.02),
  Scenario = "High Repeatability\nHigh Accuracy"
)

# High repeatability, low accuracy (biased)
scenario2 <- data.frame(
  x = rnorm(n, 0.15, 0.02),
  y = rnorm(n, 0.1, 0.02),
  Scenario = "High Repeatability\nLow Accuracy (Biased)"
)

# Low repeatability, centered
scenario3 <- data.frame(
  x = rnorm(n, 0, 0.1),
  y = rnorm(n, 0, 0.1),
  Scenario = "Low Repeatability\nCentered Average"
)

scenarios <- rbind(scenario1, scenario2, scenario3)

ggplot(scenarios, aes(x = x, y = y)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_point(aes(x = 0, y = 0), color = "red", size = 4, shape = 3, stroke = 2) +
  geom_circle(aes(x0 = 0, y0 = 0, r = 0.05), inherit.aes = FALSE,
              color = "red", linetype = "dashed") +
  facet_wrap(~Scenario, ncol = 3) +
  coord_fixed(xlim = c(-0.25, 0.25), ylim = c(-0.25, 0.25)) +
  labs(title = "Repeatability vs. Accuracy in Robot Positioning",
       subtitle = "Red crosshair = target position; dashed circle = ±0.05mm tolerance",
       x = "X Error (mm)", y = "Y Error (mm)") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  )
```

<details><summary>**Understanding the Difference**</summary>

**Repeatability:**
- Ability to return to the SAME taught position
- More important for most applications
- Quoted spec (e.g., ±0.05mm) is typically 3σ
- Achieved through consistent mechanical design and servo control

**Accuracy:**
- Ability to reach a COMMANDED position
- Important for offline programming
- Affected by mechanical tolerances, deflection, calibration
- Can be improved through calibration

**Why Repeatability Matters More:**
In most applications, the robot is taught positions by jogging to them. As long as it returns to those positions consistently (repeatability), accuracy doesn't matter. Accuracy only matters when positions are calculated (offline programming) rather than taught.
</details>

---

## Robot System Components

A complete robotic system consists of several integrated components.

### System Architecture

```{r robot-system, echo=FALSE, fig.width=14, fig.height=9}
ggplot() +
  # Manipulator
  annotate("rect", xmin = 0.5, xmax = 3, ymin = 4, ymax = 7,
           fill = "#3498db", color = "black") +
  annotate("text", x = 1.75, y = 6.5, label = "MANIPULATOR",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 1.75, y = 5.5, label = "• Mechanical arm\n• Motors & drives\n• Encoders\n• Brakes",
           color = "white", size = 3, lineheight = 0.9) +

  # End Effector
  annotate("rect", xmin = 3.5, xmax = 6, ymin = 5.5, ymax = 7,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 4.75, y = 6.7, label = "END EFFECTOR",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 4.75, y = 6, label = "Gripper, welding torch,\nspray gun, tool",
           color = "white", size = 3, lineheight = 0.9) +

  # Controller
  annotate("rect", xmin = 0.5, xmax = 3, ymin = 1, ymax = 3.5,
           fill = "#e74c3c", color = "black") +
  annotate("text", x = 1.75, y = 3.2, label = "CONTROLLER",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 1.75, y = 2.2, label = "• CPU & memory\n• Motion control\n• I/O modules\n• Safety circuits",
           color = "white", size = 3, lineheight = 0.9) +

  # Teach Pendant
  annotate("rect", xmin = 3.5, xmax = 6, ymin = 1, ymax = 3,
           fill = "#f39c12", color = "black") +
  annotate("text", x = 4.75, y = 2.7, label = "TEACH PENDANT",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 4.75, y = 1.8, label = "• Manual control\n• Programming\n• E-stop",
           color = "white", size = 3, lineheight = 0.9) +

  # External systems
  annotate("rect", xmin = 7, xmax = 10, ymin = 4.5, ymax = 6.5,
           fill = "#9b59b6", color = "black") +
  annotate("text", x = 8.5, y = 6.2, label = "EXTERNAL SYSTEMS",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 8.5, y = 5.3, label = "• PLC integration\n• Vision system\n• Force sensor",
           color = "white", size = 3, lineheight = 0.9) +

  # Safety system
  annotate("rect", xmin = 7, xmax = 10, ymin = 1.5, ymax = 4,
           fill = "#1abc9c", color = "black") +
  annotate("text", x = 8.5, y = 3.7, label = "SAFETY SYSTEM",
           color = "white", fontface = "bold", size = 4) +
  annotate("text", x = 8.5, y = 2.5, label = "• Light curtains\n• Safety mats\n• Interlocked gates\n• E-stops",
           color = "white", size = 3, lineheight = 0.9) +

  # Connections
  annotate("segment", x = 3, xend = 3.5, y = 6.25, yend = 6.25,
           arrow = arrow(length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 1.75, xend = 1.75, y = 4, yend = 3.5,
           arrow = arrow(ends = "both", length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 3, xend = 3.5, y = 2, yend = 2,
           arrow = arrow(ends = "both", length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 6, xend = 7, y = 5.5, yend = 5.5,
           arrow = arrow(ends = "both", length = unit(0.2, "cm")), size = 1) +
  annotate("segment", x = 3, xend = 7, y = 2.75, yend = 2.75,
           arrow = arrow(ends = "both", length = unit(0.2, "cm")), size = 1, linetype = "dashed") +

  coord_cartesian(xlim = c(0, 10.5), ylim = c(0.5, 7.5)) +
  labs(title = "Industrial Robot System Components",
       subtitle = "Integrated system of manipulator, controller, teach pendant, and peripherals") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### End Effectors (EOAT)

**End of Arm Tooling (EOAT)** is the device attached to the robot's wrist to interact with parts.

```{r end-effectors, echo=FALSE}
eoat <- data.frame(
  Type = c("Mechanical Gripper", "Vacuum Gripper", "Magnetic Gripper",
           "Welding Torch", "Spray Gun", "Deburring Tool",
           "Force/Torque Sensor", "Vision Camera"),
  Principle = c(
    "Fingers actuated by pneumatic, electric, or hydraulic",
    "Suction cups powered by venturi or vacuum pump",
    "Electromagnetic or permanent magnet",
    "MIG, TIG, spot welding equipment",
    "Paint, adhesive, sealant dispensing",
    "Rotary tool for edge finishing",
    "Measures forces and torques at tool",
    "2D or 3D imaging for guidance"
  ),
  Applications = c(
    "General part handling; assembly",
    "Flat surfaces; sheet material; boxes",
    "Ferrous metal parts; steel sheets",
    "Automotive body, frames, components",
    "Automotive painting; sealing",
    "Casting, machining finishing",
    "Assembly; polishing; insertion",
    "Part location; inspection; guidance"
  ),
  Considerations = c(
    "Part geometry; grip force; cycle time",
    "Surface porosity; part weight; seal",
    "Part material; residual magnetism",
    "Process parameters; wire feed; shielding",
    "Pattern; coverage; waste",
    "Speed; pressure; consistency",
    "Sensitivity; overload protection",
    "Resolution; lighting; processing speed"
  )
)

kable(eoat, col.names = c("EOAT Type", "Operating Principle", "Applications", "Key Considerations"),
      caption = "Common End Effector Types") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "16%")
```

### Gripper Selection Example

```{r gripper-selection, echo=TRUE}
# Gripper Force Calculation
part_mass <- 3.0        # kg
acceleration <- 15      # m/s² (robot acceleration)
gravity <- 9.81         # m/s²
safety_factor <- 2.0    # Minimum safety factor
friction_coefficient <- 0.3  # Steel on rubber

# Calculate forces
weight_force <- part_mass * gravity
inertia_force <- part_mass * acceleration
total_force <- sqrt(weight_force^2 + inertia_force^2)

# Required grip force (friction gripper)
required_grip <- total_force / friction_coefficient * safety_factor

cat("Gripper Force Calculation:\n")
cat("─────────────────────────────\n")
cat("Part mass:", part_mass, "kg\n")
cat("Weight force:", round(weight_force, 1), "N\n")
cat("Inertia force:", round(inertia_force, 1), "N\n")
cat("Combined force:", round(total_force, 1), "N\n")
cat("Friction coefficient:", friction_coefficient, "\n")
cat("Safety factor:", safety_factor, "\n")
cat("─────────────────────────────\n")
cat("Required grip force:", round(required_grip, 1), "N\n")
cat("\nSelect gripper with grip force ≥", ceiling(required_grip/10)*10, "N\n")
```

---

## Coordinate Systems and Motion

Understanding coordinate systems is essential for robot programming.

### Coordinate Frames

```{r coordinate-frames, echo=FALSE, fig.width=12, fig.height=8}
ggplot() +
  # World/Base coordinate system
  annotate("segment", x = 1, xend = 2.5, y = 1, yend = 1,
           arrow = arrow(length = unit(0.2, "cm")), color = "red", size = 1.2) +
  annotate("segment", x = 1, xend = 1, y = 1, yend = 2.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "green", size = 1.2) +
  annotate("point", x = 1, y = 1, size = 6, color = "#34495e") +
  annotate("text", x = 2.7, y = 1, label = "X", color = "red", fontface = "bold") +
  annotate("text", x = 1, y = 2.7, label = "Y", color = "green", fontface = "bold") +
  annotate("text", x = 1, y = 0.5, label = "World/Base Frame\n(Fixed)", size = 3,
           lineheight = 0.9, fontface = "bold") +

  # Tool coordinate system
  annotate("segment", x = 6, xend = 7.2, y = 4.5, yend = 5,
           arrow = arrow(length = unit(0.2, "cm")), color = "red", size = 1.2) +
  annotate("segment", x = 6, xend = 5.5, y = 4.5, yend = 5.7,
           arrow = arrow(length = unit(0.2, "cm")), color = "green", size = 1.2) +
  annotate("point", x = 6, y = 4.5, size = 6, color = "#9b59b6") +
  annotate("text", x = 7.4, y = 5, label = "X", color = "red", fontface = "bold") +
  annotate("text", x = 5.3, y = 5.9, label = "Y", color = "green", fontface = "bold") +
  annotate("text", x = 6, y = 3.8, label = "Tool Frame\n(Moves with robot)", size = 3,
           lineheight = 0.9, fontface = "bold") +

  # User/Work object frame
  annotate("rect", xmin = 7.5, xmax = 10, ymin = 1, ymax = 2.5,
           fill = "#f39c12", alpha = 0.3, color = "#f39c12") +
  annotate("segment", x = 7.5, xend = 9, y = 1, yend = 1,
           arrow = arrow(length = unit(0.2, "cm")), color = "red", size = 1.2) +
  annotate("segment", x = 7.5, xend = 7.5, y = 1, yend = 2.5,
           arrow = arrow(length = unit(0.2, "cm")), color = "green", size = 1.2) +
  annotate("text", x = 8.75, y = 0.5, label = "User/Work Object Frame\n(On fixture or part)",
           size = 3, lineheight = 0.9, fontface = "bold") +

  # Robot arm (simplified)
  annotate("segment", x = 1, xend = 3, y = 1, yend = 3, size = 4, color = "#3498db") +
  annotate("segment", x = 3, xend = 5, y = 3, yend = 4, size = 3, color = "#3498db") +
  annotate("segment", x = 5, xend = 6, y = 4, yend = 4.5, size = 2, color = "#3498db") +

  # Labels for coordinate types
  annotate("rect", xmin = 0, xmax = 4.5, ymin = 5.5, ymax = 7.5,
           fill = "#ecf0f1", color = "gray") +
  annotate("text", x = 0.2, y = 7.2, label = "Coordinate Types:", hjust = 0,
           fontface = "bold", size = 4) +
  annotate("text", x = 0.2, y = 6.7, label = "• Joint: J1, J2, J3, J4, J5, J6 (degrees)", hjust = 0, size = 3) +
  annotate("text", x = 0.2, y = 6.3, label = "• Cartesian: X, Y, Z, Rx, Ry, Rz (mm, degrees)", hjust = 0, size = 3) +
  annotate("text", x = 0.2, y = 5.9, label = "• Tool: Relative to end effector", hjust = 0, size = 3) +

  coord_cartesian(xlim = c(-0.5, 10.5), ylim = c(0, 8)) +
  labs(title = "Robot Coordinate Systems",
       subtitle = "Different reference frames for programming and motion") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Motion Types

```{r motion-types, echo=FALSE}
motion_table <- data.frame(
  Motion_Type = c("Joint Move (MoveJ)", "Linear Move (MoveL)", "Circular Move (MoveC)"),
  Path = c(
    "Unpredictable path; each joint moves at constant speed",
    "Straight line from start to end; TCP follows linear path",
    "Arc or circle; defined by start, via, and end points"
  ),
  Speed_Control = c(
    "Joint velocity (% or deg/s)",
    "TCP velocity (mm/s)",
    "TCP velocity (mm/s)"
  ),
  When_to_Use = c(
    "Fast point-to-point; collision-free space; approach moves",
    "Process paths (welding, sealing); precise positioning",
    "Arc welding; edge following; contoured surfaces"
  ),
  Cycle_Time = c("Fastest", "Moderate", "Slowest")
)

kable(motion_table, col.names = c("Motion Type", "Path Characteristic",
                                   "Speed Control", "When to Use", "Cycle Time"),
      caption = "Robot Motion Types") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "16%")
```

```{r motion-visualization, echo=FALSE, fig.width=11, fig.height=5}
# Visualize motion types
t <- seq(0, 1, length.out = 50)

# Joint motion (curved path)
joint_path <- data.frame(
  x = sin(t * pi) * 100 + 50,
  y = (1 - cos(t * pi)) * 50 + 20,
  Type = "Joint Move"
)

# Linear motion (straight)
linear_path <- data.frame(
  x = t * 100 + 50,
  y = t * 100 + 20,
  Type = "Linear Move"
)

# Circular motion (arc)
theta <- t * pi
circular_path <- data.frame(
  x = 100 + 50 * cos(theta + pi),
  y = 70 + 50 * sin(theta + pi),
  Type = "Circular Move"
)

paths <- rbind(joint_path, linear_path, circular_path)

ggplot(paths, aes(x = x, y = y, color = Type)) +
  geom_path(size = 1.5) +
  geom_point(data = paths[paths$Type == "Joint Move",][c(1, 50),],
             size = 4, shape = 21, fill = "white") +
  geom_point(data = paths[paths$Type == "Linear Move",][c(1, 50),],
             size = 4, shape = 21, fill = "white") +
  geom_point(data = paths[paths$Type == "Circular Move",][c(1, 25, 50),],
             size = 4, shape = 21, fill = "white") +
  scale_color_manual(values = c("#27ae60", "#3498db", "#e74c3c")) +
  facet_wrap(~Type, ncol = 3) +
  labs(title = "Robot Motion Types Visualized",
       subtitle = "White dots indicate programmed points",
       x = "X Position", y = "Y Position") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "none",
    strip.text = element_text(face = "bold")
  )
```

---

## Robot Applications

### Automotive Applications

```{r auto-applications, echo=FALSE, fig.width=12, fig.height=7}
auto_apps <- data.frame(
  Application = c("Spot Welding", "Arc Welding", "Painting", "Assembly",
                  "Material Handling", "Inspection"),
  Robot_Type = c("6-axis, heavy payload", "6-axis", "6-axis, hollow wrist",
                 "6-axis or SCARA", "6-axis or gantry", "6-axis with vision"),
  Typical_Robot = c("FANUC R-2000, KUKA KR 240", "Yaskawa AR series",
                    "ABB IRB 5500, FANUC P-series", "Universal Robots, FANUC LR Mate",
                    "FANUC M-710, ABB IRB 6700", "FANUC with iRVision"),
  Key_Metrics = c("Weld quality, cycle time", "Seam tracking, penetration",
                  "Coverage, film thickness", "Precision, flexibility",
                  "Throughput, reliability", "Detection rate, false positive"),
  x = c(1, 2, 3, 1, 2, 3),
  y = c(2, 2, 2, 1, 1, 1)
)

ggplot(auto_apps, aes(x = x, y = y)) +
  geom_tile(aes(fill = Application), width = 0.95, height = 0.9, color = "white", size = 2) +
  geom_text(aes(label = Application), fontface = "bold", size = 4, color = "white", vjust = -1.5) +
  geom_text(aes(label = paste0("Robot: ", Robot_Type)), size = 2.5, color = "white", vjust = 0) +
  geom_text(aes(label = Key_Metrics), size = 2.5, color = "white",
            fontface = "italic", vjust = 2) +
  scale_fill_manual(values = c("#e74c3c", "#3498db", "#27ae60",
                               "#f39c12", "#9b59b6", "#1abc9c"), guide = "none") +
  labs(title = "Automotive Robot Applications",
       subtitle = "Common applications in automotive manufacturing") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

### Food & Beverage Applications

```{r food-applications, echo=FALSE}
food_apps <- data.frame(
  Application = c("Palletizing", "Case Packing", "Pick and Place",
                  "Cutting/Portioning", "Decorating", "Quality Inspection"),
  Description = c(
    "Stack cases/bags onto pallets in patterns",
    "Load products into cases/cartons",
    "Transfer products between conveyors/stations",
    "Protein portioning, cake cutting",
    "Applying icing, toppings, decorations",
    "Vision-based defect detection, grading"
  ),
  Robot_Type = c("4-axis palletizer, 6-axis", "Delta, SCARA, 6-axis",
                 "Delta (high speed), SCARA", "6-axis with vision",
                 "6-axis, delta", "6-axis with vision"),
  Special_Requirements = c(
    "IP65+, washdown, food-safe lubricants",
    "High speed, gentle handling",
    "Extremely fast cycles, hygienic design",
    "Precise cutting, washdown capable",
    "Food-grade materials, precise dispensing",
    "Hygienic design, reliable detection"
  )
)

kable(food_apps, col.names = c("Application", "Description", "Robot Type", "Special Requirements"),
      caption = "Food & Beverage Robot Applications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "16%")
```

### Aerospace/Defense Applications

```{r aerospace-applications, echo=FALSE}
aero_apps <- data.frame(
  Application = c("Drilling & Fastening", "Composite Layup",
                  "NDT/Inspection", "Surface Treatment", "Assembly"),
  Description = c(
    "Precision hole drilling; rivet/bolt installation",
    "Automated fiber placement (AFP); tape laying",
    "Ultrasonic, X-ray, visual inspection of structures",
    "Painting, coating, surface prep for bonding",
    "Large structure assembly; wing-to-fuselage"
  ),
  Accuracy_Required = c("±0.05mm position", "±0.25mm fiber placement",
                        "Full coverage", "Consistent thickness", "±0.5mm"),
  Challenges = c(
    "Drill normal to curved surfaces; chip management",
    "Complex contours; material handling",
    "Large part access; data management",
    "Large envelopes; environmental control",
    "Heavy payloads; coordination of multiple robots"
  )
)

kable(aero_apps, col.names = c("Application", "Description", "Accuracy Required", "Challenges"),
      caption = "Aerospace/Defense Robot Applications") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "16%")
```

---

## Robot Safety

Robot safety is critical to protect workers from potential hazards.

### Hazard Categories

```{r robot-hazards, echo=FALSE}
hazards <- data.frame(
  Hazard = c("Impact", "Crushing", "Trapping", "Ejection", "Other"),
  Description = c(
    "Robot strikes person with arm or tooling",
    "Person caught between robot and fixed object",
    "Body part caught in articulating joints or mechanisms",
    "Part or tool flies off due to grip failure or breakage",
    "Electrical, thermal, noise, radiation hazards"
  ),
  Risk_Factors = c(
    "Speed, mass, sharp edges, unexpected motion",
    "Limited escape space, high forces",
    "Pinch points at joints, insufficient clearance",
    "Grip force, centrifugal force, tool condition",
    "Voltage, heat, welding arc, laser"
  ),
  Mitigation = c(
    "Guarding, reduced speed zones, sensors",
    "Minimum clearances, presence detection",
    "Joint covers, clearance design",
    "Grip verification, part detection, enclosure",
    "Proper grounding, barriers, PPE"
  )
)

kable(hazards, caption = "Robot Hazard Categories and Mitigations") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "12%")
```

### Safety Standards

```{r safety-standards, echo=FALSE}
standards <- data.frame(
  Standard = c("ISO 10218-1:2011", "ISO 10218-2:2011", "ISO/TS 15066:2016",
               "ANSI/RIA R15.06", "ANSI/RIA R15.08"),
  Scope = c(
    "Robot manufacturer requirements",
    "Robot system integrator requirements",
    "Collaborative robot safety",
    "US equivalent to ISO 10218",
    "Industrial mobile robots"
  ),
  Key_Requirements = c(
    "Stop functions, speed limiting, singularity protection",
    "Risk assessment, safeguarding, layout, validation",
    "Force/pressure limits, speed/separation monitoring",
    "Safeguarding devices, risk assessment",
    "Navigation safety, personnel detection"
  )
)

kable(standards, col.names = c("Standard", "Scope", "Key Requirements"),
      caption = "Key Robot Safety Standards") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Safeguarding Methods

```{r safeguarding, echo=FALSE, fig.width=13, fig.height=8}
ggplot() +
  # Robot cell outline
  annotate("rect", xmin = 2, xmax = 8, ymin = 1, ymax = 6,
           fill = "#f8f9fa", color = "black", linetype = "dashed", size = 1) +

  # Robot
  annotate("point", x = 5, y = 3.5, size = 15, color = "#3498db") +
  annotate("text", x = 5, y = 3.5, label = "Robot", color = "white",
           fontface = "bold", size = 3) +

  # Physical barrier (fence)
  annotate("segment", x = 2, xend = 2, y = 1, yend = 6, color = "#e74c3c", size = 3) +
  annotate("segment", x = 8, xend = 8, y = 1, yend = 3, color = "#e74c3c", size = 3) +
  annotate("segment", x = 8, xend = 8, y = 4.5, yend = 6, color = "#e74c3c", size = 3) +
  annotate("text", x = 1.5, y = 3.5, label = "Safety\nFence",
           color = "#e74c3c", fontface = "bold", size = 3, lineheight = 0.9) +

  # Light curtain
  annotate("segment", x = 8, xend = 8, y = 3, yend = 4.5,
           color = "#f39c12", size = 2, linetype = "dotted") +
  annotate("rect", xmin = 7.8, xmax = 8.2, ymin = 3, ymax = 3.3,
           fill = "#f39c12", color = "black") +
  annotate("rect", xmin = 7.8, xmax = 8.2, ymin = 4.2, ymax = 4.5,
           fill = "#f39c12", color = "black") +
  annotate("text", x = 9, y = 3.75, label = "Light\nCurtain",
           color = "#f39c12", fontface = "bold", size = 3, lineheight = 0.9) +

  # Interlocked gate
  annotate("rect", xmin = 4, xmax = 6, ymin = 0.8, ymax = 1.2,
           fill = "#27ae60", color = "black") +
  annotate("text", x = 5, y = 0.5, label = "Interlocked Gate",
           color = "#27ae60", fontface = "bold", size = 3) +

  # Safety mat
  annotate("rect", xmin = 2.5, xmax = 4, ymin = 1.5, ymax = 2.5,
           fill = "#9b59b6", alpha = 0.5, color = "#9b59b6") +
  annotate("text", x = 3.25, y = 2, label = "Safety\nMat",
           color = "#9b59b6", fontface = "bold", size = 2.5, lineheight = 0.9) +

  # E-stop
  annotate("point", x = 1.5, y = 5.5, size = 8, color = "red") +
  annotate("text", x = 1.5, y = 5.5, label = "E", color = "white",
           fontface = "bold", size = 3) +
  annotate("text", x = 1.5, y = 5, label = "E-Stop", size = 2.5) +

  # Scanner (area scanner)
  annotate("point", x = 7, y = 2, size = 6, color = "#1abc9c") +
  annotate("curve", x = 7, xend = 8.5, y = 2, yend = 1.5,
           curvature = 0.3, color = "#1abc9c", linetype = "dashed") +
  annotate("curve", x = 7, xend = 8.5, y = 2, yend = 2.5,
           curvature = -0.3, color = "#1abc9c", linetype = "dashed") +
  annotate("text", x = 7, y = 1.3, label = "Area\nScanner",
           color = "#1abc9c", fontface = "bold", size = 2.5, lineheight = 0.9) +

  # Legend
  annotate("rect", xmin = 9.5, xmax = 13, ymin = 1, ymax = 6,
           fill = "#f8f9fa", color = "gray") +
  annotate("text", x = 9.7, y = 5.7, label = "Safeguarding Devices:",
           hjust = 0, fontface = "bold", size = 3.5) +
  annotate("segment", x = 9.7, xend = 10.2, y = 5.3, yend = 5.3, color = "#e74c3c", size = 2) +
  annotate("text", x = 10.4, y = 5.3, label = "Physical Barrier", hjust = 0, size = 2.8) +
  annotate("segment", x = 9.7, xend = 10.2, y = 4.9, yend = 4.9,
           color = "#f39c12", size = 2, linetype = "dotted") +
  annotate("text", x = 10.4, y = 4.9, label = "Light Curtain", hjust = 0, size = 2.8) +
  annotate("rect", xmin = 9.7, xmax = 10.2, ymin = 4.4, ymax = 4.6, fill = "#27ae60") +
  annotate("text", x = 10.4, y = 4.5, label = "Interlocked Gate", hjust = 0, size = 2.8) +
  annotate("rect", xmin = 9.7, xmax = 10.2, ymin = 4, ymax = 4.2, fill = "#9b59b6", alpha = 0.5) +
  annotate("text", x = 10.4, y = 4.1, label = "Safety Mat", hjust = 0, size = 2.8) +
  annotate("point", x = 9.95, y = 3.7, size = 4, color = "#1abc9c") +
  annotate("text", x = 10.4, y = 3.7, label = "Area Scanner", hjust = 0, size = 2.8) +
  annotate("point", x = 9.95, y = 3.3, size = 4, color = "red") +
  annotate("text", x = 10.4, y = 3.3, label = "E-Stop", hjust = 0, size = 2.8) +

  coord_cartesian(xlim = c(0.5, 13.5), ylim = c(0, 6.5)) +
  labs(title = "Robot Cell Safeguarding Methods",
       subtitle = "Multiple layers of protection for personnel safety") +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )
```

---

## Collaborative Robots (Cobots)

**Collaborative robots** are designed to work safely alongside humans without traditional guarding.

### Cobot Characteristics

```{r cobot-comparison, echo=FALSE}
cobot_compare <- data.frame(
  Characteristic = c("Safety Approach", "Payload", "Speed", "Reach",
                     "Programming", "Guarding", "Investment", "Applications"),
  Traditional_Robot = c(
    "Safeguarded cell; humans excluded",
    "Up to 2300 kg",
    "Very high (>2 m/s)",
    "Up to 4 m",
    "Specialized programmers",
    "Required (fences, curtains)",
    "High ($50K-500K+ with cell)",
    "High-volume, dedicated tasks"
  ),
  Collaborative_Robot = c(
    "Inherently safe; force/speed limited",
    "Typically 3-35 kg",
    "Limited (<1.5 m/s typically)",
    "500-1300 mm typical",
    "Intuitive; hand guiding",
    "Often not required",
    "Lower ($25K-75K typical)",
    "Flexible, shared workspace"
  )
)

kable(cobot_compare, col.names = c("", "Traditional Industrial Robot", "Collaborative Robot"),
      caption = "Traditional Robot vs. Collaborative Robot Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%") %>%
  column_spec(2, background = "#fadbd8") %>%
  column_spec(3, background = "#d5f5e3")
```

### Collaborative Operation Modes (ISO/TS 15066)

```{r cobot-modes, echo=FALSE}
cobot_modes <- data.frame(
  Mode = c("Safety-Rated Monitored Stop", "Hand Guiding",
           "Speed and Separation Monitoring", "Power and Force Limiting"),
  Description = c(
    "Robot stops when human enters collaborative zone; resumes when clear",
    "Operator physically guides robot; robot follows input forces",
    "Robot adjusts speed based on distance to human; stops if too close",
    "Robot limits force/pressure on contact to safe levels"
  ),
  Application = c(
    "Loading/unloading where human enters occasionally",
    "Teaching positions; flexible positioning tasks",
    "Shared workspace with variable human presence",
    "Direct human-robot collaboration; assembly assist"
  ),
  Requirements = c(
    "Safety-rated sensors; safe zone definition",
    "Emergency stop; safe torque control",
    "Distance sensing; certified safety functions",
    "Compliant design; verified force limits"
  )
)

kable(cobot_modes, col.names = c("Collaboration Mode", "Description", "Application", "Requirements"),
      caption = "ISO/TS 15066 Collaborative Operation Modes") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "20%")
```

### Force and Pressure Limits

ISO/TS 15066 specifies maximum contact forces and pressures for different body areas:

```{r force-limits, echo=FALSE}
force_limits <- data.frame(
  Body_Area = c("Skull/Forehead", "Face", "Neck (front/back)", "Chest",
                "Abdomen", "Hand/Finger", "Arm", "Leg"),
  Max_Pressure_Transient = c(130, 65, 145, 140, 110, 280, 190, 220),
  Max_Pressure_QuasiStatic = c(130, 65, 145, 140, 110, 280, 190, 220),
  Max_Force_Transient = c(130, 65, 150, 140, 110, 140, 150, 220),
  Max_Force_QuasiStatic = c(130, 65, 150, 140, 110, 140, 150, 220)
)

kable(force_limits, col.names = c("Body Area", "Max Pressure (N/cm²)", "Quasi-Static Pressure",
                                   "Max Force (N)", "Quasi-Static Force"),
      caption = "ISO/TS 15066 Biomechanical Limits (Selected Values)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

---

## Robot Programming Basics

### Programming Methods

```{r programming-methods, echo=FALSE}
prog_methods <- data.frame(
  Method = c("Online/Teach Pendant", "Lead-Through/Hand Guiding",
             "Offline Programming", "Simulation-Based"),
  Description = c(
    "Use teach pendant to jog robot to positions and record",
    "Physically move robot arm to desired positions",
    "Create programs on PC without robot; download later",
    "Program and test in virtual environment; transfer to real robot"
  ),
  Advantages = c(
    "Direct; precise; see actual positions",
    "Intuitive; fast for simple paths; no programming skill needed",
    "No production downtime; complex paths; optimization",
    "Risk-free testing; cycle time estimation; collision checking"
  ),
  Disadvantages = c(
    "Production downtime; time-consuming for complex paths",
    "Limited to cobot-style robots; not precise",
    "Requires accurate cell model; calibration needed",
    "Model accuracy critical; license costs"
  )
)

kable(prog_methods, caption = "Robot Programming Methods Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "18%")
```

### Basic Program Structure

```{r program-structure, echo=FALSE}
program_example <- '
PROGRAM Main()

  ! Initialize
  HomePosition()
  GripperOpen()

  ! Main cycle
  WHILE running DO

    ! Move to pick position
    MoveJ pApproach, v500, z50, tool1
    MoveL pPick, v100, fine, tool1

    ! Pick part
    GripperClose()
    WaitTime 0.2

    ! Move to place position
    MoveL pApproach, v200, z50, tool1
    MoveJ pPlaceApproach, v500, z50, tool1
    MoveL pPlace, v100, fine, tool1

    ! Place part
    GripperOpen()
    WaitTime 0.2

    ! Return
    MoveL pPlaceApproach, v200, z50, tool1

    ! Increment counter
    PartCount := PartCount + 1

  ENDWHILE

ENDPROGRAM
'

cat("Example Robot Program (ABB RAPID-style pseudocode):\n")
cat("────────────────────────────────────────────────────\n")
cat(program_example)
```

### Key Programming Concepts

```{r programming-concepts, echo=FALSE}
concepts <- data.frame(
  Concept = c("Position/Target", "Motion Instruction", "Speed Data",
              "Zone Data", "Tool Data", "Work Object", "I/O Commands"),
  Description = c(
    "Stored robot position (joint angles or Cartesian coordinates)",
    "Command to move robot (MoveJ, MoveL, MoveC)",
    "Velocity parameter (mm/s for TCP, % for joints)",
    "Corner path blending (fine = stop at point, z10 = 10mm blend)",
    "Definition of tool center point relative to flange",
    "Definition of work coordinate system for part positions",
    "Control external devices (SetDO, WaitDI, etc.)"
  ),
  Example = c(
    "pHome, pPick, pPlace",
    "MoveL pTarget, v100, fine, tool1",
    "v100 = 100 mm/s, v500 = 500 mm/s",
    "fine = stop, z5 = 5mm radius blend",
    "tool1 with TCP offset [0, 0, 150, 0, 0, 0]",
    "wobj_fixture with base offset",
    "SetDO doGripper, 1; WaitDI diPartPresent, 1"
  )
)

kable(concepts, caption = "Key Robot Programming Concepts") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = TRUE) %>%
  column_spec(1, bold = TRUE, width = "16%")
```

---

## Video Resources

### Introduction to Industrial Robots

<iframe width="560" height="315" src="https://www.youtube.com/embed/2O7yj9g_oRQ" title="Industrial Robots Introduction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Collaborative Robots Explained

<iframe width="560" height="315" src="https://www.youtube.com/embed/KIw3iQKC6BE" title="Collaborative Robots" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Summary

Industrial robotics is a fundamental technology in modern manufacturing:

1. **Robot types** include articulated (most versatile), SCARA (fast assembly), delta (high-speed picking), and cartesian (large work areas)
2. **Key specifications** include payload, reach, repeatability, speed, and degrees of freedom
3. **System components** work together: manipulator, controller, teach pendant, end effector, and safety system
4. **Coordinate systems** (world, tool, user) enable flexible programming and positioning
5. **Applications** span automotive, food & beverage, and aerospace with industry-specific requirements
6. **Safety** requires comprehensive risk assessment and appropriate safeguarding
7. **Collaborative robots** enable human-robot cooperation with force/speed limiting
8. **Programming** can be online (teach pendant), lead-through, or offline

---

## Review Questions

<details><summary>**Question 1**: Compare articulated (6-axis) robots, SCARA robots, and delta robots. For each, describe the typical applications and key advantages.</summary>

**Answer:**

| Robot Type | Configuration | Key Advantages | Typical Applications |
|------------|---------------|----------------|---------------------|
| **6-Axis Articulated** | 6 revolute joints; human-like arm | Maximum flexibility; can reach any orientation; large payload range | Welding, painting, assembly, material handling, machine tending |
| **SCARA** | 4 axes; selective compliance | Very fast horizontal motion; rigid vertical; compact; precise | Pick-and-place, assembly, screw driving, packaging |
| **Delta (Parallel)** | 3-4 axes; parallel linkage | Extremely fast (150+ picks/min); low moving mass | High-speed picking, packaging, sorting, light assembly |

**Detailed Comparison:**

**6-Axis Articulated:**
- Most versatile - can position tool at any angle
- Wide payload range (3 kg to 2300+ kg)
- Can reach around obstacles
- Complex programming possible
- *Best for:* Tasks requiring complex orientations, welding seams, painting

**SCARA:**
- Inherently rigid in Z (vertical) - good for insertion
- Very fast in X-Y plane
- Lower cost than 6-axis
- Compact footprint
- *Best for:* Assembly operations, circuit board population, packaging

**Delta:**
- Highest speed of any configuration
- Low inertia (motors at base, not moving)
- Limited payload (typically <15 kg)
- Requires overhead mounting
- *Best for:* High-speed sorting, packaging lines, food handling
</details>

<details><summary>**Question 2**: A robot has a maximum payload of 15 kg. The gripper weighs 4 kg and the part weighs 8 kg. Is this robot suitable? What other factors should be considered?</summary>

**Answer:**

**Initial Assessment:**
```
Total load = Gripper weight + Part weight
Total load = 4 kg + 8 kg = 12 kg

Robot capacity: 15 kg
Load: 12 kg
Remaining margin: 3 kg (20%)
```

**Consideration with Safety Factor:**
```
Typical safety factor: 1.2 - 1.5
Required capacity = 12 kg × 1.25 = 15 kg

This equals the robot's maximum capacity - marginal!
```

**Additional Factors to Consider:**

1. **Moment Load (Torque at Wrist)**
   - Distance from flange to center of gravity matters
   - If part is held 300mm from flange: Moment = 8 kg × 0.3 m = 2.4 kg·m
   - Robot specs include moment limits - must verify

2. **Inertia**
   - Fast motion requires acceleration
   - Higher mass + longer distance = higher inertia
   - May need to derate payload for high-speed applications

3. **Payload Derating with Reach**
   - Many robots derate payload at extended reach
   - 15 kg at 500mm may become 10 kg at 1500mm
   - Check payload diagram in robot specifications

4. **Orientation**
   - Payload may vary with wrist orientation
   - Horizontal reach vs. vertical lift differ

5. **Acceleration Requirements**
   - Higher acceleration = higher effective load
   - May need to reduce speed/acceleration

**Recommendation:**
The 15 kg robot is marginal for this application. Consider:
- Select next size up (20 kg) for adequate margin
- Use lighter gripper (3 kg or less)
- Reduce part handling distance from flange
- Limit acceleration/speed if using this robot
</details>

<details><summary>**Question 3**: Explain the difference between repeatability and accuracy. Why is repeatability often more important than accuracy for robot applications?</summary>

**Answer:**

**Definitions:**

**Repeatability:**
- Ability to return to the **same taught position** multiple times
- Measures consistency/precision of motion
- Quoted as ± value (e.g., ±0.05 mm at 3σ)
- Affected by: mechanical wear, servo control, thermal effects

**Accuracy:**
- Ability to reach a **commanded position** exactly
- Measures how close actual position is to theoretical position
- Typically worse than repeatability (e.g., ±0.5 mm)
- Affected by: manufacturing tolerances, calibration, deflection, backlash

**Why Repeatability is Usually More Important:**

1. **Teaching Method**
   - Most robots are programmed by teaching (jogging to positions)
   - Robot doesn't need to know where it "should" be - just return to where it was taught
   - As long as it returns consistently (repeatability), accuracy doesn't matter

2. **Process Requirements**
   - Welding: Need to follow same seam every time → repeatability
   - Assembly: Need to insert part in same hole every time → repeatability
   - Pick-place: Need to pick from same fixture position → repeatability

3. **Compensation Possible**
   - Poor accuracy can be compensated by adjusting taught points
   - Poor repeatability cannot be compensated

**When Accuracy Matters:**

1. **Offline Programming**
   - Positions calculated from CAD data, not taught
   - Robot must go where commanded, first time
   - Common in aerospace (large parts, tight access)

2. **Multi-Robot Systems**
   - Robots must agree on positions
   - Calibration to common frame requires accuracy

3. **Frequent Program Changes**
   - If programs are frequently changed without re-teaching
   - Offline modifications need accurate execution

**Bottom Line:**
For most industrial applications, ±0.05 mm repeatability is far more valuable than ±0.5 mm accuracy because taught positions are used.
</details>

<details><summary>**Question 4**: Describe the four collaborative operation modes defined in ISO/TS 15066. Give an example application for each.</summary>

**Answer:**

**1. Safety-Rated Monitored Stop**

*Description:* Robot operates at normal speed when workspace is clear. When a person enters the collaborative zone, the robot stops and holds position. Robot resumes automatically when person exits.

*Technical Requirements:*
- Safety-rated sensors (light curtains, scanners)
- Safety-rated monitored stop function
- Clearly defined collaborative zone

*Example Application:* Machine tending cell where operator occasionally loads raw material. Robot works at full speed during machining cycle but stops safely when operator enters to load/unload.

---

**2. Hand Guiding**

*Description:* Operator physically contacts the robot through a hand guiding device and manually moves it. Robot follows operator's force input.

*Technical Requirements:*
- Hand guiding device (force/torque sensing)
- Emergency stop accessible at guiding device
- Speed reduction while guiding
- Safe torque control

*Example Application:* Teaching a paint path on an aerospace component. Operator guides robot along surface contour while robot records positions. Also used for "collaborative finishing" where operator guides robot holding a polishing tool.

---

**3. Speed and Separation Monitoring**

*Description:* Robot continuously monitors distance to the nearest person. Speed adjusts based on separation: full speed when far, reduced speed when closer, stop if minimum distance breached.

*Technical Requirements:*
- Safety-rated distance monitoring (usually area scanners)
- Safety-rated speed control
- Multiple speed/distance zones defined
- Real-time separation calculation

*Example Application:* Shared packaging area where robot palletizes cases while operator moves around the cell. Robot slows when operator approaches, stops if too close, and resumes at appropriate speed as operator moves away.

---

**4. Power and Force Limiting**

*Description:* Robot is designed so that forces and pressures from any contact are below injury thresholds. Contact is allowed because it cannot cause harm.

*Technical Requirements:*
- Inherently safe design (compliant joints, low mass, rounded surfaces)
- Force/torque sensing or current monitoring
- Verified force limits per ISO/TS 15066 body area tables
- May include padding/soft covers

*Example Application:* Assembly assist where robot holds a heavy part while human worker installs fasteners. Robot and human are in direct contact, with robot providing position support and human providing dexterity. Force is limited so accidental contact causes no injury.
</details>

<details><summary>**Question 5**: Calculate the required gripper force for a robot picking a 2 kg part with a friction coefficient of 0.4. The robot accelerates at 10 m/s². Use a safety factor of 2.0.</summary>

**Answer:**

```{r q5-answer, echo=TRUE}
# Given values
mass <- 2.0            # kg
acceleration <- 10     # m/s²
gravity <- 9.81        # m/s²
friction_coef <- 0.4   # Coefficient of friction
safety_factor <- 2.0   # Safety factor

# Calculate forces
# Weight force (vertical)
F_gravity <- mass * gravity

# Inertia force (from acceleration)
F_inertia <- mass * acceleration

# Combined force (vector sum for worst case)
# Worst case: acceleration horizontal while holding against gravity
F_combined <- sqrt(F_gravity^2 + F_inertia^2)

# Required friction force to hold part
# F_friction = μ × F_normal
# F_normal = Grip force
# F_friction must overcome F_combined

# Without safety factor:
F_grip_min <- F_combined / friction_coef

# With safety factor:
F_grip_required <- F_grip_min * safety_factor

cat("Gripper Force Calculation:\n")
cat("═══════════════════════════════════════\n\n")
cat("Input Parameters:\n")
cat("  Part mass:", mass, "kg\n")
cat("  Robot acceleration:", acceleration, "m/s²\n")
cat("  Friction coefficient:", friction_coef, "\n")
cat("  Safety factor:", safety_factor, "\n\n")

cat("Force Analysis:\n")
cat("  Gravity force: F_g = m × g =", mass, "×", gravity, "=",
    round(F_gravity, 1), "N\n")
cat("  Inertia force: F_i = m × a =", mass, "×", acceleration, "=",
    round(F_inertia, 1), "N\n")
cat("  Combined force: F_c = √(F_g² + F_i²) =", round(F_combined, 1), "N\n\n")

cat("Grip Force Calculation:\n")
cat("  F_friction = μ × F_grip ≥ F_combined\n")
cat("  F_grip ≥ F_combined / μ =", round(F_combined, 1), "/", friction_coef,
    "=", round(F_grip_min, 1), "N\n")
cat("  With safety factor:", round(F_grip_min, 1), "×", safety_factor,
    "=", round(F_grip_required, 1), "N\n\n")

cat("═══════════════════════════════════════\n")
cat("REQUIRED GRIPPER FORCE:", ceiling(F_grip_required), "N minimum\n")
cat("Select gripper rated for ≥", ceiling(F_grip_required/10)*10, "N\n")
```
</details>

<details><summary>**Question 6**: List and describe five safety devices used to protect personnel around industrial robots.</summary>

**Answer:**

**1. Physical Barriers (Safety Fencing)**

*Description:* Fixed guards or fencing that physically prevent access to the robot work envelope.

*Characteristics:*
- Rigid construction (steel, aluminum, polycarbonate)
- Must withstand expected impact forces
- Minimum height (typically ≥1.8 m)
- Properly anchored to floor
- May include interlocked gates for authorized entry

*Application:* Primary safeguard for most traditional robot cells.

---

**2. Light Curtains (AOPD - Active Opto-electronic Protective Device)**

*Description:* Transmitter and receiver create a sensing field of infrared beams. Breaking any beam triggers a stop.

*Characteristics:*
- Type 2 or Type 4 (safety-rated)
- Resolution (14mm for finger, 40mm for hand/arm)
- Muting capability for material transfer
- Very fast response (<20ms)

*Application:* Access points where frequent entry needed; allows material flow while protecting personnel.

---

**3. Safety Mats (Pressure-Sensitive Mats)**

*Description:* Floor mats that detect weight/pressure and trigger stop when stepped on.

*Characteristics:*
- Placed in hazardous zones
- Withstand industrial environment (oil, debris)
- Fast response
- Self-monitoring for failures

*Application:* Areas where overhead detection isn't practical; around robot bases.

---

**4. Area Scanners (Safety Laser Scanners)**

*Description:* Laser scanner detects objects/personnel entering defined zones. Multiple warning and stop zones configurable.

*Characteristics:*
- 270° field of view typical
- Multiple programmable zones
- Warning zone (slow robot) and stop zone (stop robot)
- Type 3 safety rating
- Detects at floor level

*Application:* Open cells requiring flexibility; mobile robot protection; speed/separation monitoring.

---

**5. Interlocked Gates/Doors**

*Description:* Access gates with safety switches that stop robot when opened.

*Characteristics:*
- Mechanical or magnetic interlock switches
- Trapped key systems for lockout
- May include guard locking (prevent opening while robot moving)
- Escape release from inside
- Meets ISO 14119

*Application:* Authorized entry points for maintenance, setup, troubleshooting.

---

**Additional Devices:**

- **E-Stop (Emergency Stop)**: Palm-operated buttons to immediately stop robot
- **Two-Hand Controls**: Require both hands on buttons to initiate motion
- **Enabling Devices**: 3-position switches held by personnel in restricted area
- **Presence-Sensing Devices**: Capacitive, radar, or vision-based detection
</details>

<details><summary>**Question 7**: Explain the difference between MoveJ (Joint Move) and MoveL (Linear Move). When would you use each?</summary>

**Answer:**

**MoveJ (Joint Move)**

*How It Works:*
- Each joint moves from start to end angle independently
- All joints start and stop together (coordinated)
- Path of TCP (Tool Center Point) is unpredictable - curved
- Robot calculates joint interpolation, not TCP path

*Characteristics:*
- Fastest point-to-point motion
- No singularity issues during move
- Path may vary depending on starting configuration
- Speed specified in % of max or joint velocity (°/s)

*When to Use:*
- Moving between distant points through free space
- Approach movements before precise positioning
- Home position moves
- Any time when path doesn't matter, only endpoints
- Escaping from near-singularity positions

---

**MoveL (Linear Move)**

*How It Works:*
- TCP follows a straight line from start to end
- Robot calculates joint positions to maintain linear TCP path
- Orientation is interpolated linearly as well
- All axes coordinated to produce straight line

*Characteristics:*
- Guaranteed straight path
- Consistent, predictable motion
- Slower than MoveJ for same endpoint distance
- Can encounter singularities during move
- Speed specified in mm/s at TCP

*When to Use:*
- Process paths (welding, sealing, cutting)
- Insertion/extraction operations
- Approach to pick/place positions
- Any time path must be straight
- When moving close to obstacles

---

**Practical Example:**

Imagine picking a part from a fixture:

```
! Move from home to near pick position - path doesn't matter
MoveJ pApproach, v1000, z50, tool1    ! Joint move - fast

! Move down to pick - must be straight to avoid collision
MoveL pPick, v100, fine, tool1        ! Linear move - controlled

! Pick part, then retract straight up
GripperClose()
MoveL pApproach, v200, z10, tool1     ! Linear move - straight up

! Move to place area - through open space
MoveJ pPlaceApproach, v1000, z50, tool1  ! Joint move - fast
```

**Key Decision:**
- If path matters → MoveL
- If only destination matters → MoveJ
</details>

<details><summary>**Question 8**: A manufacturing engineer needs to select a robot for a palletizing application. The requirements are: 25 kg payload, 2.2 m horizontal reach, 10 cycles per minute, floor-mounted. Recommend a robot type and justify your selection.</summary>

**Answer:**

**Application Analysis:**

| Requirement | Value | Implication |
|-------------|-------|-------------|
| Payload | 25 kg | Medium-heavy; rules out delta and most SCARA |
| Reach | 2.2 m | Large work envelope needed |
| Cycle rate | 10/min | 6 seconds/cycle; moderate speed |
| Mounting | Floor | Typical industrial installation |
| Motion type | Palletizing | Mainly vertical and horizontal; some rotation |

**Robot Type Evaluation:**

**1. 4-Axis Palletizing Robot (RECOMMENDED)**
- Specifically designed for palletizing
- 4 axes: base rotation, arm, elbow, wrist
- High payload capability (25-700+ kg available)
- Long reach available (up to 3.2m)
- Fast for palletizing motions
- Lower cost than 6-axis
- Examples: FANUC M-410iC, KUKA KR QUANTEC PA, ABB IRB 460

*Verdict: Excellent match for this application*

**2. 6-Axis Articulated Robot**
- Maximum flexibility
- Can handle complex pallet patterns
- Higher cost than 4-axis for same payload
- May be over-specified for simple palletizing
- Examples: FANUC M-710iC/50, ABB IRB 6700

*Verdict: Capable but potentially over-specified and more expensive*

**3. Cartesian/Gantry Robot**
- Can cover very large areas
- Simple motion control
- Higher installation complexity
- Less common for palletizing applications

*Verdict: Possible but not ideal for this payload/cycle rate*

**Recommended Selection:**

**FANUC M-410iC/185** or similar 4-axis palletizer
- Payload: 185 kg (well above 25 kg requirement with margin for gripper)
- Reach: 3.143 m (exceeds 2.2 m requirement)
- Repeatability: ±0.5 mm
- Axes: 4

**Justification:**
1. **Purpose-built**: Designed specifically for palletizing
2. **Adequate payload**: 185 kg allows for heavy gripper + multiple parts
3. **Reach**: 3.1 m provides margin for future needs
4. **Speed**: Optimized kinematics for palletizing motion profile
5. **Reliability**: Proven in thousands of palletizing applications
6. **Cost**: Lower than equivalent 6-axis robot
7. **Simplicity**: 4 axes easier to program and maintain than 6

**Additional Recommendations:**
- Vacuum or mechanical gripper depending on product
- Vision system for product detection if variety exists
- Safety scanner for operator access during pallet changes
- Interface to conveyor for product delivery
</details>

---

## References

1. Siciliano, B., & Khatib, O. (Eds.). (2016). *Springer Handbook of Robotics* (2nd ed.). Springer.

2. ISO 10218-1:2011. *Robots and Robotic Devices - Safety Requirements for Industrial Robots - Part 1: Robots*.

3. ISO 10218-2:2011. *Robots and Robotic Devices - Safety Requirements for Industrial Robots - Part 2: Robot Systems and Integration*.

4. ISO/TS 15066:2016. *Robots and Robotic Devices - Collaborative Robots*.

5. International Federation of Robotics. (2023). *World Robotics Report*. IFR.

6. Niku, S.B. (2020). *Introduction to Robotics: Analysis, Control, Applications* (3rd ed.). Wiley.

7. Craig, J.J. (2018). *Introduction to Robotics: Mechanics and Control* (4th ed.). Pearson.

8. FANUC Corporation. (2023). *Robot Technical Manuals*. FANUC.

9. ABB Robotics. (2023). *Technical Reference Manual - RAPID Instructions*. ABB.

10. Robotic Industries Association. (2023). *ANSI/RIA R15.06-2012: Industrial Robots and Robot Systems - Safety Requirements*. RIA.

<!--chapter:end:15-Industrial-Robotics.Rmd-->

